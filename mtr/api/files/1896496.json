{"id":"1896496","content":"package ch.qos.logback.core;\n\nimport ch.qos.logback.core.spi.AppenderAttachable;\nimport ch.qos.logback.core.spi.AppenderAttachableImpl;\nimport ch.qos.logback.core.util.InterruptUtil;\nimport java.util.Iterator;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\n\npublic class AsyncAppenderBase<E> extends UnsynchronizedAppenderBase<E> implements AppenderAttachable<E> {\n   AppenderAttachableImpl<E> aai = new AppenderAttachableImpl();\n   BlockingQueue<E> blockingQueue;\n   public static final int DEFAULT_QUEUE_SIZE = 256;\n   int queueSize = 256;\n   int appenderCount = 0;\n   static final int UNDEFINED = -1;\n   int discardingThreshold = -1;\n   boolean neverBlock = false;\n   AsyncAppenderBase<E>.Worker worker = new AsyncAppenderBase.Worker();\n   public static final int DEFAULT_MAX_FLUSH_TIME = 1000;\n   int maxFlushTime = 1000;\n\n   protected boolean isDiscardable(E eventObject) {\n      return false;\n   }\n\n   protected void preprocess(E eventObject) {\n   }\n\n   public void start() {\n      if (!this.isStarted()) {\n         if (this.appenderCount == 0) {\n            this.addError(\"No attached appenders found.\");\n         } else if (this.queueSize < 1) {\n            this.addError(\"Invalid queue size [\" + this.queueSize + \"]\");\n         } else {\n            this.blockingQueue = new ArrayBlockingQueue(this.queueSize);\n            if (this.discardingThreshold == -1) {\n               this.discardingThreshold = this.queueSize / 5;\n            }\n\n            this.addInfo(\"Setting discardingThreshold to \" + this.discardingThreshold);\n            this.worker.setDaemon(true);\n            this.worker.setName(\"AsyncAppender-Worker-\" + this.getName());\n            super.start();\n            this.worker.start();\n         }\n      }\n   }\n\n   public void stop() {\n      if (this.isStarted()) {\n         super.stop();\n         this.worker.interrupt();\n         InterruptUtil interruptUtil = new InterruptUtil(this.context);\n\n         try {\n            interruptUtil.maskInterruptFlag();\n            this.worker.join((long)this.maxFlushTime);\n            if (this.worker.isAlive()) {\n               this.addWarn(\"Max queue flush timeout (\" + this.maxFlushTime + \" ms) exceeded. Approximately \" + this.blockingQueue.size() + \" queued events were possibly discarded.\");\n            } else {\n               this.addInfo(\"Queue flush finished successfully within timeout.\");\n            }\n         } catch (InterruptedException var7) {\n            int remaining = this.blockingQueue.size();\n            this.addError(\"Failed to join worker thread. \" + remaining + \" queued events may be discarded.\", var7);\n         } finally {\n            interruptUtil.unmaskInterruptFlag();\n         }\n\n      }\n   }\n\n   protected void append(E eventObject) {\n      if (!this.isQueueBelowDiscardingThreshold() || !this.isDiscardable(eventObject)) {\n         this.preprocess(eventObject);\n         this.put(eventObject);\n      }\n   }\n\n   private boolean isQueueBelowDiscardingThreshold() {\n      return this.blockingQueue.remainingCapacity() < this.discardingThreshold;\n   }\n\n   private void put(E eventObject) {\n      if (this.neverBlock) {\n         this.blockingQueue.offer(eventObject);\n      } else {\n         this.putUninterruptibly(eventObject);\n      }\n\n   }\n\n   private void putUninterruptibly(E eventObject) {\n      boolean interrupted = false;\n\n      try {\n         while(true) {\n            try {\n               this.blockingQueue.put(eventObject);\n               return;\n            } catch (InterruptedException var7) {\n               interrupted = true;\n            }\n         }\n      } finally {\n         if (interrupted) {\n            Thread.currentThread().interrupt();\n         }\n\n      }\n   }\n\n   public int getQueueSize() {\n      return this.queueSize;\n   }\n\n   public void setQueueSize(int queueSize) {\n      this.queueSize = queueSize;\n   }\n\n   public int getDiscardingThreshold() {\n      return this.discardingThreshold;\n   }\n\n   public void setDiscardingThreshold(int discardingThreshold) {\n      this.discardingThreshold = discardingThreshold;\n   }\n\n   public int getMaxFlushTime() {\n      return this.maxFlushTime;\n   }\n\n   public void setMaxFlushTime(int maxFlushTime) {\n      this.maxFlushTime = maxFlushTime;\n   }\n\n   public int getNumberOfElementsInQueue() {\n      return this.blockingQueue.size();\n   }\n\n   public void setNeverBlock(boolean neverBlock) {\n      this.neverBlock = neverBlock;\n   }\n\n   public boolean isNeverBlock() {\n      return this.neverBlock;\n   }\n\n   public int getRemainingCapacity() {\n      return this.blockingQueue.remainingCapacity();\n   }\n\n   public void addAppender(Appender<E> newAppender) {\n      if (this.appenderCount == 0) {\n         ++this.appenderCount;\n         this.addInfo(\"Attaching appender named [\" + newAppender.getName() + \"] to AsyncAppender.\");\n         this.aai.addAppender(newAppender);\n      } else {\n         this.addWarn(\"One and only one appender may be attached to AsyncAppender.\");\n         this.addWarn(\"Ignoring additional appender named [\" + newAppender.getName() + \"]\");\n      }\n\n   }\n\n   public Iterator<Appender<E>> iteratorForAppenders() {\n      return this.aai.iteratorForAppenders();\n   }\n\n   public Appender<E> getAppender(String name) {\n      return this.aai.getAppender(name);\n   }\n\n   public boolean isAttached(Appender<E> eAppender) {\n      return this.aai.isAttached(eAppender);\n   }\n\n   public void detachAndStopAllAppenders() {\n      this.aai.detachAndStopAllAppenders();\n   }\n\n   public boolean detachAppender(Appender<E> eAppender) {\n      return this.aai.detachAppender(eAppender);\n   }\n\n   public boolean detachAppender(String name) {\n      return this.aai.detachAppender(name);\n   }\n\n   class Worker extends Thread {\n      public void run() {\n         AsyncAppenderBase<E> parent = AsyncAppenderBase.this;\n         AppenderAttachableImpl aai = parent.aai;\n\n         while(parent.isStarted()) {\n            try {\n               E e = parent.blockingQueue.take();\n               aai.appendLoopOnAppenders(e);\n            } catch (InterruptedException var5) {\n               break;\n            }\n         }\n\n         AsyncAppenderBase.this.addInfo(\"Worker thread will flush remaining events before exiting. \");\n         Iterator var6 = parent.blockingQueue.iterator();\n\n         while(var6.hasNext()) {\n            E ex = var6.next();\n            aai.appendLoopOnAppenders(ex);\n            parent.blockingQueue.remove(ex);\n         }\n\n         aai.detachAndStopAllAppenders();\n      }\n   }\n}\n"}