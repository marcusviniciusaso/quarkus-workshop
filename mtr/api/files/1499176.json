{"id":"1499176","content":"package ch.qos.logback.core.net;\n\nimport ch.qos.logback.core.AppenderBase;\nimport ch.qos.logback.core.Layout;\nimport ch.qos.logback.core.boolex.EvaluationException;\nimport ch.qos.logback.core.boolex.EventEvaluator;\nimport ch.qos.logback.core.helpers.CyclicBuffer;\nimport ch.qos.logback.core.pattern.PatternLayoutBase;\nimport ch.qos.logback.core.sift.DefaultDiscriminator;\nimport ch.qos.logback.core.sift.Discriminator;\nimport ch.qos.logback.core.spi.CyclicBufferTracker;\nimport ch.qos.logback.core.util.ContentTypeUtil;\nimport ch.qos.logback.core.util.JNDIUtil;\nimport ch.qos.logback.core.util.OptionHelper;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Properties;\nimport javax.mail.Multipart;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.Message.RecipientType;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\nimport javax.naming.Context;\n\npublic abstract class SMTPAppenderBase<E> extends AppenderBase<E> {\n   static InternetAddress[] EMPTY_IA_ARRAY = new InternetAddress[0];\n   static final long MAX_DELAY_BETWEEN_STATUS_MESSAGES = 1228800000L;\n   long lastTrackerStatusPrint = 0L;\n   long delayBetweenStatusMessages = 300000L;\n   protected Layout<E> subjectLayout;\n   protected Layout<E> layout;\n   private List<PatternLayoutBase<E>> toPatternLayoutList = new ArrayList();\n   private String from;\n   private String subjectStr = null;\n   private String smtpHost;\n   private int smtpPort = 25;\n   private boolean starttls = false;\n   private boolean ssl = false;\n   private boolean sessionViaJNDI = false;\n   private String jndiLocation = \"java:comp/env/mail/Session\";\n   String username;\n   String password;\n   String localhost;\n   boolean asynchronousSending = true;\n   private String charsetEncoding = \"UTF-8\";\n   protected Session session;\n   protected EventEvaluator<E> eventEvaluator;\n   protected Discriminator<E> discriminator = new DefaultDiscriminator();\n   protected CyclicBufferTracker<E> cbTracker;\n   private int errorCount = 0;\n\n   protected abstract Layout<E> makeSubjectLayout(String var1);\n\n   public void start() {\n      if (this.cbTracker == null) {\n         this.cbTracker = new CyclicBufferTracker();\n      }\n\n      if (this.sessionViaJNDI) {\n         this.session = this.lookupSessionInJNDI();\n      } else {\n         this.session = this.buildSessionFromProperties();\n      }\n\n      if (this.session == null) {\n         this.addError(\"Failed to obtain javax.mail.Session. Cannot start.\");\n      } else {\n         this.subjectLayout = this.makeSubjectLayout(this.subjectStr);\n         this.started = true;\n      }\n   }\n\n   private Session lookupSessionInJNDI() {\n      this.addInfo(\"Looking up javax.mail.Session at JNDI location [\" + this.jndiLocation + \"]\");\n\n      try {\n         Context initialContext = JNDIUtil.getInitialContext();\n         Object obj = JNDIUtil.lookupObject(initialContext, this.jndiLocation);\n         return (Session)obj;\n      } catch (Exception var3) {\n         this.addError(\"Failed to obtain javax.mail.Session from JNDI location [\" + this.jndiLocation + \"]\");\n         return null;\n      }\n   }\n\n   private Session buildSessionFromProperties() {\n      Properties props = new Properties(OptionHelper.getSystemProperties());\n      if (this.smtpHost != null) {\n         props.put(\"mail.smtp.host\", this.smtpHost);\n      }\n\n      props.put(\"mail.smtp.port\", Integer.toString(this.smtpPort));\n      if (this.localhost != null) {\n         props.put(\"mail.smtp.localhost\", this.localhost);\n      }\n\n      LoginAuthenticator loginAuthenticator = null;\n      if (!OptionHelper.isEmpty(this.username)) {\n         loginAuthenticator = new LoginAuthenticator(this.username, this.password);\n         props.put(\"mail.smtp.auth\", \"true\");\n      }\n\n      if (this.isSTARTTLS() && this.isSSL()) {\n         this.addError(\"Both SSL and StartTLS cannot be enabled simultaneously\");\n      } else {\n         if (this.isSTARTTLS()) {\n            props.put(\"mail.smtp.starttls.enable\", \"true\");\n         }\n\n         if (this.isSSL()) {\n            String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n            props.put(\"mail.smtp.socketFactory.port\", Integer.toString(this.smtpPort));\n            props.put(\"mail.smtp.socketFactory.class\", SSL_FACTORY);\n            props.put(\"mail.smtp.socketFactory.fallback\", \"true\");\n         }\n      }\n\n      return Session.getInstance(props, loginAuthenticator);\n   }\n\n   protected void append(E eventObject) {\n      if (this.checkEntryConditions()) {\n         String key = this.discriminator.getDiscriminatingValue(eventObject);\n         long now = System.currentTimeMillis();\n         CyclicBuffer<E> cb = (CyclicBuffer)this.cbTracker.getOrCreate(key, now);\n         this.subAppend(cb, eventObject);\n\n         try {\n            if (this.eventEvaluator.evaluate(eventObject)) {\n               CyclicBuffer<E> cbClone = new CyclicBuffer(cb);\n               cb.clear();\n               if (this.asynchronousSending) {\n                  SMTPAppenderBase<E>.SenderRunnable senderRunnable = new SMTPAppenderBase.SenderRunnable(cbClone, eventObject);\n                  this.context.getScheduledExecutorService().execute(senderRunnable);\n               } else {\n                  this.sendBuffer(cbClone, eventObject);\n               }\n            }\n         } catch (EvaluationException var8) {\n            ++this.errorCount;\n            if (this.errorCount < 4) {\n               this.addError(\"SMTPAppender's EventEvaluator threw an Exception-\", var8);\n            }\n         }\n\n         if (this.eventMarksEndOfLife(eventObject)) {\n            this.cbTracker.endOfLife(key);\n         }\n\n         this.cbTracker.removeStaleComponents(now);\n         if (this.lastTrackerStatusPrint + this.delayBetweenStatusMessages < now) {\n            this.addInfo(\"SMTPAppender [\" + this.name + \"] is tracking [\" + this.cbTracker.getComponentCount() + \"] buffers\");\n            this.lastTrackerStatusPrint = now;\n            if (this.delayBetweenStatusMessages < 1228800000L) {\n               this.delayBetweenStatusMessages *= 4L;\n            }\n         }\n\n      }\n   }\n\n   protected abstract boolean eventMarksEndOfLife(E var1);\n\n   protected abstract void subAppend(CyclicBuffer<E> var1, E var2);\n\n   public boolean checkEntryConditions() {\n      if (!this.started) {\n         this.addError(\"Attempting to append to a non-started appender: \" + this.getName());\n         return false;\n      } else if (this.eventEvaluator == null) {\n         this.addError(\"No EventEvaluator is set for appender [\" + this.name + \"].\");\n         return false;\n      } else if (this.layout == null) {\n         this.addError(\"No layout set for appender named [\" + this.name + \"]. For more information, please visit http://logback.qos.ch/codes.html#smtp_no_layout\");\n         return false;\n      } else {\n         return true;\n      }\n   }\n\n   public synchronized void stop() {\n      this.started = false;\n   }\n\n   InternetAddress getAddress(String addressStr) {\n      try {\n         return new InternetAddress(addressStr);\n      } catch (AddressException var3) {\n         this.addError(\"Could not parse address [\" + addressStr + \"].\", var3);\n         return null;\n      }\n   }\n\n   private List<InternetAddress> parseAddress(E event) {\n      int len = this.toPatternLayoutList.size();\n      List<InternetAddress> iaList = new ArrayList();\n\n      for(int i = 0; i < len; ++i) {\n         try {\n            PatternLayoutBase<E> emailPL = (PatternLayoutBase)this.toPatternLayoutList.get(i);\n            String emailAdrr = emailPL.doLayout(event);\n            if (emailAdrr != null && emailAdrr.length() != 0) {\n               InternetAddress[] tmp = InternetAddress.parse(emailAdrr, true);\n               iaList.addAll(Arrays.asList(tmp));\n            }\n         } catch (AddressException var8) {\n            this.addError(\"Could not parse email address for [\" + this.toPatternLayoutList.get(i) + \"] for event [\" + event + \"]\", var8);\n            return iaList;\n         }\n      }\n\n      return iaList;\n   }\n\n   public List<PatternLayoutBase<E>> getToList() {\n      return this.toPatternLayoutList;\n   }\n\n   protected void sendBuffer(CyclicBuffer<E> cb, E lastEventObject) {\n      try {\n         MimeBodyPart part = new MimeBodyPart();\n         StringBuffer sbuf = new StringBuffer();\n         String header = this.layout.getFileHeader();\n         if (header != null) {\n            sbuf.append(header);\n         }\n\n         String presentationHeader = this.layout.getPresentationHeader();\n         if (presentationHeader != null) {\n            sbuf.append(presentationHeader);\n         }\n\n         this.fillBuffer(cb, sbuf);\n         String presentationFooter = this.layout.getPresentationFooter();\n         if (presentationFooter != null) {\n            sbuf.append(presentationFooter);\n         }\n\n         String footer = this.layout.getFileFooter();\n         if (footer != null) {\n            sbuf.append(footer);\n         }\n\n         String subjectStr = \"Undefined subject\";\n         if (this.subjectLayout != null) {\n            subjectStr = this.subjectLayout.doLayout(lastEventObject);\n            int newLinePos = subjectStr != null ? subjectStr.indexOf(10) : -1;\n            if (newLinePos > -1) {\n               subjectStr = subjectStr.substring(0, newLinePos);\n            }\n         }\n\n         MimeMessage mimeMsg = new MimeMessage(this.session);\n         if (this.from != null) {\n            mimeMsg.setFrom(this.getAddress(this.from));\n         } else {\n            mimeMsg.setFrom();\n         }\n\n         mimeMsg.setSubject(subjectStr, this.charsetEncoding);\n         List<InternetAddress> destinationAddresses = this.parseAddress(lastEventObject);\n         if (destinationAddresses.isEmpty()) {\n            this.addInfo(\"Empty destination address. Aborting email transmission\");\n            return;\n         }\n\n         InternetAddress[] toAddressArray = (InternetAddress[])destinationAddresses.toArray(EMPTY_IA_ARRAY);\n         mimeMsg.setRecipients(RecipientType.TO, toAddressArray);\n         String contentType = this.layout.getContentType();\n         if (ContentTypeUtil.isTextual(contentType)) {\n            part.setText(sbuf.toString(), this.charsetEncoding, ContentTypeUtil.getSubType(contentType));\n         } else {\n            part.setContent(sbuf.toString(), this.layout.getContentType());\n         }\n\n         Multipart mp = new MimeMultipart();\n         mp.addBodyPart(part);\n         mimeMsg.setContent(mp);\n         mimeMsg.setSentDate(new Date());\n         this.addInfo(\"About to send out SMTP message \\\"\" + subjectStr + \"\\\" to \" + Arrays.toString(toAddressArray));\n         Transport.send(mimeMsg);\n      } catch (Exception var15) {\n         this.addError(\"Error occurred while sending e-mail notification.\", var15);\n      }\n\n   }\n\n   protected abstract void fillBuffer(CyclicBuffer<E> var1, StringBuffer var2);\n\n   public String getFrom() {\n      return this.from;\n   }\n\n   public String getSubject() {\n      return this.subjectStr;\n   }\n\n   public void setFrom(String from) {\n      this.from = from;\n   }\n\n   public void setSubject(String subject) {\n      this.subjectStr = subject;\n   }\n\n   public void setSMTPHost(String smtpHost) {\n      this.setSmtpHost(smtpHost);\n   }\n\n   public void setSmtpHost(String smtpHost) {\n      this.smtpHost = smtpHost;\n   }\n\n   public String getSMTPHost() {\n      return this.getSmtpHost();\n   }\n\n   public String getSmtpHost() {\n      return this.smtpHost;\n   }\n\n   public void setSMTPPort(int port) {\n      this.setSmtpPort(port);\n   }\n\n   public void setSmtpPort(int port) {\n      this.smtpPort = port;\n   }\n\n   public int getSMTPPort() {\n      return this.getSmtpPort();\n   }\n\n   public int getSmtpPort() {\n      return this.smtpPort;\n   }\n\n   public String getLocalhost() {\n      return this.localhost;\n   }\n\n   public void setLocalhost(String localhost) {\n      this.localhost = localhost;\n   }\n\n   public CyclicBufferTracker<E> getCyclicBufferTracker() {\n      return this.cbTracker;\n   }\n\n   public void setCyclicBufferTracker(CyclicBufferTracker<E> cbTracker) {\n      this.cbTracker = cbTracker;\n   }\n\n   public Discriminator<E> getDiscriminator() {\n      return this.discriminator;\n   }\n\n   public void setDiscriminator(Discriminator<E> discriminator) {\n      this.discriminator = discriminator;\n   }\n\n   public boolean isAsynchronousSending() {\n      return this.asynchronousSending;\n   }\n\n   public void setAsynchronousSending(boolean asynchronousSending) {\n      this.asynchronousSending = asynchronousSending;\n   }\n\n   public void addTo(String to) {\n      if (to != null && to.length() != 0) {\n         PatternLayoutBase<E> plb = this.makeNewToPatternLayout(to.trim());\n         plb.setContext(this.context);\n         plb.start();\n         this.toPatternLayoutList.add(plb);\n      } else {\n         throw new IllegalArgumentException(\"Null or empty <to> property\");\n      }\n   }\n\n   protected abstract PatternLayoutBase<E> makeNewToPatternLayout(String var1);\n\n   public List<String> getToAsListOfString() {\n      List<String> toList = new ArrayList();\n      Iterator var2 = this.toPatternLayoutList.iterator();\n\n      while(var2.hasNext()) {\n         PatternLayoutBase<E> plb = (PatternLayoutBase)var2.next();\n         toList.add(plb.getPattern());\n      }\n\n      return toList;\n   }\n\n   public boolean isSTARTTLS() {\n      return this.starttls;\n   }\n\n   public void setSTARTTLS(boolean startTLS) {\n      this.starttls = startTLS;\n   }\n\n   public boolean isSSL() {\n      return this.ssl;\n   }\n\n   public void setSSL(boolean ssl) {\n      this.ssl = ssl;\n   }\n\n   public void setEvaluator(EventEvaluator<E> eventEvaluator) {\n      this.eventEvaluator = eventEvaluator;\n   }\n\n   public String getUsername() {\n      return this.username;\n   }\n\n   public void setUsername(String username) {\n      this.username = username;\n   }\n\n   public String getPassword() {\n      return this.password;\n   }\n\n   public void setPassword(String password) {\n      this.password = password;\n   }\n\n   public String getCharsetEncoding() {\n      return this.charsetEncoding;\n   }\n\n   public String getJndiLocation() {\n      return this.jndiLocation;\n   }\n\n   public void setJndiLocation(String jndiLocation) {\n      this.jndiLocation = jndiLocation;\n   }\n\n   public boolean isSessionViaJNDI() {\n      return this.sessionViaJNDI;\n   }\n\n   public void setSessionViaJNDI(boolean sessionViaJNDI) {\n      this.sessionViaJNDI = sessionViaJNDI;\n   }\n\n   public void setCharsetEncoding(String charsetEncoding) {\n      this.charsetEncoding = charsetEncoding;\n   }\n\n   public Layout<E> getLayout() {\n      return this.layout;\n   }\n\n   public void setLayout(Layout<E> layout) {\n      this.layout = layout;\n   }\n\n   class SenderRunnable implements Runnable {\n      final CyclicBuffer<E> cyclicBuffer;\n      final E e;\n\n      SenderRunnable(CyclicBuffer<E> this$0, E cyclicBuffer) {\n         this.cyclicBuffer = cyclicBuffer;\n         this.e = e;\n      }\n\n      public void run() {\n         SMTPAppenderBase.this.sendBuffer(this.cyclicBuffer, this.e);\n      }\n   }\n}\n"}