{"id":"2220088","content":"package org.springframework.boot.loader.jar;\n\nimport java.io.File;\nimport java.io.FilePermission;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.ref.SoftReference;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLStreamHandlerFactory;\nimport java.security.Permission;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.Supplier;\nimport java.util.jar.JarEntry;\nimport java.util.jar.Manifest;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\nimport java.util.zip.ZipEntry;\nimport org.springframework.boot.loader.data.RandomAccessData;\nimport org.springframework.boot.loader.data.RandomAccessDataFile;\nimport org.springframework.boot.loader.jar.AbstractJarFile.JarFileType;\n\npublic class JarFile extends AbstractJarFile implements Iterable<JarEntry> {\n   private static final String MANIFEST_NAME = \"META-INF/MANIFEST.MF\";\n   private static final String PROTOCOL_HANDLER = \"java.protocol.handler.pkgs\";\n   private static final String HANDLERS_PACKAGE = \"org.springframework.boot.loader\";\n   private static final AsciiBytes META_INF = new AsciiBytes(\"META-INF/\");\n   private static final AsciiBytes SIGNATURE_FILE_EXTENSION = new AsciiBytes(\".SF\");\n   private static final String READ_ACTION = \"read\";\n   private final RandomAccessDataFile rootFile;\n   private final String pathFromRoot;\n   private final RandomAccessData data;\n   private final JarFileType type;\n   private URL url;\n   private String urlString;\n   private JarFileEntries entries;\n   private Supplier<Manifest> manifestSupplier;\n   private SoftReference<Manifest> manifest;\n   private boolean signed;\n   private String comment;\n   private volatile boolean closed;\n   private volatile JarFileWrapper wrapper;\n\n   public JarFile(File file) throws IOException {\n      this(new RandomAccessDataFile(file));\n   }\n\n   JarFile(RandomAccessDataFile file) throws IOException {\n      this(file, \"\", file, JarFileType.DIRECT);\n   }\n\n   private JarFile(RandomAccessDataFile rootFile, String pathFromRoot, RandomAccessData data, JarFileType type) throws IOException {\n      this(rootFile, pathFromRoot, data, (JarEntryFilter)null, type, (Supplier)null);\n   }\n\n   private JarFile(RandomAccessDataFile rootFile, String pathFromRoot, RandomAccessData data, JarEntryFilter filter, JarFileType type, Supplier<Manifest> manifestSupplier) throws IOException {\n      super(rootFile.getFile());\n      if (System.getSecurityManager() == null) {\n         super.close();\n      }\n\n      this.rootFile = rootFile;\n      this.pathFromRoot = pathFromRoot;\n      CentralDirectoryParser parser = new CentralDirectoryParser();\n      this.entries = (JarFileEntries)parser.addVisitor(new JarFileEntries(this, filter));\n      this.type = type;\n      parser.addVisitor(this.centralDirectoryVisitor());\n\n      try {\n         this.data = parser.parse(data, filter == null);\n      } catch (RuntimeException var11) {\n         try {\n            this.rootFile.close();\n            super.close();\n         } catch (IOException var10) {\n            ;\n         }\n\n         throw var11;\n      }\n\n      this.manifestSupplier = manifestSupplier != null ? manifestSupplier : () -> {\n         try {\n            InputStream inputStream = this.getInputStream(\"META-INF/MANIFEST.MF\");\n            Throwable var2 = null;\n\n            Manifest var3;\n            try {\n               if (inputStream != null) {\n                  var3 = new Manifest(inputStream);\n                  return var3;\n               }\n\n               var3 = null;\n            } catch (Throwable var14) {\n               var2 = var14;\n               throw var14;\n            } finally {\n               if (inputStream != null) {\n                  if (var2 != null) {\n                     try {\n                        inputStream.close();\n                     } catch (Throwable var13) {\n                        var2.addSuppressed(var13);\n                     }\n                  } else {\n                     inputStream.close();\n                  }\n               }\n\n            }\n\n            return var3;\n         } catch (IOException var16) {\n            throw new RuntimeException(var16);\n         }\n      };\n   }\n\n   private CentralDirectoryVisitor centralDirectoryVisitor() {\n      return new CentralDirectoryVisitor() {\n         public void visitStart(CentralDirectoryEndRecord endRecord, RandomAccessData centralDirectoryData) {\n            JarFile.this.comment = endRecord.getComment();\n         }\n\n         public void visitFileHeader(CentralDirectoryFileHeader fileHeader, long dataOffset) {\n            AsciiBytes name = fileHeader.getName();\n            if (name.startsWith(JarFile.META_INF) && name.endsWith(JarFile.SIGNATURE_FILE_EXTENSION)) {\n               JarFile.this.signed = true;\n            }\n\n         }\n\n         public void visitEnd() {\n         }\n      };\n   }\n\n   JarFileWrapper getWrapper() throws IOException {\n      JarFileWrapper wrapper = this.wrapper;\n      if (wrapper == null) {\n         wrapper = new JarFileWrapper(this);\n         this.wrapper = wrapper;\n      }\n\n      return wrapper;\n   }\n\n   Permission getPermission() {\n      return new FilePermission(this.rootFile.getFile().getPath(), \"read\");\n   }\n\n   protected final RandomAccessDataFile getRootJarFile() {\n      return this.rootFile;\n   }\n\n   RandomAccessData getData() {\n      return this.data;\n   }\n\n   public Manifest getManifest() throws IOException {\n      Manifest manifest = this.manifest != null ? (Manifest)this.manifest.get() : null;\n      if (manifest == null) {\n         try {\n            manifest = (Manifest)this.manifestSupplier.get();\n         } catch (RuntimeException var3) {\n            throw new IOException(var3);\n         }\n\n         this.manifest = new SoftReference(manifest);\n      }\n\n      return manifest;\n   }\n\n   public Enumeration<JarEntry> entries() {\n      return new JarFile.JarEntryEnumeration(this.entries.iterator());\n   }\n\n   public Stream<JarEntry> stream() {\n      Spliterator<JarEntry> spliterator = Spliterators.spliterator(this.iterator(), (long)this.size(), 1297);\n      return StreamSupport.stream(spliterator, false);\n   }\n\n   public Iterator<JarEntry> iterator() {\n      return this.entries.iterator(this::ensureOpen);\n   }\n\n   public org.springframework.boot.loader.jar.JarEntry getJarEntry(CharSequence name) {\n      return this.entries.getEntry(name);\n   }\n\n   public org.springframework.boot.loader.jar.JarEntry getJarEntry(String name) {\n      return (org.springframework.boot.loader.jar.JarEntry)this.getEntry(name);\n   }\n\n   public boolean containsEntry(String name) {\n      return this.entries.containsEntry(name);\n   }\n\n   public ZipEntry getEntry(String name) {\n      this.ensureOpen();\n      return this.entries.getEntry(name);\n   }\n\n   InputStream getInputStream() throws IOException {\n      return this.data.getInputStream();\n   }\n\n   public synchronized InputStream getInputStream(ZipEntry entry) throws IOException {\n      this.ensureOpen();\n      return entry instanceof org.springframework.boot.loader.jar.JarEntry ? this.entries.getInputStream((org.springframework.boot.loader.jar.JarEntry)entry) : this.getInputStream(entry != null ? entry.getName() : null);\n   }\n\n   InputStream getInputStream(String name) throws IOException {\n      return this.entries.getInputStream(name);\n   }\n\n   public synchronized JarFile getNestedJarFile(ZipEntry entry) throws IOException {\n      return this.getNestedJarFile((org.springframework.boot.loader.jar.JarEntry)entry);\n   }\n\n   public synchronized JarFile getNestedJarFile(org.springframework.boot.loader.jar.JarEntry entry) throws IOException {\n      try {\n         return this.createJarFileFromEntry(entry);\n      } catch (Exception var3) {\n         throw new IOException(\"Unable to open nested jar file '\" + entry.getName() + \"'\", var3);\n      }\n   }\n\n   private JarFile createJarFileFromEntry(org.springframework.boot.loader.jar.JarEntry entry) throws IOException {\n      return entry.isDirectory() ? this.createJarFileFromDirectoryEntry(entry) : this.createJarFileFromFileEntry(entry);\n   }\n\n   private JarFile createJarFileFromDirectoryEntry(org.springframework.boot.loader.jar.JarEntry entry) throws IOException {\n      AsciiBytes name = entry.getAsciiBytesName();\n      JarEntryFilter filter = (candidate) -> {\n         return candidate.startsWith(name) && !candidate.equals(name) ? candidate.substring(name.length()) : null;\n      };\n      return new JarFile(this.rootFile, this.pathFromRoot + \"!/\" + entry.getName().substring(0, name.length() - 1), this.data, filter, JarFileType.NESTED_DIRECTORY, this.manifestSupplier);\n   }\n\n   private JarFile createJarFileFromFileEntry(org.springframework.boot.loader.jar.JarEntry entry) throws IOException {\n      if (entry.getMethod() != 0) {\n         throw new IllegalStateException(\"Unable to open nested entry '\" + entry.getName() + \"'. It has been compressed and nested jar files must be stored without compression. Please check the mechanism used to create your executable jar file\");\n      } else {\n         RandomAccessData entryData = this.entries.getEntryData(entry.getName());\n         return new JarFile(this.rootFile, this.pathFromRoot + \"!/\" + entry.getName(), entryData, JarFileType.NESTED_JAR);\n      }\n   }\n\n   public String getComment() {\n      this.ensureOpen();\n      return this.comment;\n   }\n\n   public int size() {\n      this.ensureOpen();\n      return this.entries.getSize();\n   }\n\n   public void close() throws IOException {\n      if (!this.closed) {\n         super.close();\n         if (this.type == JarFileType.DIRECT) {\n            this.rootFile.close();\n         }\n\n         this.closed = true;\n      }\n   }\n\n   private void ensureOpen() {\n      if (this.closed) {\n         throw new IllegalStateException(\"zip file closed\");\n      }\n   }\n\n   boolean isClosed() {\n      return this.closed;\n   }\n\n   String getUrlString() throws MalformedURLException {\n      if (this.urlString == null) {\n         this.urlString = this.getUrl().toString();\n      }\n\n      return this.urlString;\n   }\n\n   public URL getUrl() throws MalformedURLException {\n      if (this.url == null) {\n         String file = this.rootFile.getFile().toURI() + this.pathFromRoot + \"!/\";\n         file = file.replace(\"file:////\", \"file://\");\n         this.url = new URL(\"jar\", \"\", -1, file, new Handler(this));\n      }\n\n      return this.url;\n   }\n\n   public String toString() {\n      return this.getName();\n   }\n\n   public String getName() {\n      return this.rootFile.getFile() + this.pathFromRoot;\n   }\n\n   boolean isSigned() {\n      return this.signed;\n   }\n\n   JarEntryCertification getCertification(org.springframework.boot.loader.jar.JarEntry entry) {\n      try {\n         return this.entries.getCertification(entry);\n      } catch (IOException var3) {\n         throw new IllegalStateException(var3);\n      }\n   }\n\n   public void clearCache() {\n      this.entries.clearCache();\n   }\n\n   protected String getPathFromRoot() {\n      return this.pathFromRoot;\n   }\n\n   JarFileType getType() {\n      return this.type;\n   }\n\n   public static void registerUrlProtocolHandler() {\n      Handler.captureJarContextUrl();\n      String handlers = System.getProperty(\"java.protocol.handler.pkgs\", \"\");\n      System.setProperty(\"java.protocol.handler.pkgs\", handlers != null && !handlers.isEmpty() ? handlers + \"|\" + \"org.springframework.boot.loader\" : \"org.springframework.boot.loader\");\n      resetCachedUrlHandlers();\n   }\n\n   private static void resetCachedUrlHandlers() {\n      try {\n         URL.setURLStreamHandlerFactory((URLStreamHandlerFactory)null);\n      } catch (Error var1) {\n         ;\n      }\n\n   }\n\n   private static class JarEntryEnumeration implements Enumeration<JarEntry> {\n      private final Iterator<org.springframework.boot.loader.jar.JarEntry> iterator;\n\n      JarEntryEnumeration(Iterator<org.springframework.boot.loader.jar.JarEntry> iterator) {\n         this.iterator = iterator;\n      }\n\n      public boolean hasMoreElements() {\n         return this.iterator.hasNext();\n      }\n\n      public JarEntry nextElement() {\n         return (JarEntry)this.iterator.next();\n      }\n   }\n}\n"}