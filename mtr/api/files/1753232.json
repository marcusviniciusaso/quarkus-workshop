{"id":"1753232","content":"package ch.qos.logback.core.rolling.helper;\n\nimport ch.qos.logback.core.pattern.Converter;\nimport ch.qos.logback.core.pattern.LiteralConverter;\nimport ch.qos.logback.core.spi.ContextAwareBase;\nimport ch.qos.logback.core.util.FileSize;\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\n\npublic class TimeBasedArchiveRemover extends ContextAwareBase implements ArchiveRemover {\n   protected static final long UNINITIALIZED = -1L;\n   protected static final long INACTIVITY_TOLERANCE_IN_MILLIS = 2764800000L;\n   static final int MAX_VALUE_FOR_INACTIVITY_PERIODS = 336;\n   final FileNamePattern fileNamePattern;\n   final RollingCalendar rc;\n   private int maxHistory = 0;\n   private long totalSizeCap = 0L;\n   final boolean parentClean;\n   long lastHeartBeat = -1L;\n   int callCount = 0;\n\n   public TimeBasedArchiveRemover(FileNamePattern fileNamePattern, RollingCalendar rc) {\n      this.fileNamePattern = fileNamePattern;\n      this.rc = rc;\n      this.parentClean = this.computeParentCleaningFlag(fileNamePattern);\n   }\n\n   public void clean(Date now) {\n      long nowInMillis = now.getTime();\n      int periodsElapsed = this.computeElapsedPeriodsSinceLastClean(nowInMillis);\n      this.lastHeartBeat = nowInMillis;\n      if (periodsElapsed > 1) {\n         this.addInfo(\"Multiple periods, i.e. \" + periodsElapsed + \" periods, seem to have elapsed. This is expected at application start.\");\n      }\n\n      for(int i = 0; i < periodsElapsed; ++i) {\n         int offset = this.getPeriodOffsetForDeletionTarget() - i;\n         Date dateOfPeriodToClean = this.rc.getEndOfNextNthPeriod(now, offset);\n         this.cleanPeriod(dateOfPeriodToClean);\n      }\n\n   }\n\n   protected File[] getFilesInPeriod(Date dateOfPeriodToClean) {\n      String filenameToDelete = this.fileNamePattern.convert(dateOfPeriodToClean);\n      File file2Delete = new File(filenameToDelete);\n      return this.fileExistsAndIsFile(file2Delete) ? new File[]{file2Delete} : new File[0];\n   }\n\n   private boolean fileExistsAndIsFile(File file2Delete) {\n      return file2Delete.exists() && file2Delete.isFile();\n   }\n\n   public void cleanPeriod(Date dateOfPeriodToClean) {\n      File[] matchingFileArray = this.getFilesInPeriod(dateOfPeriodToClean);\n      File[] var3 = matchingFileArray;\n      int var4 = matchingFileArray.length;\n\n      for(int var5 = 0; var5 < var4; ++var5) {\n         File f = var3[var5];\n         this.addInfo(\"deleting \" + f);\n         f.delete();\n      }\n\n      if (this.parentClean && matchingFileArray.length > 0) {\n         File parentDir = this.getParentDir(matchingFileArray[0]);\n         this.removeFolderIfEmpty(parentDir);\n      }\n\n   }\n\n   void capTotalSize(Date now) {\n      long totalSize = 0L;\n      long totalRemoved = 0L;\n\n      for(int offset = 0; offset < this.maxHistory; ++offset) {\n         Date date = this.rc.getEndOfNextNthPeriod(now, -offset);\n         File[] matchingFileArray = this.getFilesInPeriod(date);\n         this.descendingSortByLastModified(matchingFileArray);\n         File[] var9 = matchingFileArray;\n         int var10 = matchingFileArray.length;\n\n         for(int var11 = 0; var11 < var10; ++var11) {\n            File f = var9[var11];\n            long size = f.length();\n            if (totalSize + size > this.totalSizeCap) {\n               this.addInfo(\"Deleting [\" + f + \"] of size \" + new FileSize(size));\n               totalRemoved += size;\n               f.delete();\n            }\n\n            totalSize += size;\n         }\n      }\n\n      this.addInfo(\"Removed  \" + new FileSize(totalRemoved) + \" of files\");\n   }\n\n   private void descendingSortByLastModified(File[] matchingFileArray) {\n      Arrays.sort(matchingFileArray, new Comparator<File>() {\n         public int compare(File f1, File f2) {\n            long l1 = f1.lastModified();\n            long l2 = f2.lastModified();\n            if (l1 == l2) {\n               return 0;\n            } else {\n               return l2 < l1 ? -1 : 1;\n            }\n         }\n      });\n   }\n\n   File getParentDir(File file) {\n      File absolute = file.getAbsoluteFile();\n      File parentDir = absolute.getParentFile();\n      return parentDir;\n   }\n\n   int computeElapsedPeriodsSinceLastClean(long nowInMillis) {\n      long periodsElapsed = 0L;\n      if (this.lastHeartBeat == -1L) {\n         this.addInfo(\"first clean up after appender initialization\");\n         periodsElapsed = this.rc.periodBarriersCrossed(nowInMillis, nowInMillis + 2764800000L);\n         periodsElapsed = Math.min(periodsElapsed, 336L);\n      } else {\n         periodsElapsed = this.rc.periodBarriersCrossed(this.lastHeartBeat, nowInMillis);\n      }\n\n      return (int)periodsElapsed;\n   }\n\n   boolean computeParentCleaningFlag(FileNamePattern fileNamePattern) {\n      DateTokenConverter<Object> dtc = fileNamePattern.getPrimaryDateTokenConverter();\n      if (dtc.getDatePattern().indexOf(47) != -1) {\n         return true;\n      } else {\n         Converter p;\n         for(p = fileNamePattern.headTokenConverter; p != null && !(p instanceof DateTokenConverter); p = p.getNext()) {\n            ;\n         }\n\n         for(; p != null; p = p.getNext()) {\n            if (p instanceof LiteralConverter) {\n               String s = p.convert((Object)null);\n               if (s.indexOf(47) != -1) {\n                  return true;\n               }\n            }\n         }\n\n         return false;\n      }\n   }\n\n   void removeFolderIfEmpty(File dir) {\n      this.removeFolderIfEmpty(dir, 0);\n   }\n\n   private void removeFolderIfEmpty(File dir, int depth) {\n      if (depth < 3) {\n         if (dir.isDirectory() && FileFilterUtil.isEmptyDirectory(dir)) {\n            this.addInfo(\"deleting folder [\" + dir + \"]\");\n            dir.delete();\n            this.removeFolderIfEmpty(dir.getParentFile(), depth + 1);\n         }\n\n      }\n   }\n\n   public void setMaxHistory(int maxHistory) {\n      this.maxHistory = maxHistory;\n   }\n\n   protected int getPeriodOffsetForDeletionTarget() {\n      return -this.maxHistory - 1;\n   }\n\n   public void setTotalSizeCap(long totalSizeCap) {\n      this.totalSizeCap = totalSizeCap;\n   }\n\n   public String toString() {\n      return \"c.q.l.core.rolling.helper.TimeBasedArchiveRemover\";\n   }\n\n   public Future<?> cleanAsynchronously(Date now) {\n      TimeBasedArchiveRemover.ArhiveRemoverRunnable runnable = new TimeBasedArchiveRemover.ArhiveRemoverRunnable(now);\n      ExecutorService executorService = this.context.getScheduledExecutorService();\n      Future<?> future = executorService.submit(runnable);\n      return future;\n   }\n\n   public class ArhiveRemoverRunnable implements Runnable {\n      Date now;\n\n      ArhiveRemoverRunnable(Date now) {\n         this.now = now;\n      }\n\n      public void run() {\n         TimeBasedArchiveRemover.this.clean(this.now);\n         if (TimeBasedArchiveRemover.this.totalSizeCap != 0L && TimeBasedArchiveRemover.this.totalSizeCap > 0L) {\n            TimeBasedArchiveRemover.this.capTotalSize(this.now);\n         }\n\n      }\n   }\n}\n"}