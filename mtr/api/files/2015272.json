{"id":"2015272","content":"package org.springframework.aop.framework;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.UndeclaredThrowableException;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport org.aopalliance.aop.Advice;\nimport org.aopalliance.intercept.MethodInvocation;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.aop.Advisor;\nimport org.springframework.aop.AopInvocationException;\nimport org.springframework.aop.PointcutAdvisor;\nimport org.springframework.aop.RawTargetAccess;\nimport org.springframework.aop.TargetSource;\nimport org.springframework.aop.support.AopUtils;\nimport org.springframework.cglib.core.ClassLoaderAwareGeneratorStrategy;\nimport org.springframework.cglib.core.CodeGenerationException;\nimport org.springframework.cglib.core.SpringNamingPolicy;\nimport org.springframework.cglib.proxy.Callback;\nimport org.springframework.cglib.proxy.CallbackFilter;\nimport org.springframework.cglib.proxy.Dispatcher;\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.Factory;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\nimport org.springframework.cglib.proxy.NoOp;\nimport org.springframework.core.KotlinDetector;\nimport org.springframework.core.SmartClassLoader;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.ReflectionUtils;\n\nclass CglibAopProxy implements AopProxy, Serializable {\n   private static final int AOP_PROXY = 0;\n   private static final int INVOKE_TARGET = 1;\n   private static final int NO_OVERRIDE = 2;\n   private static final int DISPATCH_TARGET = 3;\n   private static final int DISPATCH_ADVISED = 4;\n   private static final int INVOKE_EQUALS = 5;\n   private static final int INVOKE_HASHCODE = 6;\n   protected static final Log logger = LogFactory.getLog(CglibAopProxy.class);\n   private static final Map<Class<?>, Boolean> validatedClasses = new WeakHashMap();\n   protected final AdvisedSupport advised;\n   @Nullable\n   protected Object[] constructorArgs;\n   @Nullable\n   protected Class<?>[] constructorArgTypes;\n   private final transient CglibAopProxy.AdvisedDispatcher advisedDispatcher;\n   private transient Map<Method, Integer> fixedInterceptorMap = Collections.emptyMap();\n   private transient int fixedInterceptorOffset;\n\n   public CglibAopProxy(AdvisedSupport config) throws AopConfigException {\n      Assert.notNull(config, \"AdvisedSupport must not be null\");\n      if (config.getAdvisorCount() == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {\n         throw new AopConfigException(\"No advisors and no TargetSource specified\");\n      } else {\n         this.advised = config;\n         this.advisedDispatcher = new CglibAopProxy.AdvisedDispatcher(this.advised);\n      }\n   }\n\n   public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {\n      if (constructorArgs != null && constructorArgTypes != null) {\n         if (constructorArgs.length != constructorArgTypes.length) {\n            throw new IllegalArgumentException(\"Number of 'constructorArgs' (\" + constructorArgs.length + \") must match number of 'constructorArgTypes' (\" + constructorArgTypes.length + \")\");\n         } else {\n            this.constructorArgs = constructorArgs;\n            this.constructorArgTypes = constructorArgTypes;\n         }\n      } else {\n         throw new IllegalArgumentException(\"Both 'constructorArgs' and 'constructorArgTypes' need to be specified\");\n      }\n   }\n\n   public Object getProxy() {\n      return this.getProxy((ClassLoader)null);\n   }\n\n   public Object getProxy(@Nullable ClassLoader classLoader) {\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Creating CGLIB proxy: \" + this.advised.getTargetSource());\n      }\n\n      try {\n         Class<?> rootClass = this.advised.getTargetClass();\n         Assert.state(rootClass != null, \"Target class must be available for creating a CGLIB proxy\");\n         Class<?> proxySuperClass = rootClass;\n         int x;\n         if (rootClass.getName().contains(\"$$\")) {\n            proxySuperClass = rootClass.getSuperclass();\n            Class<?>[] additionalInterfaces = rootClass.getInterfaces();\n            Class[] var5 = additionalInterfaces;\n            int var6 = additionalInterfaces.length;\n\n            for(x = 0; x < var6; ++x) {\n               Class<?> additionalInterface = var5[x];\n               this.advised.addInterface(additionalInterface);\n            }\n         }\n\n         this.validateClassIfNecessary(proxySuperClass, classLoader);\n         Enhancer enhancer = this.createEnhancer();\n         if (classLoader != null) {\n            enhancer.setClassLoader(classLoader);\n            if (classLoader instanceof SmartClassLoader && ((SmartClassLoader)classLoader).isClassReloadable(proxySuperClass)) {\n               enhancer.setUseCache(false);\n            }\n         }\n\n         enhancer.setSuperclass(proxySuperClass);\n         enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));\n         enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);\n         enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(classLoader));\n         Callback[] callbacks = this.getCallbacks(rootClass);\n         Class<?>[] types = new Class[callbacks.length];\n\n         for(x = 0; x < types.length; ++x) {\n            types[x] = callbacks[x].getClass();\n         }\n\n         enhancer.setCallbackFilter(new CglibAopProxy.ProxyCallbackFilter(this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));\n         enhancer.setCallbackTypes(types);\n         return this.createProxyClassAndInstance(enhancer, callbacks);\n      } catch (IllegalArgumentException | CodeGenerationException var9) {\n         throw new AopConfigException(\"Could not generate CGLIB subclass of \" + this.advised.getTargetClass() + \": Common causes of this problem include using a final class or a non-visible class\", var9);\n      } catch (Throwable var10) {\n         throw new AopConfigException(\"Unexpected AOP exception\", var10);\n      }\n   }\n\n   protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) {\n      enhancer.setInterceptDuringConstruction(false);\n      enhancer.setCallbacks(callbacks);\n      return this.constructorArgs != null && this.constructorArgTypes != null ? enhancer.create(this.constructorArgTypes, this.constructorArgs) : enhancer.create();\n   }\n\n   protected Enhancer createEnhancer() {\n      return new Enhancer();\n   }\n\n   private void validateClassIfNecessary(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader) {\n      if (!this.advised.isOptimize() && logger.isInfoEnabled()) {\n         Map var3 = validatedClasses;\n         synchronized(validatedClasses) {\n            if (!validatedClasses.containsKey(proxySuperClass)) {\n               this.doValidateClass(proxySuperClass, proxyClassLoader, ClassUtils.getAllInterfacesForClassAsSet(proxySuperClass));\n               validatedClasses.put(proxySuperClass, Boolean.TRUE);\n            }\n         }\n      }\n\n   }\n\n   private void doValidateClass(Class<?> proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set<Class<?>> ifcs) {\n      if (proxySuperClass != Object.class) {\n         Method[] methods = proxySuperClass.getDeclaredMethods();\n         Method[] var5 = methods;\n         int var6 = methods.length;\n\n         for(int var7 = 0; var7 < var6; ++var7) {\n            Method method = var5[var7];\n            int mod = method.getModifiers();\n            if (!Modifier.isStatic(mod) && !Modifier.isPrivate(mod)) {\n               if (Modifier.isFinal(mod)) {\n                  if (logger.isInfoEnabled() && implementsInterface(method, ifcs)) {\n                     logger.info(\"Unable to proxy interface-implementing method [\" + method + \"] because it is marked as final: Consider using interface-based JDK proxies instead!\");\n                  }\n\n                  if (logger.isDebugEnabled()) {\n                     logger.debug(\"Final method [\" + method + \"] cannot get proxied via CGLIB: Calls to this method will NOT be routed to the target instance and might lead to NPEs against uninitialized fields in the proxy instance.\");\n                  }\n               } else if (logger.isDebugEnabled() && !Modifier.isPublic(mod) && !Modifier.isProtected(mod) && proxyClassLoader != null && proxySuperClass.getClassLoader() != proxyClassLoader) {\n                  logger.debug(\"Method [\" + method + \"] is package-visible across different ClassLoaders and cannot get proxied via CGLIB: Declare this method as public or protected if you need to support invocations through the proxy.\");\n               }\n            }\n         }\n\n         this.doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs);\n      }\n\n   }\n\n   private Callback[] getCallbacks(Class<?> rootClass) throws Exception {\n      boolean isFrozen = this.advised.isFrozen();\n      boolean exposeProxy = this.advised.isExposeProxy();\n      boolean isStatic = this.advised.getTargetSource().isStatic();\n      Callback aopInterceptor = new CglibAopProxy.DynamicAdvisedInterceptor(this.advised);\n      Object targetInterceptor;\n      if (exposeProxy) {\n         targetInterceptor = isStatic ? new CglibAopProxy.StaticUnadvisedExposedInterceptor(this.advised.getTargetSource().getTarget()) : new CglibAopProxy.DynamicUnadvisedExposedInterceptor(this.advised.getTargetSource());\n      } else {\n         targetInterceptor = isStatic ? new CglibAopProxy.StaticUnadvisedInterceptor(this.advised.getTargetSource().getTarget()) : new CglibAopProxy.DynamicUnadvisedInterceptor(this.advised.getTargetSource());\n      }\n\n      Callback targetDispatcher = isStatic ? new CglibAopProxy.StaticDispatcher(this.advised.getTargetSource().getTarget()) : new CglibAopProxy.SerializableNoOp();\n      Callback[] mainCallbacks = new Callback[]{aopInterceptor, (Callback)targetInterceptor, new CglibAopProxy.SerializableNoOp(), (Callback)targetDispatcher, this.advisedDispatcher, new CglibAopProxy.EqualsInterceptor(this.advised), new CglibAopProxy.HashCodeInterceptor(this.advised)};\n      Callback[] callbacks;\n      if (isStatic && isFrozen) {\n         Method[] methods = rootClass.getMethods();\n         Callback[] fixedCallbacks = new Callback[methods.length];\n         this.fixedInterceptorMap = CollectionUtils.newHashMap(methods.length);\n\n         for(int x = 0; x < methods.length; ++x) {\n            Method method = methods[x];\n            List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, rootClass);\n            fixedCallbacks[x] = new CglibAopProxy.FixedChainStaticTargetInterceptor(chain, this.advised.getTargetSource().getTarget(), this.advised.getTargetClass());\n            this.fixedInterceptorMap.put(method, x);\n         }\n\n         callbacks = new Callback[mainCallbacks.length + fixedCallbacks.length];\n         System.arraycopy(mainCallbacks, 0, callbacks, 0, mainCallbacks.length);\n         System.arraycopy(fixedCallbacks, 0, callbacks, mainCallbacks.length, fixedCallbacks.length);\n         this.fixedInterceptorOffset = mainCallbacks.length;\n      } else {\n         callbacks = mainCallbacks;\n      }\n\n      return callbacks;\n   }\n\n   public boolean equals(@Nullable Object other) {\n      return this == other || other instanceof CglibAopProxy && AopProxyUtils.equalsInProxy(this.advised, ((CglibAopProxy)other).advised);\n   }\n\n   public int hashCode() {\n      return CglibAopProxy.class.hashCode() * 13 + this.advised.getTargetSource().hashCode();\n   }\n\n   private static boolean implementsInterface(Method method, Set<Class<?>> ifcs) {\n      Iterator var2 = ifcs.iterator();\n\n      Class ifc;\n      do {\n         if (!var2.hasNext()) {\n            return false;\n         }\n\n         ifc = (Class)var2.next();\n      } while(!ClassUtils.hasMethod(ifc, method));\n\n      return true;\n   }\n\n   @Nullable\n   private static Object invokeMethod(@Nullable Object target, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n      try {\n         return methodProxy.invoke(target, args);\n      } catch (CodeGenerationException var5) {\n         CglibAopProxy.CglibMethodInvocation.logFastClassGenerationFailure(method);\n         return AopUtils.invokeJoinpointUsingReflection(target, method, args);\n      }\n   }\n\n   @Nullable\n   private static Object processReturnType(Object proxy, @Nullable Object target, Method method, @Nullable Object returnValue) {\n      if (returnValue != null && returnValue == target && !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {\n         returnValue = proxy;\n      }\n\n      Class<?> returnType = method.getReturnType();\n      if (returnValue == null && returnType != Void.TYPE && returnType.isPrimitive()) {\n         throw new AopInvocationException(\"Null return value from advice does not match primitive return type for: \" + method);\n      } else {\n         return returnValue;\n      }\n   }\n\n   private static class ProxyCallbackFilter implements CallbackFilter {\n      private final AdvisedSupport advised;\n      private final Map<Method, Integer> fixedInterceptorMap;\n      private final int fixedInterceptorOffset;\n\n      public ProxyCallbackFilter(AdvisedSupport advised, Map<Method, Integer> fixedInterceptorMap, int fixedInterceptorOffset) {\n         this.advised = advised;\n         this.fixedInterceptorMap = fixedInterceptorMap;\n         this.fixedInterceptorOffset = fixedInterceptorOffset;\n      }\n\n      public int accept(Method method) {\n         if (AopUtils.isFinalizeMethod(method)) {\n            CglibAopProxy.logger.trace(\"Found finalize() method - using NO_OVERRIDE\");\n            return 2;\n         } else if (!this.advised.isOpaque() && method.getDeclaringClass().isInterface() && method.getDeclaringClass().isAssignableFrom(Advised.class)) {\n            if (CglibAopProxy.logger.isTraceEnabled()) {\n               CglibAopProxy.logger.trace(\"Method is declared on Advised interface: \" + method);\n            }\n\n            return 4;\n         } else if (AopUtils.isEqualsMethod(method)) {\n            if (CglibAopProxy.logger.isTraceEnabled()) {\n               CglibAopProxy.logger.trace(\"Found 'equals' method: \" + method);\n            }\n\n            return 5;\n         } else if (AopUtils.isHashCodeMethod(method)) {\n            if (CglibAopProxy.logger.isTraceEnabled()) {\n               CglibAopProxy.logger.trace(\"Found 'hashCode' method: \" + method);\n            }\n\n            return 6;\n         } else {\n            Class<?> targetClass = this.advised.getTargetClass();\n            List<?> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n            boolean haveAdvice = !chain.isEmpty();\n            boolean isFrozen = this.advised.isFrozen();\n            boolean exposeProxy = this.advised.isExposeProxy();\n            boolean isStatic = this.advised.getTargetSource().isStatic();\n            if (!haveAdvice && isFrozen) {\n               if (!exposeProxy && isStatic) {\n                  Class<?> returnType = method.getReturnType();\n                  if (targetClass != null && returnType.isAssignableFrom(targetClass)) {\n                     if (CglibAopProxy.logger.isTraceEnabled()) {\n                        CglibAopProxy.logger.trace(\"Method return type is assignable from target type and may therefore return 'this' - using INVOKE_TARGET: \" + method);\n                     }\n\n                     return 1;\n                  } else {\n                     if (CglibAopProxy.logger.isTraceEnabled()) {\n                        CglibAopProxy.logger.trace(\"Method return type ensures 'this' cannot be returned - using DISPATCH_TARGET: \" + method);\n                     }\n\n                     return 3;\n                  }\n               } else {\n                  return 1;\n               }\n            } else if (exposeProxy) {\n               if (CglibAopProxy.logger.isTraceEnabled()) {\n                  CglibAopProxy.logger.trace(\"Must expose proxy on advised method: \" + method);\n               }\n\n               return 0;\n            } else if (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(method)) {\n               if (CglibAopProxy.logger.isTraceEnabled()) {\n                  CglibAopProxy.logger.trace(\"Method has advice and optimizations are enabled: \" + method);\n               }\n\n               int index = ((Integer)this.fixedInterceptorMap.get(method)).intValue();\n               return index + this.fixedInterceptorOffset;\n            } else {\n               if (CglibAopProxy.logger.isTraceEnabled()) {\n                  CglibAopProxy.logger.trace(\"Unable to apply any optimizations to advised method: \" + method);\n               }\n\n               return 0;\n            }\n         }\n      }\n\n      public boolean equals(@Nullable Object other) {\n         if (this == other) {\n            return true;\n         } else if (!(other instanceof CglibAopProxy.ProxyCallbackFilter)) {\n            return false;\n         } else {\n            CglibAopProxy.ProxyCallbackFilter otherCallbackFilter = (CglibAopProxy.ProxyCallbackFilter)other;\n            AdvisedSupport otherAdvised = otherCallbackFilter.advised;\n            if (this.advised.isFrozen() != otherAdvised.isFrozen()) {\n               return false;\n            } else if (this.advised.isExposeProxy() != otherAdvised.isExposeProxy()) {\n               return false;\n            } else if (this.advised.isOpaque() != otherAdvised.isOpaque()) {\n               return false;\n            } else if (this.advised.getTargetSource().isStatic() != otherAdvised.getTargetSource().isStatic()) {\n               return false;\n            } else if (!AopProxyUtils.equalsProxiedInterfaces(this.advised, otherAdvised)) {\n               return false;\n            } else if (this.advised.getAdvisorCount() != otherAdvised.getAdvisorCount()) {\n               return false;\n            } else {\n               Advisor[] thisAdvisors = this.advised.getAdvisors();\n               Advisor[] thatAdvisors = otherAdvised.getAdvisors();\n\n               for(int i = 0; i < thisAdvisors.length; ++i) {\n                  Advisor thisAdvisor = thisAdvisors[i];\n                  Advisor thatAdvisor = thatAdvisors[i];\n                  if (!equalsAdviceClasses(thisAdvisor, thatAdvisor)) {\n                     return false;\n                  }\n\n                  if (!equalsPointcuts(thisAdvisor, thatAdvisor)) {\n                     return false;\n                  }\n               }\n\n               return true;\n            }\n         }\n      }\n\n      private static boolean equalsAdviceClasses(Advisor a, Advisor b) {\n         return a.getAdvice().getClass() == b.getAdvice().getClass();\n      }\n\n      private static boolean equalsPointcuts(Advisor a, Advisor b) {\n         return !(a instanceof PointcutAdvisor) || b instanceof PointcutAdvisor && ObjectUtils.nullSafeEquals(((PointcutAdvisor)a).getPointcut(), ((PointcutAdvisor)b).getPointcut());\n      }\n\n      public int hashCode() {\n         int hashCode = 0;\n         Advisor[] advisors = this.advised.getAdvisors();\n         Advisor[] var3 = advisors;\n         int var4 = advisors.length;\n\n         for(int var5 = 0; var5 < var4; ++var5) {\n            Advisor advisor = var3[var5];\n            Advice advice = advisor.getAdvice();\n            hashCode = 13 * hashCode + advice.getClass().hashCode();\n         }\n\n         return hashCode;\n      }\n   }\n\n   private static class CglibMethodInvocation extends ReflectiveMethodInvocation {\n      @Nullable\n      private final MethodProxy methodProxy;\n\n      public CglibMethodInvocation(Object proxy, @Nullable Object target, Method method, Object[] arguments, @Nullable Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers, MethodProxy methodProxy) {\n         super(proxy, target, method, arguments, targetClass, interceptorsAndDynamicMethodMatchers);\n         this.methodProxy = isMethodProxyCompatible(method) ? methodProxy : null;\n      }\n\n      @Nullable\n      public Object proceed() throws Throwable {\n         try {\n            return super.proceed();\n         } catch (RuntimeException var2) {\n            throw var2;\n         } catch (Exception var3) {\n            if (!ReflectionUtils.declaresException(this.getMethod(), var3.getClass()) && !KotlinDetector.isKotlinType(this.getMethod().getDeclaringClass())) {\n               throw new UndeclaredThrowableException(var3);\n            } else {\n               throw var3;\n            }\n         }\n      }\n\n      protected Object invokeJoinpoint() throws Throwable {\n         if (this.methodProxy != null) {\n            try {\n               return this.methodProxy.invoke(this.target, this.arguments);\n            } catch (CodeGenerationException var2) {\n               logFastClassGenerationFailure(this.method);\n            }\n         }\n\n         return super.invokeJoinpoint();\n      }\n\n      static boolean isMethodProxyCompatible(Method method) {\n         return Modifier.isPublic(method.getModifiers()) && method.getDeclaringClass() != Object.class && !AopUtils.isEqualsMethod(method) && !AopUtils.isHashCodeMethod(method) && !AopUtils.isToStringMethod(method);\n      }\n\n      static void logFastClassGenerationFailure(Method method) {\n         if (CglibAopProxy.logger.isDebugEnabled()) {\n            CglibAopProxy.logger.debug(\"Failed to generate CGLIB fast class for method: \" + method);\n         }\n\n      }\n   }\n\n   private static class DynamicAdvisedInterceptor implements MethodInterceptor, Serializable {\n      private final AdvisedSupport advised;\n\n      public DynamicAdvisedInterceptor(AdvisedSupport advised) {\n         this.advised = advised;\n      }\n\n      @Nullable\n      public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n         Object oldProxy = null;\n         boolean setProxyContext = false;\n         Object target = null;\n         TargetSource targetSource = this.advised.getTargetSource();\n\n         Object var16;\n         try {\n            if (this.advised.exposeProxy) {\n               oldProxy = AopContext.setCurrentProxy(proxy);\n               setProxyContext = true;\n            }\n\n            target = targetSource.getTarget();\n            Class<?> targetClass = target != null ? target.getClass() : null;\n            List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n            Object retVal;\n            if (chain.isEmpty() && CglibAopProxy.CglibMethodInvocation.isMethodProxyCompatible(method)) {\n               Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n               retVal = CglibAopProxy.invokeMethod(target, method, argsToUse, methodProxy);\n            } else {\n               retVal = (new CglibAopProxy.CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy)).proceed();\n            }\n\n            retVal = CglibAopProxy.processReturnType(proxy, target, method, retVal);\n            var16 = retVal;\n         } finally {\n            if (target != null && !targetSource.isStatic()) {\n               targetSource.releaseTarget(target);\n            }\n\n            if (setProxyContext) {\n               AopContext.setCurrentProxy(oldProxy);\n            }\n\n         }\n\n         return var16;\n      }\n\n      public boolean equals(@Nullable Object other) {\n         return this == other || other instanceof CglibAopProxy.DynamicAdvisedInterceptor && this.advised.equals(((CglibAopProxy.DynamicAdvisedInterceptor)other).advised);\n      }\n\n      public int hashCode() {\n         return this.advised.hashCode();\n      }\n   }\n\n   private static class FixedChainStaticTargetInterceptor implements MethodInterceptor, Serializable {\n      private final List<Object> adviceChain;\n      @Nullable\n      private final Object target;\n      @Nullable\n      private final Class<?> targetClass;\n\n      public FixedChainStaticTargetInterceptor(List<Object> adviceChain, @Nullable Object target, @Nullable Class<?> targetClass) {\n         this.adviceChain = adviceChain;\n         this.target = target;\n         this.targetClass = targetClass;\n      }\n\n      @Nullable\n      public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n         MethodInvocation invocation = new CglibAopProxy.CglibMethodInvocation(proxy, this.target, method, args, this.targetClass, this.adviceChain, methodProxy);\n         Object retVal = invocation.proceed();\n         retVal = CglibAopProxy.processReturnType(proxy, this.target, method, retVal);\n         return retVal;\n      }\n   }\n\n   private static class HashCodeInterceptor implements MethodInterceptor, Serializable {\n      private final AdvisedSupport advised;\n\n      public HashCodeInterceptor(AdvisedSupport advised) {\n         this.advised = advised;\n      }\n\n      public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) {\n         return CglibAopProxy.class.hashCode() * 13 + this.advised.getTargetSource().hashCode();\n      }\n   }\n\n   private static class EqualsInterceptor implements MethodInterceptor, Serializable {\n      private final AdvisedSupport advised;\n\n      public EqualsInterceptor(AdvisedSupport advised) {\n         this.advised = advised;\n      }\n\n      public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) {\n         Object other = args[0];\n         if (proxy == other) {\n            return true;\n         } else if (other instanceof Factory) {\n            Callback callback = ((Factory)other).getCallback(5);\n            if (!(callback instanceof CglibAopProxy.EqualsInterceptor)) {\n               return false;\n            } else {\n               AdvisedSupport otherAdvised = ((CglibAopProxy.EqualsInterceptor)callback).advised;\n               return AopProxyUtils.equalsInProxy(this.advised, otherAdvised);\n            }\n         } else {\n            return false;\n         }\n      }\n   }\n\n   private static class AdvisedDispatcher implements Dispatcher, Serializable {\n      private final AdvisedSupport advised;\n\n      public AdvisedDispatcher(AdvisedSupport advised) {\n         this.advised = advised;\n      }\n\n      public Object loadObject() {\n         return this.advised;\n      }\n   }\n\n   private static class StaticDispatcher implements Dispatcher, Serializable {\n      @Nullable\n      private final Object target;\n\n      public StaticDispatcher(@Nullable Object target) {\n         this.target = target;\n      }\n\n      @Nullable\n      public Object loadObject() {\n         return this.target;\n      }\n   }\n\n   private static class DynamicUnadvisedExposedInterceptor implements MethodInterceptor, Serializable {\n      private final TargetSource targetSource;\n\n      public DynamicUnadvisedExposedInterceptor(TargetSource targetSource) {\n         this.targetSource = targetSource;\n      }\n\n      @Nullable\n      public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n         Object oldProxy = null;\n         Object target = this.targetSource.getTarget();\n\n         Object var8;\n         try {\n            oldProxy = AopContext.setCurrentProxy(proxy);\n            Object retVal = CglibAopProxy.invokeMethod(target, method, args, methodProxy);\n            var8 = CglibAopProxy.processReturnType(proxy, target, method, retVal);\n         } finally {\n            AopContext.setCurrentProxy(oldProxy);\n            if (target != null) {\n               this.targetSource.releaseTarget(target);\n            }\n\n         }\n\n         return var8;\n      }\n   }\n\n   private static class DynamicUnadvisedInterceptor implements MethodInterceptor, Serializable {\n      private final TargetSource targetSource;\n\n      public DynamicUnadvisedInterceptor(TargetSource targetSource) {\n         this.targetSource = targetSource;\n      }\n\n      @Nullable\n      public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n         Object target = this.targetSource.getTarget();\n\n         Object var7;\n         try {\n            Object retVal = CglibAopProxy.invokeMethod(target, method, args, methodProxy);\n            var7 = CglibAopProxy.processReturnType(proxy, target, method, retVal);\n         } finally {\n            if (target != null) {\n               this.targetSource.releaseTarget(target);\n            }\n\n         }\n\n         return var7;\n      }\n   }\n\n   private static class StaticUnadvisedExposedInterceptor implements MethodInterceptor, Serializable {\n      @Nullable\n      private final Object target;\n\n      public StaticUnadvisedExposedInterceptor(@Nullable Object target) {\n         this.target = target;\n      }\n\n      @Nullable\n      public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n         Object oldProxy = null;\n\n         Object var7;\n         try {\n            oldProxy = AopContext.setCurrentProxy(proxy);\n            Object retVal = CglibAopProxy.invokeMethod(this.target, method, args, methodProxy);\n            var7 = CglibAopProxy.processReturnType(proxy, this.target, method, retVal);\n         } finally {\n            AopContext.setCurrentProxy(oldProxy);\n         }\n\n         return var7;\n      }\n   }\n\n   private static class StaticUnadvisedInterceptor implements MethodInterceptor, Serializable {\n      @Nullable\n      private final Object target;\n\n      public StaticUnadvisedInterceptor(@Nullable Object target) {\n         this.target = target;\n      }\n\n      @Nullable\n      public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n         Object retVal = CglibAopProxy.invokeMethod(this.target, method, args, methodProxy);\n         return CglibAopProxy.processReturnType(proxy, this.target, method, retVal);\n      }\n   }\n\n   public static class SerializableNoOp implements NoOp, Serializable {\n   }\n}\n"}