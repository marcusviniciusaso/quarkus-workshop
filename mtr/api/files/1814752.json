{"id":"1814752","content":"package org.springframework.boot.loader;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.jar.Attributes;\nimport java.util.jar.Manifest;\nimport org.springframework.boot.loader.archive.Archive;\nimport org.springframework.boot.loader.archive.ExplodedArchive;\nimport org.springframework.boot.loader.archive.Archive.Entry;\nimport org.springframework.boot.loader.archive.Archive.EntryFilter;\n\npublic abstract class ExecutableArchiveLauncher extends Launcher {\n   private static final String START_CLASS_ATTRIBUTE = \"Start-Class\";\n   protected static final String BOOT_CLASSPATH_INDEX_ATTRIBUTE = \"Spring-Boot-Classpath-Index\";\n   protected static final String DEFAULT_CLASSPATH_INDEX_FILE_NAME = \"classpath.idx\";\n   private final Archive archive;\n   private final ClassPathIndexFile classPathIndex;\n\n   public ExecutableArchiveLauncher() {\n      try {\n         this.archive = this.createArchive();\n         this.classPathIndex = this.getClassPathIndex(this.archive);\n      } catch (Exception var2) {\n         throw new IllegalStateException(var2);\n      }\n   }\n\n   protected ExecutableArchiveLauncher(Archive archive) {\n      try {\n         this.archive = archive;\n         this.classPathIndex = this.getClassPathIndex(this.archive);\n      } catch (Exception var3) {\n         throw new IllegalStateException(var3);\n      }\n   }\n\n   protected ClassPathIndexFile getClassPathIndex(Archive archive) throws IOException {\n      if (archive instanceof ExplodedArchive) {\n         String location = this.getClassPathIndexFileLocation(archive);\n         return ClassPathIndexFile.loadIfPossible(archive.getUrl(), location);\n      } else {\n         return null;\n      }\n   }\n\n   private String getClassPathIndexFileLocation(Archive archive) throws IOException {\n      Manifest manifest = archive.getManifest();\n      Attributes attributes = manifest != null ? manifest.getMainAttributes() : null;\n      String location = attributes != null ? attributes.getValue(\"Spring-Boot-Classpath-Index\") : null;\n      return location != null ? location : this.getArchiveEntryPathPrefix() + \"classpath.idx\";\n   }\n\n   protected String getMainClass() throws Exception {\n      Manifest manifest = this.archive.getManifest();\n      String mainClass = null;\n      if (manifest != null) {\n         mainClass = manifest.getMainAttributes().getValue(\"Start-Class\");\n      }\n\n      if (mainClass == null) {\n         throw new IllegalStateException(\"No 'Start-Class' manifest entry specified in \" + this);\n      } else {\n         return mainClass;\n      }\n   }\n\n   protected ClassLoader createClassLoader(Iterator<Archive> archives) throws Exception {\n      ArrayList urls = new ArrayList(this.guessClassPathSize());\n\n      while(archives.hasNext()) {\n         urls.add(((Archive)archives.next()).getUrl());\n      }\n\n      if (this.classPathIndex != null) {\n         urls.addAll(this.classPathIndex.getUrls());\n      }\n\n      return this.createClassLoader((URL[])urls.toArray(new URL[0]));\n   }\n\n   private int guessClassPathSize() {\n      return this.classPathIndex != null ? this.classPathIndex.size() + 10 : 50;\n   }\n\n   protected Iterator<Archive> getClassPathArchivesIterator() throws Exception {\n      EntryFilter searchFilter = this::isSearchCandidate;\n      Iterator<Archive> archives = this.archive.getNestedArchives(searchFilter, (entry) -> {\n         return this.isNestedArchive(entry) && !this.isEntryIndexed(entry);\n      });\n      if (this.isPostProcessingClassPathArchives()) {\n         archives = this.applyClassPathArchivePostProcessing(archives);\n      }\n\n      return archives;\n   }\n\n   private boolean isEntryIndexed(Entry entry) {\n      return this.classPathIndex != null ? this.classPathIndex.containsEntry(entry.getName()) : false;\n   }\n\n   private Iterator<Archive> applyClassPathArchivePostProcessing(Iterator<Archive> archives) throws Exception {\n      ArrayList list = new ArrayList();\n\n      while(archives.hasNext()) {\n         list.add(archives.next());\n      }\n\n      this.postProcessClassPathArchives(list);\n      return list.iterator();\n   }\n\n   protected boolean isSearchCandidate(Entry entry) {\n      return this.getArchiveEntryPathPrefix() == null ? true : entry.getName().startsWith(this.getArchiveEntryPathPrefix());\n   }\n\n   protected abstract boolean isNestedArchive(Entry var1);\n\n   protected boolean isPostProcessingClassPathArchives() {\n      return true;\n   }\n\n   protected void postProcessClassPathArchives(List<Archive> archives) throws Exception {\n   }\n\n   protected String getArchiveEntryPathPrefix() {\n      return null;\n   }\n\n   protected boolean isExploded() {\n      return this.archive.isExploded();\n   }\n\n   protected final Archive getArchive() {\n      return this.archive;\n   }\n}\n"}