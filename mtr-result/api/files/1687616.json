{"id":"1687616","content":"package org.springframework.aop.aspectj;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.aopalliance.aop.Advice;\nimport org.aopalliance.intercept.MethodInvocation;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.JoinPoint.StaticPart;\nimport org.aspectj.weaver.tools.JoinPointMatch;\nimport org.aspectj.weaver.tools.PointcutParameter;\nimport org.springframework.aop.AopInvocationException;\nimport org.springframework.aop.MethodMatcher;\nimport org.springframework.aop.Pointcut;\nimport org.springframework.aop.ProxyMethodInvocation;\nimport org.springframework.aop.interceptor.ExposeInvocationInterceptor;\nimport org.springframework.aop.support.ComposablePointcut;\nimport org.springframework.aop.support.MethodMatchers;\nimport org.springframework.aop.support.StaticMethodMatcher;\nimport org.springframework.core.DefaultParameterNameDiscoverer;\nimport org.springframework.core.ParameterNameDiscoverer;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.util.StringUtils;\n\npublic abstract class AbstractAspectJAdvice implements Advice, AspectJPrecedenceInformation, Serializable {\n   protected static final String JOIN_POINT_KEY = JoinPoint.class.getName();\n   private final Class<?> declaringClass;\n   private final String methodName;\n   private final Class<?>[] parameterTypes;\n   protected transient Method aspectJAdviceMethod;\n   private final AspectJExpressionPointcut pointcut;\n   private final AspectInstanceFactory aspectInstanceFactory;\n   private String aspectName = \"\";\n   private int declarationOrder;\n   @Nullable\n   private String[] argumentNames;\n   @Nullable\n   private String throwingName;\n   @Nullable\n   private String returningName;\n   private Class<?> discoveredReturningType = Object.class;\n   private Class<?> discoveredThrowingType = Object.class;\n   private int joinPointArgumentIndex = -1;\n   private int joinPointStaticPartArgumentIndex = -1;\n   @Nullable\n   private Map<String, Integer> argumentBindings;\n   private boolean argumentsIntrospected = false;\n   @Nullable\n   private Type discoveredReturningGenericType;\n\n   public static JoinPoint currentJoinPoint() {\n      MethodInvocation mi = ExposeInvocationInterceptor.currentInvocation();\n      if (!(mi instanceof ProxyMethodInvocation)) {\n         throw new IllegalStateException(\"MethodInvocation is not a Spring ProxyMethodInvocation: \" + mi);\n      } else {\n         ProxyMethodInvocation pmi = (ProxyMethodInvocation)mi;\n         JoinPoint jp = (JoinPoint)pmi.getUserAttribute(JOIN_POINT_KEY);\n         if (jp == null) {\n            jp = new MethodInvocationProceedingJoinPoint(pmi);\n            pmi.setUserAttribute(JOIN_POINT_KEY, jp);\n         }\n\n         return (JoinPoint)jp;\n      }\n   }\n\n   public AbstractAspectJAdvice(Method aspectJAdviceMethod, AspectJExpressionPointcut pointcut, AspectInstanceFactory aspectInstanceFactory) {\n      Assert.notNull(aspectJAdviceMethod, \"Advice method must not be null\");\n      this.declaringClass = aspectJAdviceMethod.getDeclaringClass();\n      this.methodName = aspectJAdviceMethod.getName();\n      this.parameterTypes = aspectJAdviceMethod.getParameterTypes();\n      this.aspectJAdviceMethod = aspectJAdviceMethod;\n      this.pointcut = pointcut;\n      this.aspectInstanceFactory = aspectInstanceFactory;\n   }\n\n   public final Method getAspectJAdviceMethod() {\n      return this.aspectJAdviceMethod;\n   }\n\n   public final AspectJExpressionPointcut getPointcut() {\n      this.calculateArgumentBindings();\n      return this.pointcut;\n   }\n\n   public final Pointcut buildSafePointcut() {\n      Pointcut pc = this.getPointcut();\n      MethodMatcher safeMethodMatcher = MethodMatchers.intersection(new AbstractAspectJAdvice.AdviceExcludingMethodMatcher(this.aspectJAdviceMethod), pc.getMethodMatcher());\n      return new ComposablePointcut(pc.getClassFilter(), safeMethodMatcher);\n   }\n\n   public final AspectInstanceFactory getAspectInstanceFactory() {\n      return this.aspectInstanceFactory;\n   }\n\n   @Nullable\n   public final ClassLoader getAspectClassLoader() {\n      return this.aspectInstanceFactory.getAspectClassLoader();\n   }\n\n   public int getOrder() {\n      return this.aspectInstanceFactory.getOrder();\n   }\n\n   public void setAspectName(String name) {\n      this.aspectName = name;\n   }\n\n   public String getAspectName() {\n      return this.aspectName;\n   }\n\n   public void setDeclarationOrder(int order) {\n      this.declarationOrder = order;\n   }\n\n   public int getDeclarationOrder() {\n      return this.declarationOrder;\n   }\n\n   public void setArgumentNames(String argNames) {\n      String[] tokens = StringUtils.commaDelimitedListToStringArray(argNames);\n      this.setArgumentNamesFromStringArray(tokens);\n   }\n\n   public void setArgumentNamesFromStringArray(String... args) {\n      this.argumentNames = new String[args.length];\n\n      for(int i = 0; i < args.length; ++i) {\n         this.argumentNames[i] = StringUtils.trimWhitespace(args[i]);\n         if (!isVariableName(this.argumentNames[i])) {\n            throw new IllegalArgumentException(\"'argumentNames' property of AbstractAspectJAdvice contains an argument name '\" + this.argumentNames[i] + \"' that is not a valid Java identifier\");\n         }\n      }\n\n      if (this.argumentNames != null && this.aspectJAdviceMethod.getParameterCount() == this.argumentNames.length + 1) {\n         Class<?> firstArgType = this.aspectJAdviceMethod.getParameterTypes()[0];\n         if (firstArgType == JoinPoint.class || firstArgType == ProceedingJoinPoint.class || firstArgType == StaticPart.class) {\n            String[] oldNames = this.argumentNames;\n            this.argumentNames = new String[oldNames.length + 1];\n            this.argumentNames[0] = \"THIS_JOIN_POINT\";\n            System.arraycopy(oldNames, 0, this.argumentNames, 1, oldNames.length);\n         }\n      }\n\n   }\n\n   public void setReturningName(String name) {\n      throw new UnsupportedOperationException(\"Only afterReturning advice can be used to bind a return value\");\n   }\n\n   protected void setReturningNameNoCheck(String name) {\n      if (isVariableName(name)) {\n         this.returningName = name;\n      } else {\n         try {\n            this.discoveredReturningType = ClassUtils.forName(name, this.getAspectClassLoader());\n         } catch (Throwable var3) {\n            throw new IllegalArgumentException(\"Returning name '\" + name + \"' is neither a valid argument name nor the fully-qualified name of a Java type on the classpath. Root cause: \" + var3);\n         }\n      }\n\n   }\n\n   protected Class<?> getDiscoveredReturningType() {\n      return this.discoveredReturningType;\n   }\n\n   @Nullable\n   protected Type getDiscoveredReturningGenericType() {\n      return this.discoveredReturningGenericType;\n   }\n\n   public void setThrowingName(String name) {\n      throw new UnsupportedOperationException(\"Only afterThrowing advice can be used to bind a thrown exception\");\n   }\n\n   protected void setThrowingNameNoCheck(String name) {\n      if (isVariableName(name)) {\n         this.throwingName = name;\n      } else {\n         try {\n            this.discoveredThrowingType = ClassUtils.forName(name, this.getAspectClassLoader());\n         } catch (Throwable var3) {\n            throw new IllegalArgumentException(\"Throwing name '\" + name + \"' is neither a valid argument name nor the fully-qualified name of a Java type on the classpath. Root cause: \" + var3);\n         }\n      }\n\n   }\n\n   protected Class<?> getDiscoveredThrowingType() {\n      return this.discoveredThrowingType;\n   }\n\n   private static boolean isVariableName(String name) {\n      return AspectJProxyUtils.isVariableName(name);\n   }\n\n   public final void calculateArgumentBindings() {\n      if (!this.argumentsIntrospected && this.parameterTypes.length != 0) {\n         int numUnboundArgs = this.parameterTypes.length;\n         Class<?>[] parameterTypes = this.aspectJAdviceMethod.getParameterTypes();\n         if (this.maybeBindJoinPoint(parameterTypes[0]) || this.maybeBindProceedingJoinPoint(parameterTypes[0]) || this.maybeBindJoinPointStaticPart(parameterTypes[0])) {\n            --numUnboundArgs;\n         }\n\n         if (numUnboundArgs > 0) {\n            this.bindArgumentsByName(numUnboundArgs);\n         }\n\n         this.argumentsIntrospected = true;\n      }\n   }\n\n   private boolean maybeBindJoinPoint(Class<?> candidateParameterType) {\n      if (JoinPoint.class == candidateParameterType) {\n         this.joinPointArgumentIndex = 0;\n         return true;\n      } else {\n         return false;\n      }\n   }\n\n   private boolean maybeBindProceedingJoinPoint(Class<?> candidateParameterType) {\n      if (ProceedingJoinPoint.class == candidateParameterType) {\n         if (!this.supportsProceedingJoinPoint()) {\n            throw new IllegalArgumentException(\"ProceedingJoinPoint is only supported for around advice\");\n         } else {\n            this.joinPointArgumentIndex = 0;\n            return true;\n         }\n      } else {\n         return false;\n      }\n   }\n\n   protected boolean supportsProceedingJoinPoint() {\n      return false;\n   }\n\n   private boolean maybeBindJoinPointStaticPart(Class<?> candidateParameterType) {\n      if (StaticPart.class == candidateParameterType) {\n         this.joinPointStaticPartArgumentIndex = 0;\n         return true;\n      } else {\n         return false;\n      }\n   }\n\n   private void bindArgumentsByName(int numArgumentsExpectingToBind) {\n      if (this.argumentNames == null) {\n         this.argumentNames = this.createParameterNameDiscoverer().getParameterNames(this.aspectJAdviceMethod);\n      }\n\n      if (this.argumentNames != null) {\n         this.bindExplicitArguments(numArgumentsExpectingToBind);\n      } else {\n         throw new IllegalStateException(\"Advice method [\" + this.aspectJAdviceMethod.getName() + \"] requires \" + numArgumentsExpectingToBind + \" arguments to be bound by name, but the argument names were not specified and could not be discovered.\");\n      }\n   }\n\n   protected ParameterNameDiscoverer createParameterNameDiscoverer() {\n      DefaultParameterNameDiscoverer discoverer = new DefaultParameterNameDiscoverer();\n      AspectJAdviceParameterNameDiscoverer adviceParameterNameDiscoverer = new AspectJAdviceParameterNameDiscoverer(this.pointcut.getExpression());\n      adviceParameterNameDiscoverer.setReturningName(this.returningName);\n      adviceParameterNameDiscoverer.setThrowingName(this.throwingName);\n      adviceParameterNameDiscoverer.setRaiseExceptions(true);\n      discoverer.addDiscoverer(adviceParameterNameDiscoverer);\n      return discoverer;\n   }\n\n   private void bindExplicitArguments(int numArgumentsLeftToBind) {\n      Assert.state(this.argumentNames != null, \"No argument names available\");\n      this.argumentBindings = new HashMap();\n      int numExpectedArgumentNames = this.aspectJAdviceMethod.getParameterCount();\n      if (this.argumentNames.length != numExpectedArgumentNames) {\n         throw new IllegalStateException(\"Expecting to find \" + numExpectedArgumentNames + \" arguments to bind by name in advice, but actually found \" + this.argumentNames.length + \" arguments.\");\n      } else {\n         int argumentIndexOffset = this.parameterTypes.length - numArgumentsLeftToBind;\n\n         for(int i = argumentIndexOffset; i < this.argumentNames.length; ++i) {\n            this.argumentBindings.put(this.argumentNames[i], i);\n         }\n\n         Integer index;\n         if (this.returningName != null) {\n            if (!this.argumentBindings.containsKey(this.returningName)) {\n               throw new IllegalStateException(\"Returning argument name '\" + this.returningName + \"' was not bound in advice arguments\");\n            }\n\n            index = (Integer)this.argumentBindings.get(this.returningName);\n            this.discoveredReturningType = this.aspectJAdviceMethod.getParameterTypes()[index.intValue()];\n            this.discoveredReturningGenericType = this.aspectJAdviceMethod.getGenericParameterTypes()[index.intValue()];\n         }\n\n         if (this.throwingName != null) {\n            if (!this.argumentBindings.containsKey(this.throwingName)) {\n               throw new IllegalStateException(\"Throwing argument name '\" + this.throwingName + \"' was not bound in advice arguments\");\n            }\n\n            index = (Integer)this.argumentBindings.get(this.throwingName);\n            this.discoveredThrowingType = this.aspectJAdviceMethod.getParameterTypes()[index.intValue()];\n         }\n\n         this.configurePointcutParameters(this.argumentNames, argumentIndexOffset);\n      }\n   }\n\n   private void configurePointcutParameters(String[] argumentNames, int argumentIndexOffset) {\n      int numParametersToRemove = argumentIndexOffset;\n      if (this.returningName != null) {\n         numParametersToRemove = argumentIndexOffset + 1;\n      }\n\n      if (this.throwingName != null) {\n         ++numParametersToRemove;\n      }\n\n      String[] pointcutParameterNames = new String[argumentNames.length - numParametersToRemove];\n      Class<?>[] pointcutParameterTypes = new Class[pointcutParameterNames.length];\n      Class<?>[] methodParameterTypes = this.aspectJAdviceMethod.getParameterTypes();\n      int index = 0;\n\n      for(int i = 0; i < argumentNames.length; ++i) {\n         if (i >= argumentIndexOffset && !argumentNames[i].equals(this.returningName) && !argumentNames[i].equals(this.throwingName)) {\n            pointcutParameterNames[index] = argumentNames[i];\n            pointcutParameterTypes[index] = methodParameterTypes[i];\n            ++index;\n         }\n      }\n\n      this.pointcut.setParameterNames(pointcutParameterNames);\n      this.pointcut.setParameterTypes(pointcutParameterTypes);\n   }\n\n   protected Object[] argBinding(JoinPoint jp, @Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex) {\n      this.calculateArgumentBindings();\n      Object[] adviceInvocationArgs = new Object[this.parameterTypes.length];\n      int numBound = 0;\n      if (this.joinPointArgumentIndex != -1) {\n         adviceInvocationArgs[this.joinPointArgumentIndex] = jp;\n         ++numBound;\n      } else if (this.joinPointStaticPartArgumentIndex != -1) {\n         adviceInvocationArgs[this.joinPointStaticPartArgumentIndex] = jp.getStaticPart();\n         ++numBound;\n      }\n\n      if (!CollectionUtils.isEmpty(this.argumentBindings)) {\n         if (jpMatch != null) {\n            PointcutParameter[] parameterBindings = jpMatch.getParameterBindings();\n            PointcutParameter[] var8 = parameterBindings;\n            int var9 = parameterBindings.length;\n\n            for(int var10 = 0; var10 < var9; ++var10) {\n               PointcutParameter parameter = var8[var10];\n               String name = parameter.getName();\n               Integer index = (Integer)this.argumentBindings.get(name);\n               adviceInvocationArgs[index.intValue()] = parameter.getBinding();\n               ++numBound;\n            }\n         }\n\n         Integer index;\n         if (this.returningName != null) {\n            index = (Integer)this.argumentBindings.get(this.returningName);\n            adviceInvocationArgs[index.intValue()] = returnValue;\n            ++numBound;\n         }\n\n         if (this.throwingName != null) {\n            index = (Integer)this.argumentBindings.get(this.throwingName);\n            adviceInvocationArgs[index.intValue()] = ex;\n            ++numBound;\n         }\n      }\n\n      if (numBound != this.parameterTypes.length) {\n         throw new IllegalStateException(\"Required to bind \" + this.parameterTypes.length + \" arguments, but only bound \" + numBound + \" (JoinPointMatch \" + (jpMatch == null ? \"was NOT\" : \"WAS\") + \" bound in invocation)\");\n      } else {\n         return adviceInvocationArgs;\n      }\n   }\n\n   protected Object invokeAdviceMethod(@Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex) throws Throwable {\n      return this.invokeAdviceMethodWithGivenArgs(this.argBinding(this.getJoinPoint(), jpMatch, returnValue, ex));\n   }\n\n   protected Object invokeAdviceMethod(JoinPoint jp, @Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable t) throws Throwable {\n      return this.invokeAdviceMethodWithGivenArgs(this.argBinding(jp, jpMatch, returnValue, t));\n   }\n\n   protected Object invokeAdviceMethodWithGivenArgs(Object[] args) throws Throwable {\n      Object[] actualArgs = args;\n      if (this.aspectJAdviceMethod.getParameterCount() == 0) {\n         actualArgs = null;\n      }\n\n      try {\n         ReflectionUtils.makeAccessible(this.aspectJAdviceMethod);\n         return this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);\n      } catch (IllegalArgumentException var4) {\n         throw new AopInvocationException(\"Mismatch on arguments to advice method [\" + this.aspectJAdviceMethod + \"]; pointcut expression [\" + this.pointcut.getPointcutExpression() + \"]\", var4);\n      } catch (InvocationTargetException var5) {\n         throw var5.getTargetException();\n      }\n   }\n\n   protected JoinPoint getJoinPoint() {\n      return currentJoinPoint();\n   }\n\n   @Nullable\n   protected JoinPointMatch getJoinPointMatch() {\n      MethodInvocation mi = ExposeInvocationInterceptor.currentInvocation();\n      if (!(mi instanceof ProxyMethodInvocation)) {\n         throw new IllegalStateException(\"MethodInvocation is not a Spring ProxyMethodInvocation: \" + mi);\n      } else {\n         return this.getJoinPointMatch((ProxyMethodInvocation)mi);\n      }\n   }\n\n   @Nullable\n   protected JoinPointMatch getJoinPointMatch(ProxyMethodInvocation pmi) {\n      String expression = this.pointcut.getExpression();\n      return expression != null ? (JoinPointMatch)pmi.getUserAttribute(expression) : null;\n   }\n\n   public String toString() {\n      return this.getClass().getName() + \": advice method [\" + this.aspectJAdviceMethod + \"]; aspect name '\" + this.aspectName + \"'\";\n   }\n\n   private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\n      inputStream.defaultReadObject();\n\n      try {\n         this.aspectJAdviceMethod = this.declaringClass.getMethod(this.methodName, this.parameterTypes);\n      } catch (NoSuchMethodException var3) {\n         throw new IllegalStateException(\"Failed to find advice method on deserialization\", var3);\n      }\n   }\n\n   private static class AdviceExcludingMethodMatcher extends StaticMethodMatcher {\n      private final Method adviceMethod;\n\n      public AdviceExcludingMethodMatcher(Method adviceMethod) {\n         this.adviceMethod = adviceMethod;\n      }\n\n      public boolean matches(Method method, Class<?> targetClass) {\n         return !this.adviceMethod.equals(method);\n      }\n\n      public boolean equals(@Nullable Object other) {\n         if (this == other) {\n            return true;\n         } else if (!(other instanceof AbstractAspectJAdvice.AdviceExcludingMethodMatcher)) {\n            return false;\n         } else {\n            AbstractAspectJAdvice.AdviceExcludingMethodMatcher otherMm = (AbstractAspectJAdvice.AdviceExcludingMethodMatcher)other;\n            return this.adviceMethod.equals(otherMm.adviceMethod);\n         }\n      }\n\n      public int hashCode() {\n         return this.adviceMethod.hashCode();\n      }\n\n      public String toString() {\n         return this.getClass().getName() + \": \" + this.adviceMethod;\n      }\n   }\n}\n"}