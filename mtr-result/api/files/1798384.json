{"id":"1798384","content":"package ch.qos.logback.classic.spi;\n\nimport java.net.URL;\nimport java.security.CodeSource;\nimport java.util.HashMap;\nimport sun.reflect.Reflection;\n\npublic class PackagingDataCalculator {\n   static final StackTraceElementProxy[] STEP_ARRAY_TEMPLATE = new StackTraceElementProxy[0];\n   HashMap<String, ClassPackagingData> cache = new HashMap();\n   private static boolean GET_CALLER_CLASS_METHOD_AVAILABLE = false;\n\n   public void calculate(IThrowableProxy tp) {\n      for(; tp != null; tp = tp.getCause()) {\n         this.populateFrames(tp.getStackTraceElementProxyArray());\n         IThrowableProxy[] suppressed = tp.getSuppressed();\n         if (suppressed != null) {\n            IThrowableProxy[] var3 = suppressed;\n            int var4 = suppressed.length;\n\n            for(int var5 = 0; var5 < var4; ++var5) {\n               IThrowableProxy current = var3[var5];\n               this.populateFrames(current.getStackTraceElementProxyArray());\n            }\n         }\n      }\n\n   }\n\n   void populateFrames(StackTraceElementProxy[] stepArray) {\n      Throwable t = new Throwable(\"local stack reference\");\n      StackTraceElement[] localteSTEArray = t.getStackTrace();\n      int commonFrames = STEUtil.findNumberOfCommonFrames(localteSTEArray, stepArray);\n      int localFirstCommon = localteSTEArray.length - commonFrames;\n      int stepFirstCommon = stepArray.length - commonFrames;\n      ClassLoader lastExactClassLoader = null;\n      ClassLoader firsExactClassLoader = null;\n      int missfireCount = 0;\n\n      for(int i = 0; i < commonFrames; ++i) {\n         Class callerClass = null;\n         if (GET_CALLER_CLASS_METHOD_AVAILABLE) {\n            callerClass = Reflection.getCallerClass(localFirstCommon + i - missfireCount + 1);\n         }\n\n         StackTraceElementProxy step = stepArray[stepFirstCommon + i];\n         String stepClassname = step.ste.getClassName();\n         ClassPackagingData pi;\n         if (callerClass != null && stepClassname.equals(callerClass.getName())) {\n            lastExactClassLoader = callerClass.getClassLoader();\n            if (firsExactClassLoader == null) {\n               firsExactClassLoader = lastExactClassLoader;\n            }\n\n            pi = this.calculateByExactType(callerClass);\n            step.setClassPackagingData(pi);\n         } else {\n            ++missfireCount;\n            pi = this.computeBySTEP(step, lastExactClassLoader);\n            step.setClassPackagingData(pi);\n         }\n      }\n\n      this.populateUncommonFrames(commonFrames, stepArray, firsExactClassLoader);\n   }\n\n   void populateUncommonFrames(int commonFrames, StackTraceElementProxy[] stepArray, ClassLoader firstExactClassLoader) {\n      int uncommonFrames = stepArray.length - commonFrames;\n\n      for(int i = 0; i < uncommonFrames; ++i) {\n         StackTraceElementProxy step = stepArray[i];\n         ClassPackagingData pi = this.computeBySTEP(step, firstExactClassLoader);\n         step.setClassPackagingData(pi);\n      }\n\n   }\n\n   private ClassPackagingData calculateByExactType(Class type) {\n      String className = type.getName();\n      ClassPackagingData cpd = (ClassPackagingData)this.cache.get(className);\n      if (cpd != null) {\n         return cpd;\n      } else {\n         String version = this.getImplementationVersion(type);\n         String codeLocation = this.getCodeLocation(type);\n         cpd = new ClassPackagingData(codeLocation, version);\n         this.cache.put(className, cpd);\n         return cpd;\n      }\n   }\n\n   private ClassPackagingData computeBySTEP(StackTraceElementProxy step, ClassLoader lastExactClassLoader) {\n      String className = step.ste.getClassName();\n      ClassPackagingData cpd = (ClassPackagingData)this.cache.get(className);\n      if (cpd != null) {\n         return cpd;\n      } else {\n         Class type = this.bestEffortLoadClass(lastExactClassLoader, className);\n         String version = this.getImplementationVersion(type);\n         String codeLocation = this.getCodeLocation(type);\n         cpd = new ClassPackagingData(codeLocation, version, false);\n         this.cache.put(className, cpd);\n         return cpd;\n      }\n   }\n\n   String getImplementationVersion(Class type) {\n      if (type == null) {\n         return \"na\";\n      } else {\n         Package aPackage = type.getPackage();\n         if (aPackage != null) {\n            String v = aPackage.getImplementationVersion();\n            return v == null ? \"na\" : v;\n         } else {\n            return \"na\";\n         }\n      }\n   }\n\n   String getCodeLocation(Class type) {\n      try {\n         if (type != null) {\n            CodeSource codeSource = type.getProtectionDomain().getCodeSource();\n            if (codeSource != null) {\n               URL resource = codeSource.getLocation();\n               if (resource != null) {\n                  String locationStr = resource.toString();\n                  String result = this.getCodeLocation(locationStr, '/');\n                  if (result != null) {\n                     return result;\n                  }\n\n                  return this.getCodeLocation(locationStr, '\\\\');\n               }\n            }\n         }\n      } catch (Exception var6) {\n         ;\n      }\n\n      return \"na\";\n   }\n\n   private String getCodeLocation(String locationStr, char separator) {\n      int idx = locationStr.lastIndexOf(separator);\n      if (this.isFolder(idx, locationStr)) {\n         idx = locationStr.lastIndexOf(separator, idx - 1);\n         return locationStr.substring(idx + 1);\n      } else {\n         return idx > 0 ? locationStr.substring(idx + 1) : null;\n      }\n   }\n\n   private boolean isFolder(int idx, String text) {\n      return idx != -1 && idx + 1 == text.length();\n   }\n\n   private Class loadClass(ClassLoader cl, String className) {\n      if (cl == null) {\n         return null;\n      } else {\n         try {\n            return cl.loadClass(className);\n         } catch (ClassNotFoundException var4) {\n            return null;\n         } catch (NoClassDefFoundError var5) {\n            return null;\n         } catch (Exception var6) {\n            var6.printStackTrace();\n            return null;\n         }\n      }\n   }\n\n   private Class bestEffortLoadClass(ClassLoader lastGuaranteedClassLoader, String className) {\n      Class result = this.loadClass(lastGuaranteedClassLoader, className);\n      if (result != null) {\n         return result;\n      } else {\n         ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n         if (tccl != lastGuaranteedClassLoader) {\n            result = this.loadClass(tccl, className);\n         }\n\n         if (result != null) {\n            return result;\n         } else {\n            try {\n               return Class.forName(className);\n            } catch (ClassNotFoundException var6) {\n               return null;\n            } catch (NoClassDefFoundError var7) {\n               return null;\n            } catch (Exception var8) {\n               var8.printStackTrace();\n               return null;\n            }\n         }\n      }\n   }\n\n   static {\n      try {\n         Reflection.getCallerClass(2);\n         GET_CALLER_CLASS_METHOD_AVAILABLE = true;\n      } catch (NoClassDefFoundError var1) {\n         ;\n      } catch (NoSuchMethodError var2) {\n         ;\n      } catch (UnsupportedOperationException var3) {\n         ;\n      } catch (Throwable var4) {\n         System.err.println(\"Unexpected exception\");\n         var4.printStackTrace();\n      }\n\n   }\n}\n"}