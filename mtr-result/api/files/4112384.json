{"id":"4112384","content":"package ch.qos.logback.core.net.server;\n\nimport ch.qos.logback.core.spi.ContextAwareBase;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic abstract class ConcurrentServerRunner<T extends Client> extends ContextAwareBase implements Runnable, ServerRunner<T> {\n   private final Lock clientsLock = new ReentrantLock();\n   private final Collection<T> clients = new ArrayList();\n   private final ServerListener<T> listener;\n   private final Executor executor;\n   private boolean running;\n\n   public ConcurrentServerRunner(ServerListener<T> listener, Executor executor) {\n      this.listener = listener;\n      this.executor = executor;\n   }\n\n   public boolean isRunning() {\n      return this.running;\n   }\n\n   protected void setRunning(boolean running) {\n      this.running = running;\n   }\n\n   public void stop() throws IOException {\n      this.listener.close();\n      this.accept(new ClientVisitor<T>() {\n         public void visit(T client) {\n            client.close();\n         }\n      });\n   }\n\n   public void accept(ClientVisitor<T> visitor) {\n      Collection<T> clients = this.copyClients();\n      Iterator var3 = clients.iterator();\n\n      while(var3.hasNext()) {\n         Client client = (Client)var3.next();\n\n         try {\n            visitor.visit(client);\n         } catch (RuntimeException var6) {\n            this.addError(client + \": \" + var6);\n         }\n      }\n\n   }\n\n   private Collection<T> copyClients() {\n      this.clientsLock.lock();\n\n      ArrayList var2;\n      try {\n         Collection<T> copy = new ArrayList(this.clients);\n         var2 = copy;\n      } finally {\n         this.clientsLock.unlock();\n      }\n\n      return var2;\n   }\n\n   public void run() {\n      this.setRunning(true);\n\n      try {\n         this.addInfo(\"listening on \" + this.listener);\n\n         while(!Thread.currentThread().isInterrupted()) {\n            T client = this.listener.acceptClient();\n            if (!this.configureClient(client)) {\n               this.addError(client + \": connection dropped\");\n               client.close();\n            } else {\n               try {\n                  this.executor.execute(new ConcurrentServerRunner.ClientWrapper(client));\n               } catch (RejectedExecutionException var3) {\n                  this.addError(client + \": connection dropped\");\n                  client.close();\n               }\n            }\n         }\n      } catch (InterruptedException var4) {\n         ;\n      } catch (Exception var5) {\n         this.addError(\"listener: \" + var5);\n      }\n\n      this.setRunning(false);\n      this.addInfo(\"shutting down\");\n      this.listener.close();\n   }\n\n   protected abstract boolean configureClient(T var1);\n\n   private void addClient(T client) {\n      this.clientsLock.lock();\n\n      try {\n         this.clients.add(client);\n      } finally {\n         this.clientsLock.unlock();\n      }\n\n   }\n\n   private void removeClient(T client) {\n      this.clientsLock.lock();\n\n      try {\n         this.clients.remove(client);\n      } finally {\n         this.clientsLock.unlock();\n      }\n\n   }\n\n   private class ClientWrapper implements Client {\n      private final T delegate;\n\n      public ClientWrapper(T var1) {\n         this.delegate = client;\n      }\n\n      public void run() {\n         ConcurrentServerRunner.this.addClient(this.delegate);\n\n         try {\n            this.delegate.run();\n         } finally {\n            ConcurrentServerRunner.this.removeClient(this.delegate);\n         }\n\n      }\n\n      public void close() {\n         this.delegate.close();\n      }\n   }\n}\n"}