{"id":"1573048","content":"package org.springframework.aop.framework;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.List;\nimport org.aopalliance.intercept.MethodInvocation;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.aop.AopInvocationException;\nimport org.springframework.aop.RawTargetAccess;\nimport org.springframework.aop.TargetSource;\nimport org.springframework.aop.support.AopUtils;\nimport org.springframework.core.DecoratingProxy;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\n\nfinal class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable {\n   private static final long serialVersionUID = 5531744639992436476L;\n   private static final Log logger = LogFactory.getLog(JdkDynamicAopProxy.class);\n   private final AdvisedSupport advised;\n   private final Class<?>[] proxiedInterfaces;\n   private boolean equalsDefined;\n   private boolean hashCodeDefined;\n\n   public JdkDynamicAopProxy(AdvisedSupport config) throws AopConfigException {\n      Assert.notNull(config, \"AdvisedSupport must not be null\");\n      if (config.getAdvisorCount() == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {\n         throw new AopConfigException(\"No advisors and no TargetSource specified\");\n      } else {\n         this.advised = config;\n         this.proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);\n         this.findDefinedEqualsAndHashCodeMethods(this.proxiedInterfaces);\n      }\n   }\n\n   public Object getProxy() {\n      return this.getProxy(ClassUtils.getDefaultClassLoader());\n   }\n\n   public Object getProxy(@Nullable ClassLoader classLoader) {\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Creating JDK dynamic proxy: \" + this.advised.getTargetSource());\n      }\n\n      return Proxy.newProxyInstance(this.determineClassLoader(classLoader), this.proxiedInterfaces, this);\n   }\n\n   private ClassLoader determineClassLoader(@Nullable ClassLoader classLoader) {\n      if (classLoader == null) {\n         return this.getClass().getClassLoader();\n      } else {\n         if (classLoader.getParent() == null) {\n            ClassLoader aopClassLoader = this.getClass().getClassLoader();\n\n            for(ClassLoader aopParent = aopClassLoader.getParent(); aopParent != null; aopParent = aopParent.getParent()) {\n               if (classLoader == aopParent) {\n                  return aopClassLoader;\n               }\n            }\n         }\n\n         return classLoader;\n      }\n   }\n\n   private void findDefinedEqualsAndHashCodeMethods(Class<?>[] proxiedInterfaces) {\n      Class[] var2 = proxiedInterfaces;\n      int var3 = proxiedInterfaces.length;\n\n      for(int var4 = 0; var4 < var3; ++var4) {\n         Class<?> proxiedInterface = var2[var4];\n         Method[] methods = proxiedInterface.getDeclaredMethods();\n         Method[] var7 = methods;\n         int var8 = methods.length;\n\n         for(int var9 = 0; var9 < var8; ++var9) {\n            Method method = var7[var9];\n            if (AopUtils.isEqualsMethod(method)) {\n               this.equalsDefined = true;\n            }\n\n            if (AopUtils.isHashCodeMethod(method)) {\n               this.hashCodeDefined = true;\n            }\n\n            if (this.equalsDefined && this.hashCodeDefined) {\n               return;\n            }\n         }\n      }\n\n   }\n\n   @Nullable\n   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      Object oldProxy = null;\n      boolean setProxyContext = false;\n      TargetSource targetSource = this.advised.targetSource;\n      Object target = null;\n\n      Object var12;\n      try {\n         if (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {\n            Boolean var18 = this.equals(args[0]);\n            return var18;\n         }\n\n         if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {\n            Integer var17 = this.hashCode();\n            return var17;\n         }\n\n         if (method.getDeclaringClass() == DecoratingProxy.class) {\n            Class var16 = AopProxyUtils.ultimateTargetClass(this.advised);\n            return var16;\n         }\n\n         Object retVal;\n         if (!this.advised.opaque && method.getDeclaringClass().isInterface() && method.getDeclaringClass().isAssignableFrom(Advised.class)) {\n            retVal = AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);\n            return retVal;\n         }\n\n         if (this.advised.exposeProxy) {\n            oldProxy = AopContext.setCurrentProxy(proxy);\n            setProxyContext = true;\n         }\n\n         target = targetSource.getTarget();\n         Class<?> targetClass = target != null ? target.getClass() : null;\n         List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n         if (chain.isEmpty()) {\n            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);\n         } else {\n            MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\n            retVal = invocation.proceed();\n         }\n\n         Class<?> returnType = method.getReturnType();\n         if (retVal != null && retVal == target && returnType != Object.class && returnType.isInstance(proxy) && !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {\n            retVal = proxy;\n         } else if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {\n            throw new AopInvocationException(\"Null return value from advice does not match primitive return type for: \" + method);\n         }\n\n         var12 = retVal;\n      } finally {\n         if (target != null && !targetSource.isStatic()) {\n            targetSource.releaseTarget(target);\n         }\n\n         if (setProxyContext) {\n            AopContext.setCurrentProxy(oldProxy);\n         }\n\n      }\n\n      return var12;\n   }\n\n   public boolean equals(@Nullable Object other) {\n      if (other == this) {\n         return true;\n      } else if (other == null) {\n         return false;\n      } else {\n         JdkDynamicAopProxy otherProxy;\n         if (other instanceof JdkDynamicAopProxy) {\n            otherProxy = (JdkDynamicAopProxy)other;\n         } else {\n            if (!Proxy.isProxyClass(other.getClass())) {\n               return false;\n            }\n\n            InvocationHandler ih = Proxy.getInvocationHandler(other);\n            if (!(ih instanceof JdkDynamicAopProxy)) {\n               return false;\n            }\n\n            otherProxy = (JdkDynamicAopProxy)ih;\n         }\n\n         return AopProxyUtils.equalsInProxy(this.advised, otherProxy.advised);\n      }\n   }\n\n   public int hashCode() {\n      return JdkDynamicAopProxy.class.hashCode() * 13 + this.advised.getTargetSource().hashCode();\n   }\n}\n"}