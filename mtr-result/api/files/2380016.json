{"id":"2380016","content":"package org.springdoc.core;\n\nimport com.fasterxml.jackson.annotation.JsonView;\nimport io.swagger.v3.core.util.PrimitiveType;\nimport io.swagger.v3.oas.annotations.Parameters;\nimport io.swagger.v3.oas.annotations.enums.ParameterIn;\nimport io.swagger.v3.oas.annotations.media.Schema;\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.OpenAPI;\nimport io.swagger.v3.oas.models.Operation;\nimport io.swagger.v3.oas.models.media.Content;\nimport io.swagger.v3.oas.models.media.MediaType;\nimport io.swagger.v3.oas.models.media.StringSchema;\nimport io.swagger.v3.oas.models.parameters.Parameter;\nimport io.swagger.v3.oas.models.parameters.RequestBody;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.security.Principal;\nimport java.time.ZoneId;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.Map.Entry;\nimport java.util.function.BiConsumer;\nimport java.util.function.BinaryOperator;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.IntFunction;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport javax.validation.constraints.DecimalMax;\nimport javax.validation.constraints.DecimalMin;\nimport javax.validation.constraints.Max;\nimport javax.validation.constraints.Min;\nimport javax.validation.constraints.Pattern;\nimport javax.validation.constraints.Size;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springdoc.core.SpringDocConfigProperties.ApiDocs.OpenApiVersion;\nimport org.springdoc.core.converters.SchemaPropertyDeprecatingConverter;\nimport org.springdoc.core.customizers.ParameterCustomizer;\nimport org.springdoc.core.providers.JavadocProvider;\nimport org.springframework.core.LocalVariableTableParameterNameDiscoverer;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.core.annotation.AnnotatedElementUtils;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.ui.Model;\nimport org.springframework.ui.ModelMap;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.validation.Errors;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestAttribute;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RequestPart;\nimport org.springframework.web.bind.support.SessionStatus;\nimport org.springframework.web.context.request.NativeWebRequest;\nimport org.springframework.web.context.request.WebRequest;\nimport org.springframework.web.method.HandlerMethod;\nimport org.springframework.web.util.UriComponentsBuilder;\n\npublic abstract class AbstractRequestService {\n   private static final List<Class<?>> PARAM_TYPES_TO_IGNORE = Collections.synchronizedList(new ArrayList());\n   private static final String[] ANNOTATIONS_FOR_REQUIRED = new String[]{\"NotNull\", \"NonNull\", \"NotBlank\", \"NotEmpty\"};\n   private static final String POSITIVE_OR_ZERO = \"PositiveOrZero\";\n   private static final String NEGATIVE_OR_ZERO = \"NegativeOrZero\";\n   private final GenericParameterService parameterBuilder;\n   private final RequestBodyService requestBodyService;\n   private final OperationService operationService;\n   private final LocalVariableTableParameterNameDiscoverer localSpringDocParameterNameDiscoverer;\n   private final Optional<List<ParameterCustomizer>> parameterCustomizers;\n   private final boolean defaultFlatParamObject;\n   private boolean defaultSupportFormData;\n\n   protected AbstractRequestService(GenericParameterService parameterBuilder, RequestBodyService requestBodyService, OperationService operationService, Optional<List<ParameterCustomizer>> parameterCustomizers, LocalVariableTableParameterNameDiscoverer localSpringDocParameterNameDiscoverer) {\n      this.parameterBuilder = parameterBuilder;\n      this.requestBodyService = requestBodyService;\n      this.operationService = operationService;\n      parameterCustomizers.ifPresent((customizers) -> {\n         customizers.removeIf(Objects::isNull);\n      });\n      this.parameterCustomizers = parameterCustomizers;\n      this.localSpringDocParameterNameDiscoverer = localSpringDocParameterNameDiscoverer;\n      this.defaultFlatParamObject = parameterBuilder.getPropertyResolverUtils().getSpringDocConfigProperties().isDefaultFlatParamObject();\n      this.defaultSupportFormData = parameterBuilder.getPropertyResolverUtils().getSpringDocConfigProperties().isDefaultSupportFormData();\n   }\n\n   public static void addRequestWrapperToIgnore(Class... classes) {\n      PARAM_TYPES_TO_IGNORE.addAll(Arrays.asList(classes));\n   }\n\n   public static void removeRequestWrapperToIgnore(Class... classes) {\n      List<Class<?>> classesToIgnore = Arrays.asList(classes);\n      if (PARAM_TYPES_TO_IGNORE.containsAll(classesToIgnore)) {\n         PARAM_TYPES_TO_IGNORE.removeAll(Arrays.asList(classes));\n      }\n\n   }\n\n   public static boolean isRequestTypeToIgnore(Class<?> rawClass) {\n      return PARAM_TYPES_TO_IGNORE.stream().anyMatch((clazz) -> {\n         return clazz.isAssignableFrom(rawClass);\n      });\n   }\n\n   public static Collection<Parameter> getHeaders(MethodAttributes methodAttributes, Map<ParameterId, Parameter> map) {\n      Parameter parameter;\n      ParameterId parameterId;\n      for(Iterator var2 = methodAttributes.getHeaders().entrySet().iterator(); var2.hasNext(); map.put(parameterId, parameter)) {\n         Entry<String, String> entry = (Entry)var2.next();\n         StringSchema schema = new StringSchema();\n         if (StringUtils.isNotEmpty((CharSequence)entry.getValue())) {\n            schema.addEnumItem((String)entry.getValue());\n         }\n\n         parameter = (new Parameter()).in(ParameterIn.HEADER.toString()).name((String)entry.getKey()).schema(schema);\n         parameterId = new ParameterId(parameter);\n         if (map.containsKey(parameterId)) {\n            parameter = (Parameter)map.get(parameterId);\n            List existingEnum = null;\n            if (parameter.getSchema() != null && !CollectionUtils.isEmpty(parameter.getSchema().getEnum())) {\n               existingEnum = parameter.getSchema().getEnum();\n            }\n\n            if (StringUtils.isNotEmpty((CharSequence)entry.getValue()) && (existingEnum == null || !existingEnum.contains(entry.getValue()))) {\n               parameter.getSchema().addEnumItemObject(entry.getValue());\n            }\n\n            parameter.setSchema(parameter.getSchema());\n         }\n      }\n\n      return map.values();\n   }\n\n   public Operation build(HandlerMethod handlerMethod, RequestMethod requestMethod, Operation operation, MethodAttributes methodAttributes, OpenAPI openAPI) {\n      String operationId = this.operationService.getOperationId(handlerMethod.getMethod().getName(), operation.getOperationId(), openAPI);\n      operation.setOperationId(operationId);\n      String[] pNames = this.localSpringDocParameterNameDiscoverer.getParameterNames(handlerMethod.getMethod());\n      MethodParameter[] parameters = handlerMethod.getMethodParameters();\n      String[] reflectionParametersNames = (String[])Arrays.stream(handlerMethod.getMethod().getParameters()).map(java.lang.reflect.Parameter::getName).toArray((x$0) -> {\n         return new String[x$0];\n      });\n      if (pNames == null || Arrays.stream(pNames).anyMatch(Objects::isNull)) {\n         pNames = reflectionParametersNames;\n      }\n\n      parameters = DelegatingMethodParameter.customize(pNames, parameters, this.parameterBuilder.getDelegatingMethodParameterCustomizer(), this.defaultFlatParamObject);\n      RequestBodyInfo requestBodyInfo = new RequestBodyInfo();\n      List<Parameter> operationParameters = operation.getParameters() != null ? operation.getParameters() : new ArrayList();\n      Map<ParameterId, io.swagger.v3.oas.annotations.Parameter> parametersDocMap = this.getApiParameters(handlerMethod.getMethod());\n      Components components = openAPI.getComponents();\n      JavadocProvider javadocProvider = this.parameterBuilder.getJavadocProvider();\n      MethodParameter[] var15 = parameters;\n      int var16 = parameters.length;\n\n      Parameter parameter;\n      for(int var17 = 0; var17 < var16; ++var17) {\n         MethodParameter methodParameter = var15[var17];\n         io.swagger.v3.oas.annotations.Parameter parameterDoc = (io.swagger.v3.oas.annotations.Parameter)AnnotatedElementUtils.findMergedAnnotation(AnnotatedElementUtils.forAnnotations(methodParameter.getParameterAnnotations()), io.swagger.v3.oas.annotations.Parameter.class);\n         String pName = methodParameter.getParameterName();\n         ParameterInfo parameterInfo = new ParameterInfo(pName, methodParameter, this.parameterBuilder, parameterDoc);\n         if (parameterDoc == null) {\n            parameterDoc = (io.swagger.v3.oas.annotations.Parameter)parametersDocMap.get(parameterInfo.getParameterId());\n         }\n\n         if (parameterDoc == null) {\n            Schema schema = (Schema)AnnotatedElementUtils.findMergedAnnotation(AnnotatedElementUtils.forAnnotations(methodParameter.getParameterAnnotations()), Schema.class);\n            if (schema != null) {\n               parameterDoc = this.parameterBuilder.generateParameterBySchema(schema);\n            }\n         }\n\n         if (parameterDoc != null) {\n            if (parameterDoc.hidden() || parameterDoc.schema().hidden()) {\n               continue;\n            }\n\n            parameter = this.parameterBuilder.buildParameterFromDoc(parameterDoc, components, methodAttributes.getJsonViewAnnotation(), methodAttributes.getLocale());\n            parameterInfo.setParameterModel(parameter);\n         }\n\n         if (!this.isParamToIgnore(methodParameter)) {\n            parameter = this.buildParams(parameterInfo, components, requestMethod, methodAttributes.getJsonViewAnnotation(), openAPI.getOpenapi());\n            parameter = GenericParameterService.mergeParameter((List)operationParameters, parameter);\n            List<Annotation> parameterAnnotations = Arrays.asList(methodParameter.getParameterAnnotations());\n            if (this.isValidParameter(parameter)) {\n               if (StringUtils.isBlank(parameter.getDescription()) && javadocProvider != null) {\n                  String paramJavadocDescription = this.parameterBuilder.getParamJavadoc(javadocProvider, methodParameter);\n                  if (!StringUtils.isBlank(paramJavadocDescription)) {\n                     parameter.setDescription(paramJavadocDescription);\n                  }\n               }\n\n               this.applyBeanValidatorAnnotations(parameter, parameterAnnotations);\n            } else if (!RequestMethod.GET.equals(requestMethod) || OpenApiVersion.OPENAPI_3_1.getVersion().equals(openAPI.getOpenapi())) {\n               if (operation.getRequestBody() != null) {\n                  requestBodyInfo.setRequestBody(operation.getRequestBody());\n               }\n\n               this.requestBodyService.calculateRequestBodyInfo(components, methodAttributes, parameterInfo, requestBodyInfo);\n               this.applyBeanValidatorAnnotations(requestBodyInfo.getRequestBody(), parameterAnnotations, methodParameter.isOptional());\n            }\n\n            this.customiseParameter(parameter, parameterInfo, (List)operationParameters);\n         }\n      }\n\n      LinkedHashMap<ParameterId, Parameter> map = this.getParameterLinkedHashMap(components, methodAttributes, (List)operationParameters, parametersDocMap);\n      RequestBody requestBody = requestBodyInfo.getRequestBody();\n      if (this.defaultSupportFormData && requestBody != null && requestBody.getContent() != null && requestBody.getContent().containsKey(\"multipart/form-data\")) {\n         Iterator it = map.entrySet().iterator();\n\n         while(it.hasNext()) {\n            Entry<ParameterId, Parameter> entry = (Entry)it.next();\n            parameter = (Parameter)entry.getValue();\n            if (!ParameterIn.PATH.toString().equals(parameter.getIn()) && !ParameterIn.HEADER.toString().equals(parameter.getIn()) && !ParameterIn.COOKIE.toString().equals(parameter.getIn())) {\n               io.swagger.v3.oas.models.media.Schema<?> itemSchema = new io.swagger.v3.oas.models.media.Schema();\n               itemSchema.setName(((ParameterId)entry.getKey()).getpName());\n               itemSchema.setDescription(parameter.getDescription());\n               itemSchema.setDeprecated(parameter.getDeprecated());\n               if (parameter.getExample() != null) {\n                  itemSchema.setExample(parameter.getExample());\n               }\n\n               requestBodyInfo.addProperties(((ParameterId)entry.getKey()).getpName(), itemSchema);\n               it.remove();\n            }\n         }\n      }\n\n      this.setParams(operation, new ArrayList(map.values()), requestBodyInfo);\n      return operation;\n   }\n\n   private LinkedHashMap<ParameterId, Parameter> getParameterLinkedHashMap(Components components, MethodAttributes methodAttributes, List<Parameter> operationParameters, Map<ParameterId, io.swagger.v3.oas.annotations.Parameter> parametersDocMap) {\n      LinkedHashMap<ParameterId, Parameter> map = (LinkedHashMap)operationParameters.stream().collect(Collectors.toMap(ParameterId::new, (parameterx) -> {\n         return parameterx;\n      }, (u, v) -> {\n         throw new IllegalStateException(String.format(\"Duplicate key %s\", u));\n      }, LinkedHashMap::new));\n      Iterator var6 = parametersDocMap.entrySet().iterator();\n\n      while(true) {\n         while(true) {\n            Entry entry;\n            ParameterId parameterId;\n            do {\n               do {\n                  do {\n                     if (!var6.hasNext()) {\n                        getHeaders(methodAttributes, map);\n                        map.forEach((parameterIdx, parameterx) -> {\n                           if (StringUtils.isBlank(parameterx.getIn()) && StringUtils.isBlank(parameterx.get$ref())) {\n                              parameterx.setIn(ParameterIn.QUERY.toString());\n                           }\n\n                        });\n                        return map;\n                     }\n\n                     entry = (Entry)var6.next();\n                     parameterId = (ParameterId)entry.getKey();\n                  } while(parameterId == null);\n               } while(map.containsKey(parameterId));\n            } while(((io.swagger.v3.oas.annotations.Parameter)entry.getValue()).hidden());\n\n            Parameter parameter = this.parameterBuilder.buildParameterFromDoc((io.swagger.v3.oas.annotations.Parameter)entry.getValue(), components, methodAttributes.getJsonViewAnnotation(), methodAttributes.getLocale());\n            if (map.containsKey(parameterId)) {\n               GenericParameterService.mergeParameter((Parameter)map.get(parameterId), parameter);\n               map.put(parameterId, parameter);\n            } else {\n               long mumParamsWithName = map.keySet().stream().filter((parameterId1) -> {\n                  return parameterId.getpName().equals(parameterId1.getpName());\n               }).count();\n               long mumParamsDocWithName = parametersDocMap.keySet().stream().filter((parameterId1) -> {\n                  return parameterId.getpName().equals(parameterId1.getpName());\n               }).count();\n               if (mumParamsWithName == 1L && mumParamsDocWithName == 1L) {\n                  Optional<ParameterId> parameterIdWithSameNameOptional = map.keySet().stream().filter((parameterId1) -> {\n                     return parameterId.getpName().equals(parameterId1.getpName());\n                  }).findAny();\n                  parameterIdWithSameNameOptional.ifPresent((parameterIdWithSameName) -> {\n                     GenericParameterService.mergeParameter((Parameter)map.get(parameterIdWithSameName), parameter);\n                     map.put(parameterIdWithSameName, parameter);\n                  });\n               } else {\n                  map.put(parameterId, parameter);\n               }\n            }\n         }\n      }\n   }\n\n   protected void customiseParameter(Parameter parameter, ParameterInfo parameterInfo, List<Parameter> operationParameters) {\n      if (this.parameterCustomizers.isPresent()) {\n         List<ParameterCustomizer> parameterCustomizerList = (List)this.parameterCustomizers.get();\n         int index = operationParameters.indexOf(parameter);\n\n         ParameterCustomizer parameterCustomizer;\n         for(Iterator var6 = parameterCustomizerList.iterator(); var6.hasNext(); parameter = parameterCustomizer.customize(parameter, parameterInfo.getMethodParameter())) {\n            parameterCustomizer = (ParameterCustomizer)var6.next();\n         }\n\n         if (index != -1) {\n            operationParameters.set(index, parameter);\n         }\n      }\n\n   }\n\n   public boolean isParamToIgnore(MethodParameter parameter) {\n      if (SpringDocAnnotationsUtils.isAnnotationToIgnore(parameter)) {\n         return true;\n      } else {\n         return this.isRequiredAnnotation(parameter) ? false : isRequestTypeToIgnore(parameter.getParameterType());\n      }\n   }\n\n   private boolean isRequiredAnnotation(MethodParameter parameter) {\n      RequestParam requestParam = (RequestParam)parameter.getParameterAnnotation(RequestParam.class);\n      PathVariable pathVariable = (PathVariable)parameter.getParameterAnnotation(PathVariable.class);\n      org.springframework.web.bind.annotation.RequestBody requestBody = (org.springframework.web.bind.annotation.RequestBody)parameter.getParameterAnnotation(org.springframework.web.bind.annotation.RequestBody.class);\n      return requestParam != null && requestParam.required() || pathVariable != null && pathVariable.required() || requestBody != null && requestBody.required();\n   }\n\n   private void setParams(Operation operation, List<Parameter> operationParameters, RequestBodyInfo requestBodyInfo) {\n      if (!CollectionUtils.isEmpty(operationParameters)) {\n         operation.setParameters(operationParameters);\n      }\n\n      if (requestBodyInfo.getRequestBody() != null) {\n         operation.setRequestBody(requestBodyInfo.getRequestBody());\n      }\n\n   }\n\n   public boolean isValidParameter(Parameter parameter) {\n      return parameter != null && (parameter.getName() != null || parameter.get$ref() != null);\n   }\n\n   public Parameter buildParams(ParameterInfo parameterInfo, Components components, RequestMethod requestMethod, JsonView jsonView, String openApiVersion) {\n      MethodParameter methodParameter = parameterInfo.getMethodParameter();\n      if (parameterInfo.getParamType() != null) {\n         if (!\"\\n\\t\\t\\n\\t\\t\\n\\ue000\\ue001\\ue002\\n\\t\\t\\t\\t\\n\".equals(parameterInfo.getDefaultValue())) {\n            parameterInfo.setRequired(false);\n         } else {\n            parameterInfo.setDefaultValue((Object)null);\n         }\n\n         return this.buildParam(parameterInfo, components, jsonView);\n      } else if (this.isRequestBodyParam(requestMethod, parameterInfo, openApiVersion)) {\n         return null;\n      } else {\n         parameterInfo.setRequired(!((DelegatingMethodParameter)methodParameter).isNotRequired() && !methodParameter.isOptional());\n         parameterInfo.setDefaultValue((Object)null);\n         return this.buildParam(parameterInfo, components, jsonView);\n      }\n   }\n\n   public Parameter buildParam(ParameterInfo parameterInfo, Components components, JsonView jsonView) {\n      Parameter parameter = parameterInfo.getParameterModel();\n      String name = parameterInfo.getpName();\n      if (parameter == null) {\n         parameter = new Parameter();\n         parameterInfo.setParameterModel(parameter);\n      }\n\n      if (StringUtils.isBlank(parameter.getName())) {\n         parameter.setName(name);\n      }\n\n      if (StringUtils.isBlank(parameter.getIn())) {\n         parameter.setIn(parameterInfo.getParamType());\n      }\n\n      if (parameter.getRequired() == null) {\n         parameter.setRequired(parameterInfo.isRequired());\n      }\n\n      if (SchemaPropertyDeprecatingConverter.containsDeprecatedAnnotation(parameterInfo.getMethodParameter().getParameterAnnotations())) {\n         parameter.setDeprecated(true);\n      }\n\n      if (parameter.getSchema() == null && parameter.getContent() == null) {\n         io.swagger.v3.oas.models.media.Schema<?> schema = this.parameterBuilder.calculateSchema(components, parameterInfo, (RequestBodyInfo)null, jsonView);\n         if (parameterInfo.getDefaultValue() != null && schema != null) {\n            Object defaultValue = parameterInfo.getDefaultValue();\n            PrimitiveType primitiveType = PrimitiveType.fromTypeAndFormat(schema.getType(), schema.getFormat());\n            if (primitiveType != null) {\n               io.swagger.v3.oas.models.media.Schema<?> primitiveSchema = primitiveType.createProperty();\n               primitiveSchema.setDefault(parameterInfo.getDefaultValue());\n               defaultValue = primitiveSchema.getDefault();\n            }\n\n            schema.setDefault(defaultValue);\n         }\n\n         parameter.setSchema(schema);\n      }\n\n      return parameter;\n   }\n\n   public void applyBeanValidatorAnnotations(Parameter parameter, List<Annotation> annotations) {\n      Map<String, Annotation> annos = new HashMap();\n      if (annotations != null) {\n         annotations.forEach((annotation) -> {\n            Annotation var10000 = (Annotation)annos.put(annotation.annotationType().getSimpleName(), annotation);\n         });\n      }\n\n      Stream var10000 = Arrays.stream(ANNOTATIONS_FOR_REQUIRED);\n      annos.getClass();\n      boolean annotationExists = var10000.anyMatch(annos::containsKey);\n      if (annotationExists) {\n         parameter.setRequired(true);\n      }\n\n      io.swagger.v3.oas.models.media.Schema<?> schema = parameter.getSchema();\n      this.applyValidationsToSchema(annos, schema);\n   }\n\n   public void applyBeanValidatorAnnotations(RequestBody requestBody, List<Annotation> annotations, boolean isOptional) {\n      Map<String, Annotation> annos = new HashMap();\n      boolean requestBodyRequired = false;\n      if (!CollectionUtils.isEmpty(annotations)) {\n         annotations.forEach((annotation) -> {\n            Annotation var10000 = (Annotation)annos.put(annotation.annotationType().getSimpleName(), annotation);\n         });\n         requestBodyRequired = annotations.stream().filter((annotation) -> {\n            return org.springframework.web.bind.annotation.RequestBody.class.equals(annotation.annotationType());\n         }).anyMatch((annotation) -> {\n            return ((org.springframework.web.bind.annotation.RequestBody)annotation).required();\n         });\n      }\n\n      Stream var10000 = Arrays.stream(ANNOTATIONS_FOR_REQUIRED);\n      annos.getClass();\n      boolean validationExists = var10000.anyMatch(annos::containsKey);\n      if (validationExists || !isOptional && requestBodyRequired) {\n         requestBody.setRequired(true);\n      }\n\n      Content content = requestBody.getContent();\n      Iterator var8 = content.values().iterator();\n\n      while(var8.hasNext()) {\n         MediaType mediaType = (MediaType)var8.next();\n         io.swagger.v3.oas.models.media.Schema<?> schema = mediaType.getSchema();\n         this.applyValidationsToSchema(annos, schema);\n      }\n\n   }\n\n   public RequestBodyService getRequestBodyBuilder() {\n      return this.requestBodyService;\n   }\n\n   public boolean isDefaultFlatParamObject() {\n      return this.defaultFlatParamObject;\n   }\n\n   private void calculateSize(Map<String, Annotation> annos, io.swagger.v3.oas.models.media.Schema<?> schema) {\n      if (annos.containsKey(Size.class.getSimpleName())) {\n         Size size = (Size)annos.get(Size.class.getSimpleName());\n         if (\"array\".equals(schema.getType())) {\n            schema.setMinItems(size.min());\n            schema.setMaxItems(size.max());\n         } else if (\"string\".equals(schema.getType())) {\n            schema.setMinLength(size.min());\n            schema.setMaxLength(size.max());\n         }\n      }\n\n   }\n\n   private Map<ParameterId, io.swagger.v3.oas.annotations.Parameter> getApiParameters(Method method) {\n      Class<?> declaringClass = method.getDeclaringClass();\n      Set<Parameters> apiParametersDoc = AnnotatedElementUtils.findAllMergedAnnotations(method, Parameters.class);\n      LinkedHashMap<ParameterId, io.swagger.v3.oas.annotations.Parameter> apiParametersMap = (LinkedHashMap)apiParametersDoc.stream().flatMap((x) -> {\n         return Stream.of(x.value());\n      }).collect(Collectors.toMap(ParameterId::new, (x) -> {\n         return x;\n      }, (e1, e2) -> {\n         return e2;\n      }, LinkedHashMap::new));\n      Set<Parameters> apiParametersDocDeclaringClass = AnnotatedElementUtils.findAllMergedAnnotations(declaringClass, Parameters.class);\n      LinkedHashMap<ParameterId, io.swagger.v3.oas.annotations.Parameter> apiParametersDocDeclaringClassMap = (LinkedHashMap)apiParametersDocDeclaringClass.stream().flatMap((x) -> {\n         return Stream.of(x.value());\n      }).collect(Collectors.toMap(ParameterId::new, (x) -> {\n         return x;\n      }, (e1, e2) -> {\n         return e2;\n      }, LinkedHashMap::new));\n      apiParametersMap.putAll(apiParametersDocDeclaringClassMap);\n      Set<io.swagger.v3.oas.annotations.Parameter> apiParameterDoc = AnnotatedElementUtils.findAllMergedAnnotations(method, io.swagger.v3.oas.annotations.Parameter.class);\n      LinkedHashMap<ParameterId, io.swagger.v3.oas.annotations.Parameter> apiParameterDocMap = (LinkedHashMap)apiParameterDoc.stream().collect(Collectors.toMap(ParameterId::new, (x) -> {\n         return x;\n      }, (e1, e2) -> {\n         return e2;\n      }, LinkedHashMap::new));\n      apiParametersMap.putAll(apiParameterDocMap);\n      Set<io.swagger.v3.oas.annotations.Parameter> apiParameterDocDeclaringClass = AnnotatedElementUtils.findAllMergedAnnotations(declaringClass, io.swagger.v3.oas.annotations.Parameter.class);\n      LinkedHashMap<ParameterId, io.swagger.v3.oas.annotations.Parameter> apiParameterDocDeclaringClassMap = (LinkedHashMap)apiParameterDocDeclaringClass.stream().collect(Collectors.toMap(ParameterId::new, (x) -> {\n         return x;\n      }, (e1, e2) -> {\n         return e2;\n      }, LinkedHashMap::new));\n      apiParametersMap.putAll(apiParameterDocDeclaringClassMap);\n      return apiParametersMap;\n   }\n\n   private void applyValidationsToSchema(Map<String, Annotation> annos, io.swagger.v3.oas.models.media.Schema<?> schema) {\n      if (annos.containsKey(Min.class.getSimpleName())) {\n         Min min = (Min)annos.get(Min.class.getSimpleName());\n         schema.setMinimum(BigDecimal.valueOf(min.value()));\n      }\n\n      if (annos.containsKey(Max.class.getSimpleName())) {\n         Max max = (Max)annos.get(Max.class.getSimpleName());\n         schema.setMaximum(BigDecimal.valueOf(max.value()));\n      }\n\n      this.calculateSize(annos, schema);\n      if (annos.containsKey(DecimalMin.class.getSimpleName())) {\n         DecimalMin min = (DecimalMin)annos.get(DecimalMin.class.getSimpleName());\n         if (min.inclusive()) {\n            schema.setMinimum(BigDecimal.valueOf(Double.parseDouble(min.value())));\n         } else {\n            schema.setExclusiveMinimum(true);\n         }\n      }\n\n      if (annos.containsKey(DecimalMax.class.getSimpleName())) {\n         DecimalMax max = (DecimalMax)annos.get(DecimalMax.class.getSimpleName());\n         if (max.inclusive()) {\n            schema.setMaximum(BigDecimal.valueOf(Double.parseDouble(max.value())));\n         } else {\n            schema.setExclusiveMaximum(true);\n         }\n      }\n\n      if (annos.containsKey(\"PositiveOrZero\")) {\n         schema.setMinimum(BigDecimal.ZERO);\n      }\n\n      if (annos.containsKey(\"NegativeOrZero\")) {\n         schema.setMaximum(BigDecimal.ZERO);\n      }\n\n      if (annos.containsKey(Pattern.class.getSimpleName())) {\n         Pattern pattern = (Pattern)annos.get(Pattern.class.getSimpleName());\n         schema.setPattern(pattern.regexp());\n      }\n\n   }\n\n   private boolean isRequestBodyParam(RequestMethod requestMethod, ParameterInfo parameterInfo, String openApiVersion) {\n      MethodParameter methodParameter = parameterInfo.getMethodParameter();\n      DelegatingMethodParameter delegatingMethodParameter = (DelegatingMethodParameter)methodParameter;\n      boolean isBodyAllowed = !RequestMethod.GET.equals(requestMethod) || OpenApiVersion.OPENAPI_3_1.getVersion().equals(openApiVersion);\n      return isBodyAllowed && (parameterInfo.getParameterModel() == null || parameterInfo.getParameterModel().getIn() == null) && !delegatingMethodParameter.isParameterObject() && (methodParameter.getParameterAnnotation(io.swagger.v3.oas.annotations.parameters.RequestBody.class) != null || methodParameter.getParameterAnnotation(org.springframework.web.bind.annotation.RequestBody.class) != null || AnnotatedElementUtils.findMergedAnnotation((AnnotatedElement)Objects.requireNonNull(methodParameter.getMethod()), io.swagger.v3.oas.annotations.parameters.RequestBody.class) != null || this.checkOperationRequestBody(methodParameter) || this.checkFile(methodParameter));\n   }\n\n   private boolean checkFile(MethodParameter methodParameter) {\n      if (methodParameter.getParameterAnnotation(RequestPart.class) != null) {\n         return true;\n      } else {\n         return methodParameter.getParameterAnnotation(RequestParam.class) != null ? GenericParameterService.isFile(methodParameter.getParameterType()) : false;\n      }\n   }\n\n   private boolean checkOperationRequestBody(MethodParameter methodParameter) {\n      if (AnnotatedElementUtils.findMergedAnnotation((AnnotatedElement)Objects.requireNonNull(methodParameter.getMethod()), io.swagger.v3.oas.annotations.Operation.class) != null) {\n         io.swagger.v3.oas.annotations.Operation operation = (io.swagger.v3.oas.annotations.Operation)AnnotatedElementUtils.findMergedAnnotation((AnnotatedElement)Objects.requireNonNull(methodParameter.getMethod()), io.swagger.v3.oas.annotations.Operation.class);\n         io.swagger.v3.oas.annotations.parameters.RequestBody requestBody = operation.requestBody();\n         if (StringUtils.isNotBlank(requestBody.description())) {\n            return true;\n         } else if (StringUtils.isNotBlank(requestBody.ref())) {\n            return true;\n         } else if (requestBody.required()) {\n            return true;\n         } else if (requestBody.useParameterTypeSchema()) {\n            return true;\n         } else if (requestBody.content().length > 0) {\n            return true;\n         } else {\n            return requestBody.extensions().length > 0;\n         }\n      } else {\n         return false;\n      }\n   }\n\n   static {\n      PARAM_TYPES_TO_IGNORE.add(WebRequest.class);\n      PARAM_TYPES_TO_IGNORE.add(NativeWebRequest.class);\n      PARAM_TYPES_TO_IGNORE.add(Principal.class);\n      PARAM_TYPES_TO_IGNORE.add(HttpMethod.class);\n      PARAM_TYPES_TO_IGNORE.add(Locale.class);\n      PARAM_TYPES_TO_IGNORE.add(TimeZone.class);\n      PARAM_TYPES_TO_IGNORE.add(InputStream.class);\n      PARAM_TYPES_TO_IGNORE.add(ZoneId.class);\n      PARAM_TYPES_TO_IGNORE.add(Reader.class);\n      PARAM_TYPES_TO_IGNORE.add(OutputStream.class);\n      PARAM_TYPES_TO_IGNORE.add(Writer.class);\n      PARAM_TYPES_TO_IGNORE.add(Map.class);\n      PARAM_TYPES_TO_IGNORE.add(Model.class);\n      PARAM_TYPES_TO_IGNORE.add(ModelMap.class);\n      PARAM_TYPES_TO_IGNORE.add(Errors.class);\n      PARAM_TYPES_TO_IGNORE.add(BindingResult.class);\n      PARAM_TYPES_TO_IGNORE.add(SessionStatus.class);\n      PARAM_TYPES_TO_IGNORE.add(UriComponentsBuilder.class);\n      PARAM_TYPES_TO_IGNORE.add(RequestAttribute.class);\n   }\n}\n"}