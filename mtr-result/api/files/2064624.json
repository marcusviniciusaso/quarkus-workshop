{"id":"2064624","content":"package org.springframework.aop.framework;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.aopalliance.aop.Advice;\nimport org.aopalliance.intercept.Interceptor;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.aop.Advisor;\nimport org.springframework.aop.TargetSource;\nimport org.springframework.aop.framework.adapter.AdvisorAdapterRegistry;\nimport org.springframework.aop.framework.adapter.GlobalAdvisorAdapterRegistry;\nimport org.springframework.aop.framework.adapter.UnknownAdviceTypeException;\nimport org.springframework.aop.target.SingletonTargetSource;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanClassLoaderAware;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.FactoryBeanNotInitializedException;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ObjectUtils;\n\npublic class ProxyFactoryBean extends ProxyCreatorSupport implements FactoryBean<Object>, BeanClassLoaderAware, BeanFactoryAware {\n   public static final String GLOBAL_SUFFIX = \"*\";\n   protected final Log logger = LogFactory.getLog(this.getClass());\n   @Nullable\n   private String[] interceptorNames;\n   @Nullable\n   private String targetName;\n   private boolean autodetectInterfaces = true;\n   private boolean singleton = true;\n   private AdvisorAdapterRegistry advisorAdapterRegistry = GlobalAdvisorAdapterRegistry.getInstance();\n   private boolean freezeProxy = false;\n   @Nullable\n   private transient ClassLoader proxyClassLoader = ClassUtils.getDefaultClassLoader();\n   private transient boolean classLoaderConfigured = false;\n   @Nullable\n   private transient BeanFactory beanFactory;\n   private boolean advisorChainInitialized = false;\n   @Nullable\n   private Object singletonInstance;\n\n   public void setProxyInterfaces(Class<?>[] proxyInterfaces) throws ClassNotFoundException {\n      this.setInterfaces(proxyInterfaces);\n   }\n\n   public void setInterceptorNames(String... interceptorNames) {\n      this.interceptorNames = interceptorNames;\n   }\n\n   public void setTargetName(String targetName) {\n      this.targetName = targetName;\n   }\n\n   public void setAutodetectInterfaces(boolean autodetectInterfaces) {\n      this.autodetectInterfaces = autodetectInterfaces;\n   }\n\n   public void setSingleton(boolean singleton) {\n      this.singleton = singleton;\n   }\n\n   public void setAdvisorAdapterRegistry(AdvisorAdapterRegistry advisorAdapterRegistry) {\n      this.advisorAdapterRegistry = advisorAdapterRegistry;\n   }\n\n   public void setFrozen(boolean frozen) {\n      this.freezeProxy = frozen;\n   }\n\n   public void setProxyClassLoader(@Nullable ClassLoader classLoader) {\n      this.proxyClassLoader = classLoader;\n      this.classLoaderConfigured = classLoader != null;\n   }\n\n   public void setBeanClassLoader(ClassLoader classLoader) {\n      if (!this.classLoaderConfigured) {\n         this.proxyClassLoader = classLoader;\n      }\n\n   }\n\n   public void setBeanFactory(BeanFactory beanFactory) {\n      this.beanFactory = beanFactory;\n      this.checkInterceptorNames();\n   }\n\n   @Nullable\n   public Object getObject() throws BeansException {\n      this.initializeAdvisorChain();\n      if (this.isSingleton()) {\n         return this.getSingletonInstance();\n      } else {\n         if (this.targetName == null) {\n            this.logger.info(\"Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the 'targetName' property.\");\n         }\n\n         return this.newPrototypeInstance();\n      }\n   }\n\n   public Class<?> getObjectType() {\n      synchronized(this) {\n         if (this.singletonInstance != null) {\n            return this.singletonInstance.getClass();\n         }\n      }\n\n      Class<?>[] ifcs = this.getProxiedInterfaces();\n      if (ifcs.length == 1) {\n         return ifcs[0];\n      } else if (ifcs.length > 1) {\n         return this.createCompositeInterface(ifcs);\n      } else {\n         return this.targetName != null && this.beanFactory != null ? this.beanFactory.getType(this.targetName) : this.getTargetClass();\n      }\n   }\n\n   public boolean isSingleton() {\n      return this.singleton;\n   }\n\n   protected Class<?> createCompositeInterface(Class<?>[] interfaces) {\n      return ClassUtils.createCompositeInterface(interfaces, this.proxyClassLoader);\n   }\n\n   private synchronized Object getSingletonInstance() {\n      if (this.singletonInstance == null) {\n         this.targetSource = this.freshTargetSource();\n         if (this.autodetectInterfaces && this.getProxiedInterfaces().length == 0 && !this.isProxyTargetClass()) {\n            Class<?> targetClass = this.getTargetClass();\n            if (targetClass == null) {\n               throw new FactoryBeanNotInitializedException(\"Cannot determine target class for proxy\");\n            }\n\n            this.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));\n         }\n\n         super.setFrozen(this.freezeProxy);\n         this.singletonInstance = this.getProxy(this.createAopProxy());\n      }\n\n      return this.singletonInstance;\n   }\n\n   private synchronized Object newPrototypeInstance() {\n      ProxyCreatorSupport copy = new ProxyCreatorSupport(this.getAopProxyFactory());\n      TargetSource targetSource = this.freshTargetSource();\n      copy.copyConfigurationFrom(this, targetSource, this.freshAdvisorChain());\n      if (this.autodetectInterfaces && this.getProxiedInterfaces().length == 0 && !this.isProxyTargetClass()) {\n         Class<?> targetClass = targetSource.getTargetClass();\n         if (targetClass != null) {\n            copy.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));\n         }\n      }\n\n      copy.setFrozen(this.freezeProxy);\n      return this.getProxy(copy.createAopProxy());\n   }\n\n   protected Object getProxy(AopProxy aopProxy) {\n      return aopProxy.getProxy(this.proxyClassLoader);\n   }\n\n   private void checkInterceptorNames() {\n      if (!ObjectUtils.isEmpty(this.interceptorNames)) {\n         String finalName = this.interceptorNames[this.interceptorNames.length - 1];\n         if (this.targetName == null && this.targetSource == EMPTY_TARGET_SOURCE && !finalName.endsWith(\"*\") && !this.isNamedBeanAnAdvisorOrAdvice(finalName)) {\n            this.targetName = finalName;\n            if (this.logger.isDebugEnabled()) {\n               this.logger.debug(\"Bean with name '\" + finalName + \"' concluding interceptor chain is not an advisor class: treating it as a target or TargetSource\");\n            }\n\n            this.interceptorNames = (String[])Arrays.copyOf(this.interceptorNames, this.interceptorNames.length - 1);\n         }\n      }\n\n   }\n\n   private boolean isNamedBeanAnAdvisorOrAdvice(String beanName) {\n      Assert.state(this.beanFactory != null, \"No BeanFactory set\");\n      Class<?> namedBeanClass = this.beanFactory.getType(beanName);\n      if (namedBeanClass == null) {\n         if (this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Could not determine type of bean with name '\" + beanName + \"' - assuming it is neither an Advisor nor an Advice\");\n         }\n\n         return false;\n      } else {\n         return Advisor.class.isAssignableFrom(namedBeanClass) || Advice.class.isAssignableFrom(namedBeanClass);\n      }\n   }\n\n   private synchronized void initializeAdvisorChain() throws AopConfigException, BeansException {\n      if (!this.advisorChainInitialized && !ObjectUtils.isEmpty(this.interceptorNames)) {\n         if (this.beanFactory == null) {\n            throw new IllegalStateException(\"No BeanFactory available anymore (probably due to serialization) - cannot resolve interceptor names \" + Arrays.toString(this.interceptorNames));\n         }\n\n         if (this.interceptorNames[this.interceptorNames.length - 1].endsWith(\"*\") && this.targetName == null && this.targetSource == EMPTY_TARGET_SOURCE) {\n            throw new AopConfigException(\"Target required after globals\");\n         }\n\n         String[] var1 = this.interceptorNames;\n         int var2 = var1.length;\n\n         for(int var3 = 0; var3 < var2; ++var3) {\n            String name = var1[var3];\n            if (name.endsWith(\"*\")) {\n               if (!(this.beanFactory instanceof ListableBeanFactory)) {\n                  throw new AopConfigException(\"Can only use global advisors or interceptors with a ListableBeanFactory\");\n               }\n\n               this.addGlobalAdvisors((ListableBeanFactory)this.beanFactory, name.substring(0, name.length() - \"*\".length()));\n            } else {\n               Object advice;\n               if (!this.singleton && !this.beanFactory.isSingleton(name)) {\n                  advice = new ProxyFactoryBean.PrototypePlaceholderAdvisor(name);\n               } else {\n                  advice = this.beanFactory.getBean(name);\n               }\n\n               this.addAdvisorOnChainCreation(advice);\n            }\n         }\n\n         this.advisorChainInitialized = true;\n      }\n\n   }\n\n   private List<Advisor> freshAdvisorChain() {\n      Advisor[] advisors = this.getAdvisors();\n      List<Advisor> freshAdvisors = new ArrayList(advisors.length);\n      Advisor[] var3 = advisors;\n      int var4 = advisors.length;\n\n      for(int var5 = 0; var5 < var4; ++var5) {\n         Advisor advisor = var3[var5];\n         if (advisor instanceof ProxyFactoryBean.PrototypePlaceholderAdvisor) {\n            ProxyFactoryBean.PrototypePlaceholderAdvisor pa = (ProxyFactoryBean.PrototypePlaceholderAdvisor)advisor;\n            if (this.logger.isDebugEnabled()) {\n               this.logger.debug(\"Refreshing bean named '\" + pa.getBeanName() + \"'\");\n            }\n\n            if (this.beanFactory == null) {\n               throw new IllegalStateException(\"No BeanFactory available anymore (probably due to serialization) - cannot resolve prototype advisor '\" + pa.getBeanName() + \"'\");\n            }\n\n            Object bean = this.beanFactory.getBean(pa.getBeanName());\n            Advisor refreshedAdvisor = this.namedBeanToAdvisor(bean);\n            freshAdvisors.add(refreshedAdvisor);\n         } else {\n            freshAdvisors.add(advisor);\n         }\n      }\n\n      return freshAdvisors;\n   }\n\n   private void addGlobalAdvisors(ListableBeanFactory beanFactory, String prefix) {\n      String[] globalAdvisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, Advisor.class);\n      String[] globalInterceptorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, Interceptor.class);\n      if (globalAdvisorNames.length > 0 || globalInterceptorNames.length > 0) {\n         List<Object> beans = new ArrayList(globalAdvisorNames.length + globalInterceptorNames.length);\n         String[] var6 = globalAdvisorNames;\n         int var7 = globalAdvisorNames.length;\n\n         int var8;\n         String name;\n         for(var8 = 0; var8 < var7; ++var8) {\n            name = var6[var8];\n            if (name.startsWith(prefix)) {\n               beans.add(beanFactory.getBean(name));\n            }\n         }\n\n         var6 = globalInterceptorNames;\n         var7 = globalInterceptorNames.length;\n\n         for(var8 = 0; var8 < var7; ++var8) {\n            name = var6[var8];\n            if (name.startsWith(prefix)) {\n               beans.add(beanFactory.getBean(name));\n            }\n         }\n\n         AnnotationAwareOrderComparator.sort(beans);\n         Iterator var10 = beans.iterator();\n\n         while(var10.hasNext()) {\n            Object bean = var10.next();\n            this.addAdvisorOnChainCreation(bean);\n         }\n      }\n\n   }\n\n   private void addAdvisorOnChainCreation(Object next) {\n      this.addAdvisor(this.namedBeanToAdvisor(next));\n   }\n\n   private TargetSource freshTargetSource() {\n      if (this.targetName == null) {\n         return this.targetSource;\n      } else if (this.beanFactory == null) {\n         throw new IllegalStateException(\"No BeanFactory available anymore (probably due to serialization) - cannot resolve target with name '\" + this.targetName + \"'\");\n      } else {\n         if (this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Refreshing target with name '\" + this.targetName + \"'\");\n         }\n\n         Object target = this.beanFactory.getBean(this.targetName);\n         return (TargetSource)(target instanceof TargetSource ? (TargetSource)target : new SingletonTargetSource(target));\n      }\n   }\n\n   private Advisor namedBeanToAdvisor(Object next) {\n      try {\n         return this.advisorAdapterRegistry.wrap(next);\n      } catch (UnknownAdviceTypeException var3) {\n         throw new AopConfigException(\"Unknown advisor type \" + next.getClass() + \"; can only include Advisor or Advice type beans in interceptorNames chain except for last entry which may also be target instance or TargetSource\", var3);\n      }\n   }\n\n   protected void adviceChanged() {\n      super.adviceChanged();\n      if (this.singleton) {\n         this.logger.debug(\"Advice has changed; re-caching singleton instance\");\n         synchronized(this) {\n            this.singletonInstance = null;\n         }\n      }\n\n   }\n\n   private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n      ois.defaultReadObject();\n      this.proxyClassLoader = ClassUtils.getDefaultClassLoader();\n   }\n\n   private static class PrototypePlaceholderAdvisor implements Advisor, Serializable {\n      private final String beanName;\n      private final String message;\n\n      public PrototypePlaceholderAdvisor(String beanName) {\n         this.beanName = beanName;\n         this.message = \"Placeholder for prototype Advisor/Advice with bean name '\" + beanName + \"'\";\n      }\n\n      public String getBeanName() {\n         return this.beanName;\n      }\n\n      public Advice getAdvice() {\n         throw new UnsupportedOperationException(\"Cannot invoke methods: \" + this.message);\n      }\n\n      public boolean isPerInstance() {\n         throw new UnsupportedOperationException(\"Cannot invoke methods: \" + this.message);\n      }\n\n      public String toString() {\n         return this.message;\n      }\n   }\n}\n"}