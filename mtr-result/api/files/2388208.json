{"id":"2388208","content":"package io.swagger.v3.core.jackson;\n\nimport com.fasterxml.jackson.annotation.JsonIdentityInfo;\nimport com.fasterxml.jackson.annotation.JsonIdentityReference;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.annotation.JsonTypeName;\nimport com.fasterxml.jackson.annotation.JsonUnwrapped;\nimport com.fasterxml.jackson.annotation.JsonValue;\nimport com.fasterxml.jackson.annotation.JsonView;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerator;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties.Value;\nimport com.fasterxml.jackson.annotation.JsonProperty.Access;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators.IntSequenceGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators.None;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators.PropertyGenerator;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators.UUIDGenerator;\nimport com.fasterxml.jackson.core.type.ResolvedType;\nimport com.fasterxml.jackson.databind.AnnotationIntrospector;\nimport com.fasterxml.jackson.databind.BeanDescription;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.PropertyMetadata;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.introspect.Annotated;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedClass;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedField;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMember;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\nimport com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\nimport com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder;\nimport com.fasterxml.jackson.databind.jsontype.NamedType;\nimport com.fasterxml.jackson.databind.util.Annotations;\nimport io.swagger.v3.core.converter.AnnotatedType;\nimport io.swagger.v3.core.converter.ModelConverter;\nimport io.swagger.v3.core.converter.ModelConverterContext;\nimport io.swagger.v3.core.jackson.TypeNameResolver.Options;\nimport io.swagger.v3.core.util.AnnotationsUtils;\nimport io.swagger.v3.core.util.Json;\nimport io.swagger.v3.core.util.ObjectMapperFactory;\nimport io.swagger.v3.core.util.PrimitiveType;\nimport io.swagger.v3.core.util.RefUtils;\nimport io.swagger.v3.core.util.ReferenceTypeUtils;\nimport io.swagger.v3.core.util.ReflectionUtils;\nimport io.swagger.v3.oas.annotations.Hidden;\nimport io.swagger.v3.oas.annotations.StringToClassMapItem;\nimport io.swagger.v3.oas.annotations.media.ArraySchema;\nimport io.swagger.v3.oas.annotations.media.DependentRequired;\nimport io.swagger.v3.oas.annotations.media.DependentSchema;\nimport io.swagger.v3.oas.annotations.media.DependentSchemas;\nimport io.swagger.v3.oas.annotations.media.DiscriminatorMapping;\nimport io.swagger.v3.oas.annotations.media.PatternProperties;\nimport io.swagger.v3.oas.annotations.media.PatternProperty;\nimport io.swagger.v3.oas.annotations.media.SchemaProperties;\nimport io.swagger.v3.oas.annotations.media.SchemaProperty;\nimport io.swagger.v3.oas.annotations.media.Schema.AccessMode;\nimport io.swagger.v3.oas.annotations.media.Schema.AdditionalPropertiesValue;\nimport io.swagger.v3.oas.annotations.media.Schema.RequiredMode;\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.ExternalDocumentation;\nimport io.swagger.v3.oas.models.media.ComposedSchema;\nimport io.swagger.v3.oas.models.media.Discriminator;\nimport io.swagger.v3.oas.models.media.IntegerSchema;\nimport io.swagger.v3.oas.models.media.JsonSchema;\nimport io.swagger.v3.oas.models.media.MapSchema;\nimport io.swagger.v3.oas.models.media.NumberSchema;\nimport io.swagger.v3.oas.models.media.ObjectSchema;\nimport io.swagger.v3.oas.models.media.Schema;\nimport io.swagger.v3.oas.models.media.StringSchema;\nimport io.swagger.v3.oas.models.media.UUIDSchema;\nimport io.swagger.v3.oas.models.media.XML;\nimport java.io.IOException;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedParameterizedType;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.Map.Entry;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.IntFunction;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport javax.validation.constraints.DecimalMax;\nimport javax.validation.constraints.DecimalMin;\nimport javax.validation.constraints.Max;\nimport javax.validation.constraints.Min;\nimport javax.validation.constraints.Pattern;\nimport javax.validation.constraints.Size;\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlElementRef;\nimport javax.xml.bind.annotation.XmlElementRefs;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlSchema;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ModelResolver extends AbstractModelConverter implements ModelConverter {\n   Logger LOGGER = LoggerFactory.getLogger(ModelResolver.class);\n   public static List<String> NOT_NULL_ANNOTATIONS = Arrays.asList(\"NotNull\", \"NonNull\", \"NotBlank\", \"NotEmpty\");\n   public static final String SET_PROPERTY_OF_COMPOSED_MODEL_AS_SIBLING = \"composed-model-properties-as-sibiling\";\n   public static final String SET_PROPERTY_OF_ENUMS_AS_REF = \"enums-as-ref\";\n   public static boolean composedModelPropertiesAsSibling = System.getProperty(\"composed-model-properties-as-sibiling\") != null;\n   public static boolean enumsAsRef = System.getProperty(\"enums-as-ref\") != null;\n   private boolean openapi31;\n\n   public ModelResolver(ObjectMapper mapper) {\n      super(mapper);\n   }\n\n   public ModelResolver(ObjectMapper mapper, TypeNameResolver typeNameResolver) {\n      super(mapper, typeNameResolver);\n   }\n\n   public ObjectMapper objectMapper() {\n      return this._mapper;\n   }\n\n   public Schema resolve(AnnotatedType annotatedType, ModelConverterContext context, Iterator<ModelConverter> next) {\n      boolean isPrimitive = false;\n      Schema model = null;\n      List<String> requiredProps = new ArrayList();\n      if (annotatedType == null) {\n         return null;\n      } else if (this.shouldIgnoreClass(annotatedType.getType())) {\n         return null;\n      } else {\n         JavaType type;\n         if (annotatedType.getType() instanceof JavaType) {\n            type = (JavaType)annotatedType.getType();\n         } else {\n            type = this._mapper.constructType(annotatedType.getType());\n         }\n\n         Annotation resolvedSchemaOrArrayAnnotation = AnnotationsUtils.mergeSchemaAnnotations(annotatedType.getCtxAnnotations(), type);\n         io.swagger.v3.oas.annotations.media.Schema resolvedSchemaAnnotation = resolvedSchemaOrArrayAnnotation == null ? null : (resolvedSchemaOrArrayAnnotation instanceof ArraySchema ? ((ArraySchema)resolvedSchemaOrArrayAnnotation).schema() : (io.swagger.v3.oas.annotations.media.Schema)resolvedSchemaOrArrayAnnotation);\n         ArraySchema resolvedArrayAnnotation = resolvedSchemaOrArrayAnnotation == null ? null : (resolvedSchemaOrArrayAnnotation instanceof ArraySchema ? (ArraySchema)resolvedSchemaOrArrayAnnotation : null);\n         BeanDescription recurBeanDesc = this._mapper.getSerializationConfig().introspect(type);\n         HashSet<String> visited = new HashSet();\n\n         String ctxAnnotation;\n         for(JsonSerialize jsonSerialize = (JsonSerialize)recurBeanDesc.getClassAnnotations().get(JsonSerialize.class); jsonSerialize != null && !Void.class.equals(jsonSerialize.as()); jsonSerialize = (JsonSerialize)recurBeanDesc.getClassAnnotations().get(JsonSerialize.class)) {\n            ctxAnnotation = jsonSerialize.as().getName();\n            if (visited.contains(ctxAnnotation)) {\n               break;\n            }\n\n            visited.add(ctxAnnotation);\n            recurBeanDesc = this._mapper.getSerializationConfig().introspect(this._mapper.constructType(jsonSerialize.as()));\n         }\n\n         String name = annotatedType.getName();\n         if (StringUtils.isBlank(name)) {\n            if (!annotatedType.isSkipSchemaName() && resolvedSchemaAnnotation != null && !resolvedSchemaAnnotation.name().isEmpty()) {\n               name = resolvedSchemaAnnotation.name();\n            }\n\n            if (StringUtils.isBlank(name) && (type.isEnumType() || !ReflectionUtils.isSystemType(type))) {\n               name = this._typeName(type, recurBeanDesc);\n            }\n         }\n\n         name = this.decorateModelName(annotatedType, name);\n         String schemaRefFromAnnotation = null;\n         if (resolvedSchemaAnnotation != null && StringUtils.isNotEmpty(resolvedSchemaAnnotation.ref())) {\n            if (resolvedArrayAnnotation != null) {\n               io.swagger.v3.oas.models.media.ArraySchema schema = new io.swagger.v3.oas.models.media.ArraySchema();\n               this.resolveArraySchema(annotatedType, schema, resolvedArrayAnnotation);\n               return schema.items((new Schema()).$ref(resolvedSchemaAnnotation.ref()).name(name));\n            }\n\n            schemaRefFromAnnotation = resolvedSchemaAnnotation.ref();\n            if (!this.openapi31) {\n               return (new JsonSchema()).$ref(resolvedSchemaAnnotation.ref()).name(name);\n            }\n         }\n\n         JavaType keyType;\n         io.swagger.v3.oas.models.media.ArraySchema schema;\n         if (!annotatedType.isSkipOverride() && resolvedSchemaAnnotation != null && !Void.class.equals(resolvedSchemaAnnotation.implementation())) {\n            Class<?> cls = resolvedSchemaAnnotation.implementation();\n            this.LOGGER.debug(\"overriding datatype from {} to {}\", type, cls.getName());\n            ctxAnnotation = null;\n            Annotation[] ctxAnnotation;\n            if (resolvedArrayAnnotation != null && annotatedType.getCtxAnnotations() != null) {\n               List<Annotation> annList = new ArrayList();\n               Annotation[] var60 = annotatedType.getCtxAnnotations();\n               int var69 = var60.length;\n\n               for(int var71 = 0; var71 < var69; ++var71) {\n                  Annotation a = var60[var71];\n                  if (!(a instanceof io.swagger.v3.oas.models.media.ArraySchema)) {\n                     annList.add(a);\n                  }\n               }\n\n               annList.add(resolvedSchemaAnnotation);\n               ctxAnnotation = (Annotation[])annList.toArray(new Annotation[annList.size()]);\n            } else {\n               ctxAnnotation = annotatedType.getCtxAnnotations();\n            }\n\n            AnnotatedType aType = (new AnnotatedType()).type(cls).ctxAnnotations(ctxAnnotation).parent(annotatedType.getParent()).name(annotatedType.getName()).resolveAsRef(annotatedType.isResolveAsRef()).jsonViewAnnotation(annotatedType.getJsonViewAnnotation()).propertyName(annotatedType.getPropertyName()).components(annotatedType.getComponents()).skipOverride(true);\n            if (resolvedArrayAnnotation != null) {\n               schema = new io.swagger.v3.oas.models.media.ArraySchema();\n               this.resolveArraySchema(annotatedType, schema, resolvedArrayAnnotation);\n               keyType = null;\n               Schema primitive = PrimitiveType.createProperty(cls);\n               Schema innerSchema;\n               if (primitive != null) {\n                  innerSchema = primitive;\n               } else {\n                  innerSchema = context.resolve(aType);\n                  if (innerSchema != null && this.isObjectSchema(innerSchema) && StringUtils.isNotBlank(innerSchema.getName())) {\n                     if (context.getDefinedModels().containsKey(innerSchema.getName())) {\n                        innerSchema = (new Schema()).$ref(RefUtils.constructRef(innerSchema.getName()));\n                     }\n                  } else if (innerSchema != null && innerSchema.get$ref() != null) {\n                     innerSchema = (new Schema()).$ref(StringUtils.isNotEmpty(innerSchema.get$ref()) ? innerSchema.get$ref() : innerSchema.getName());\n                  }\n               }\n\n               schema.setItems(innerSchema);\n               return schema;\n            } else {\n               Schema implSchema = context.resolve(aType);\n               if (implSchema != null && aType.isResolveAsRef() && this.isObjectSchema(implSchema) && StringUtils.isNotBlank(implSchema.getName())) {\n                  if (context.getDefinedModels().containsKey(implSchema.getName())) {\n                     implSchema = (new Schema()).$ref(RefUtils.constructRef(implSchema.getName()));\n                  }\n               } else if (implSchema != null && implSchema.get$ref() != null) {\n                  implSchema = (new Schema()).$ref(StringUtils.isNotEmpty(implSchema.get$ref()) ? implSchema.get$ref() : implSchema.getName());\n               }\n\n               return implSchema;\n            }\n         } else {\n            PrimitiveType primitiveType;\n            if (model == null && !annotatedType.isSkipOverride() && resolvedSchemaAnnotation != null && StringUtils.isNotEmpty(resolvedSchemaAnnotation.type()) && !resolvedSchemaAnnotation.type().equals(\"object\")) {\n               primitiveType = PrimitiveType.fromTypeAndFormat(resolvedSchemaAnnotation.type(), resolvedSchemaAnnotation.format());\n               if (primitiveType == null) {\n                  primitiveType = PrimitiveType.fromType(type);\n               }\n\n               if (primitiveType == null) {\n                  primitiveType = PrimitiveType.fromName(resolvedSchemaAnnotation.type());\n               }\n\n               if (primitiveType != null) {\n                  Schema primitive = primitiveType.createProperty();\n                  model = primitive;\n                  isPrimitive = true;\n               }\n            }\n\n            if (model == null && type.isEnumType()) {\n               model = new StringSchema();\n               this._addEnumProps(type.getRawClass(), (Schema)model);\n               isPrimitive = true;\n            }\n\n            if (model == null) {\n               primitiveType = PrimitiveType.fromType(type);\n               if (primitiveType != null) {\n                  model = PrimitiveType.fromType(type).createProperty();\n                  isPrimitive = true;\n               }\n            }\n\n            if (!annotatedType.isSkipJsonIdentity()) {\n               JsonIdentityInfo jsonIdentityInfo = (JsonIdentityInfo)AnnotationsUtils.getAnnotation(JsonIdentityInfo.class, annotatedType.getCtxAnnotations());\n               if (jsonIdentityInfo == null) {\n                  jsonIdentityInfo = (JsonIdentityInfo)type.getRawClass().getAnnotation(JsonIdentityInfo.class);\n               }\n\n               if (model == null && jsonIdentityInfo != null) {\n                  JsonIdentityReference jsonIdentityReference = (JsonIdentityReference)AnnotationsUtils.getAnnotation(JsonIdentityReference.class, annotatedType.getCtxAnnotations());\n                  if (jsonIdentityReference == null) {\n                     jsonIdentityReference = (JsonIdentityReference)type.getRawClass().getAnnotation(JsonIdentityReference.class);\n                  }\n\n                  model = (new ModelResolver.GeneratorWrapper(null)).processJsonIdentity(annotatedType, context, this._mapper, jsonIdentityInfo, jsonIdentityReference);\n                  if (model != null) {\n                     return (Schema)model;\n                  }\n               }\n            }\n\n            if (model == null && annotatedType.getJsonUnwrappedHandler() != null) {\n               model = (Schema)annotatedType.getJsonUnwrappedHandler().apply(annotatedType);\n               if (model == null) {\n                  return null;\n               }\n            }\n\n            if (\"Object\".equals(name)) {\n               Schema schema = new Schema();\n               if (schemaRefFromAnnotation != null) {\n                  schema.raw$ref(schemaRefFromAnnotation);\n               }\n\n               return schema;\n            } else {\n               List<Class<?>> composedSchemaReferencedClasses = this.getComposedSchemaReferencedClasses(type.getRawClass(), annotatedType.getCtxAnnotations(), resolvedSchemaAnnotation);\n               boolean isComposedSchema = composedSchemaReferencedClasses != null;\n               if (isPrimitive) {\n                  XML xml = this.resolveXml(recurBeanDesc.getClassInfo(), annotatedType.getCtxAnnotations(), resolvedSchemaAnnotation);\n                  if (xml != null) {\n                     ((Schema)model).xml(xml);\n                  }\n\n                  this.applyBeanValidatorAnnotations((Schema)model, annotatedType.getCtxAnnotations(), (Schema)null, false);\n                  this.resolveSchemaMembers((Schema)model, (AnnotatedType)annotatedType, (ModelConverterContext)context, (Iterator)next);\n                  if (resolvedArrayAnnotation != null) {\n                     schema = new io.swagger.v3.oas.models.media.ArraySchema();\n                     this.resolveArraySchema(annotatedType, schema, resolvedArrayAnnotation);\n                     schema.setItems((Schema)model);\n                     return schema;\n                  }\n\n                  if (type.isEnumType() && this.shouldResolveEnumAsRef(resolvedSchemaAnnotation)) {\n                     context.defineModel(name, (Schema)model, annotatedType, (String)null);\n                     model = (new Schema()).$ref(\"#/components/schemas/\" + name);\n                  }\n\n                  if (!isComposedSchema) {\n                     if (schemaRefFromAnnotation != null && model != null) {\n                        ((Schema)model).raw$ref(schemaRefFromAnnotation);\n                     }\n\n                     return (Schema)model;\n                  }\n               }\n\n               Schema resolvedModel = context.resolve(annotatedType);\n               if (resolvedModel != null && name != null && name.equals(resolvedModel.getName())) {\n                  return resolvedModel;\n               } else {\n                  Type jsonValueType = this.findJsonValueType(recurBeanDesc);\n                  AnnotatedType aType;\n                  if (jsonValueType != null) {\n                     aType = (new AnnotatedType()).type(jsonValueType).parent(annotatedType.getParent()).name(annotatedType.getName()).schemaProperty(annotatedType.isSchemaProperty()).resolveAsRef(annotatedType.isResolveAsRef()).jsonViewAnnotation(annotatedType.getJsonViewAnnotation()).propertyName(annotatedType.getPropertyName()).ctxAnnotations(annotatedType.getCtxAnnotations()).components(annotatedType.getComponents()).skipOverride(true);\n                     return context.resolve(aType);\n                  } else {\n                     XmlElement xmlElement;\n                     Schema model;\n                     ArrayList props;\n                     if (type.isContainerType()) {\n                        isComposedSchema = false;\n                        keyType = type.getKeyType();\n                        JavaType valueType = type.getContentType();\n                        String pName = null;\n                        if (valueType != null) {\n                           BeanDescription valueTypeBeanDesc = this._mapper.getSerializationConfig().introspect(valueType);\n                           pName = this._typeName(valueType, valueTypeBeanDesc);\n                        }\n\n                        props = new ArrayList();\n                        if (resolvedSchemaAnnotation != null) {\n                           props.add(0, resolvedSchemaAnnotation);\n                        }\n\n                        if (annotatedType.getCtxAnnotations() != null) {\n                           props.addAll((Collection)Arrays.stream(annotatedType.getCtxAnnotations()).filter((ass) -> {\n                              return !ass.annotationType().getName().startsWith(\"io.swagger\") && !ass.annotationType().getName().startsWith(\"javax.validation.constraints\");\n                           }).collect(Collectors.toList()));\n                        }\n\n                        Schema items;\n                        if (keyType != null && valueType != null) {\n                           if (ReflectionUtils.isSystemType(type) && !annotatedType.isSchemaProperty() && !annotatedType.isResolveAsRef()) {\n                              context.resolve((new AnnotatedType()).components(annotatedType.getComponents()).type(valueType).jsonViewAnnotation(annotatedType.getJsonViewAnnotation()));\n                              return null;\n                           }\n\n                           items = context.resolve((new AnnotatedType()).type(valueType).schemaProperty(annotatedType.isSchemaProperty()).ctxAnnotations((Annotation[])props.toArray(new Annotation[0])).skipSchemaName(true).resolveAsRef(annotatedType.isResolveAsRef()).jsonViewAnnotation(annotatedType.getJsonViewAnnotation()).propertyName(annotatedType.getPropertyName()).components(annotatedType.getComponents()).parent(annotatedType.getParent()));\n                           if (items != null) {\n                              if (StringUtils.isNotBlank(items.getName())) {\n                                 pName = items.getName();\n                              }\n\n                              if (this.isObjectSchema(items) && pName != null) {\n                                 if (context.getDefinedModels().containsKey(pName)) {\n                                    items = (new Schema()).$ref(RefUtils.constructRef(pName));\n                                 }\n                              } else if (items.get$ref() != null) {\n                                 items = (new Schema()).$ref(StringUtils.isNotEmpty(items.get$ref()) ? items.get$ref() : items.getName());\n                              }\n                           }\n\n                           Schema mapModel = (new MapSchema()).additionalProperties(items);\n                           mapModel.name(name);\n                           model = mapModel;\n                        } else if (valueType != null) {\n                           if (ReflectionUtils.isSystemType(type) && !annotatedType.isSchemaProperty() && !annotatedType.isResolveAsRef()) {\n                              context.resolve((new AnnotatedType()).components(annotatedType.getComponents()).type(valueType).jsonViewAnnotation(annotatedType.getJsonViewAnnotation()));\n                              return null;\n                           }\n\n                           items = context.resolve((new AnnotatedType()).type(valueType).schemaProperty(annotatedType.isSchemaProperty()).ctxAnnotations((Annotation[])props.toArray(new Annotation[0])).skipSchemaName(true).resolveAsRef(annotatedType.isResolveAsRef()).propertyName(annotatedType.getPropertyName()).jsonViewAnnotation(annotatedType.getJsonViewAnnotation()).components(annotatedType.getComponents()).parent(annotatedType.getParent()));\n                           if (items == null) {\n                              return null;\n                           }\n\n                           if (annotatedType.isSchemaProperty() && annotatedType.getCtxAnnotations() != null && annotatedType.getCtxAnnotations().length > 0 && !\"object\".equals(items.getType())) {\n                              Annotation[] var23 = annotatedType.getCtxAnnotations();\n                              int var24 = var23.length;\n\n                              for(int var25 = 0; var25 < var24; ++var25) {\n                                 Annotation annotation = var23[var25];\n                                 if (annotation instanceof XmlElement) {\n                                    xmlElement = (XmlElement)annotation;\n                                    if (xmlElement != null && xmlElement.name() != null && !\"\".equals(xmlElement.name()) && !\"##default\".equals(xmlElement.name())) {\n                                       XML xml = items.getXml() != null ? items.getXml() : new XML();\n                                       xml.setName(xmlElement.name());\n                                       items.setXml(xml);\n                                    }\n                                 }\n                              }\n                           }\n\n                           if (StringUtils.isNotBlank(items.getName())) {\n                              pName = items.getName();\n                           }\n\n                           if (this.isObjectSchema(items) && pName != null) {\n                              if (context.getDefinedModels().containsKey(pName)) {\n                                 items = (new Schema()).$ref(RefUtils.constructRef(pName));\n                              }\n                           } else if (items.get$ref() != null) {\n                              items = (new Schema()).$ref(StringUtils.isNotEmpty(items.get$ref()) ? items.get$ref() : items.getName());\n                           }\n\n                           Schema arrayModel = (new io.swagger.v3.oas.models.media.ArraySchema()).items(items);\n                           if (this._isSetType(type.getRawClass())) {\n                              arrayModel.setUniqueItems(true);\n                           }\n\n                           arrayModel.name(name);\n                           model = arrayModel;\n                        } else if (ReflectionUtils.isSystemType(type) && !annotatedType.isSchemaProperty() && !annotatedType.isResolveAsRef()) {\n                           return null;\n                        }\n                     } else if (isComposedSchema) {\n                        model = (new ComposedSchema()).type(\"object\").name(name);\n                     } else {\n                        aType = ReferenceTypeUtils.unwrapReference(annotatedType);\n                        if (aType != null) {\n                           model = context.resolve(aType);\n                           return model;\n                        }\n\n                        model = (new Schema()).type(\"object\").name(name);\n                     }\n\n                     if (!type.isContainerType() && StringUtils.isNotBlank(name)) {\n                        context.defineModel(name, (Schema)model, annotatedType, (String)null);\n                     }\n\n                     XML xml = this.resolveXml(recurBeanDesc.getClassInfo(), annotatedType.getCtxAnnotations(), resolvedSchemaAnnotation);\n                     if (xml != null) {\n                        ((Schema)model).xml(xml);\n                     }\n\n                     if (!(model instanceof io.swagger.v3.oas.models.media.ArraySchema) || model instanceof io.swagger.v3.oas.models.media.ArraySchema && resolvedArrayAnnotation == null) {\n                        this.resolveSchemaMembers((Schema)model, (AnnotatedType)annotatedType, (ModelConverterContext)context, (Iterator)next);\n                     }\n\n                     XmlAccessorType xmlAccessorTypeAnnotation = (XmlAccessorType)recurBeanDesc.getClassAnnotations().get(XmlAccessorType.class);\n                     Set<String> propertiesToIgnore = this.resolveIgnoredProperties(recurBeanDesc.getClassAnnotations(), annotatedType.getCtxAnnotations());\n                     props = new ArrayList();\n                     Map<String, Schema> modelProps = new LinkedHashMap();\n                     List<BeanPropertyDefinition> properties = recurBeanDesc.findProperties();\n                     List<String> ignoredProps = this.getIgnoredProperties(recurBeanDesc);\n                     properties.removeIf((p) -> {\n                        return ignoredProps.contains(p.getName());\n                     });\n                     Iterator var82 = properties.iterator();\n\n                     while(true) {\n                        Annotation[] annotations;\n                        AccessMode accessMode;\n                        RequiredMode requiredMode;\n                        BeanPropertyDefinition propDef;\n                        Schema property;\n                        String propName;\n                        PropertyMetadata md;\n                        JavaType propType;\n                        io.swagger.v3.oas.annotations.media.Schema ctxSchema;\n                        ArraySchema ctxArraySchema;\n                        do {\n                           AnnotatedMember member;\n                           do {\n                              Iterator var33;\n                              do {\n                                 do {\n                                    List allOfFiltered;\n                                    if (!var82.hasNext()) {\n                                       var82 = props.iterator();\n\n                                       while(var82.hasNext()) {\n                                          Schema prop = (Schema)var82.next();\n                                          modelProps.put(prop.getName(), prop);\n                                       }\n\n                                       String ref;\n                                       if (modelProps.size() > 0) {\n                                          if (((Schema)model).getProperties() == null) {\n                                             ((Schema)model).setProperties(modelProps);\n                                          } else {\n                                             var82 = modelProps.keySet().iterator();\n\n                                             while(var82.hasNext()) {\n                                                ref = (String)var82.next();\n                                                ((Schema)model).addProperty(ref, (Schema)modelProps.get(ref));\n                                             }\n                                          }\n\n                                          var82 = requiredProps.iterator();\n\n                                          while(var82.hasNext()) {\n                                             ref = (String)var82.next();\n                                             this.addRequiredItem((Schema)model, ref);\n                                          }\n                                       }\n\n                                       if (!type.isContainerType() && StringUtils.isNotBlank(name)) {\n                                          context.defineModel(name, (Schema)model, annotatedType, (String)null);\n                                       }\n\n                                       if (!this.resolveSubtypes((Schema)model, recurBeanDesc, context, annotatedType.getJsonViewAnnotation())) {\n                                          ((Schema)model).setDiscriminator((Discriminator)null);\n                                       }\n\n                                       Discriminator discriminator = this.resolveDiscriminator(type, context);\n                                       if (discriminator != null) {\n                                          ((Schema)model).setDiscriminator(discriminator);\n                                       }\n\n                                       if (resolvedSchemaAnnotation != null) {\n                                          ref = resolvedSchemaAnnotation.ref();\n                                          if (!StringUtils.isBlank(ref)) {\n                                             ((Schema)model).$ref(ref);\n                                          }\n\n                                          Class<?> not = resolvedSchemaAnnotation.not();\n                                          if (!Void.class.equals(not)) {\n                                             ((Schema)model).not((new Schema()).$ref(context.resolve((new AnnotatedType()).components(annotatedType.getComponents()).type(not).jsonViewAnnotation(annotatedType.getJsonViewAnnotation())).getName()));\n                                          }\n\n                                          if (resolvedSchemaAnnotation.requiredProperties() != null && resolvedSchemaAnnotation.requiredProperties().length > 0 && StringUtils.isNotBlank(resolvedSchemaAnnotation.requiredProperties()[0])) {\n                                             String[] var90 = resolvedSchemaAnnotation.requiredProperties();\n                                             int var91 = var90.length;\n\n                                             for(int var97 = 0; var97 < var91; ++var97) {\n                                                String prop = var90[var97];\n                                                this.addRequiredItem((Schema)model, prop);\n                                             }\n                                          }\n                                       }\n\n                                       Map<String, Schema> patternProperties = this.resolvePatternProperties(type, annotatedType.getCtxAnnotations(), context);\n                                       if (model != null && patternProperties != null && !patternProperties.isEmpty()) {\n                                          if (((Schema)model).getPatternProperties() == null) {\n                                             ((Schema)model).patternProperties(patternProperties);\n                                          } else {\n                                             ((Schema)model).getPatternProperties().putAll(patternProperties);\n                                          }\n                                       }\n\n                                       Map<String, Schema> schemaProperties = this.resolveSchemaProperties(type, annotatedType.getCtxAnnotations(), context);\n                                       if (model != null && schemaProperties != null && !schemaProperties.isEmpty()) {\n                                          if (((Schema)model).getProperties() == null) {\n                                             ((Schema)model).properties(schemaProperties);\n                                          } else {\n                                             ((Schema)model).getProperties().putAll(schemaProperties);\n                                          }\n                                       }\n\n                                       if (this.openapi31) {\n                                          Map<String, Schema> dependentSchemas = this.resolveDependentSchemas(type, annotatedType.getCtxAnnotations(), context, annotatedType.getComponents(), annotatedType.getJsonViewAnnotation(), this.openapi31);\n                                          if (model != null && dependentSchemas != null && !dependentSchemas.isEmpty()) {\n                                             if (((Schema)model).getDependentSchemas() == null) {\n                                                ((Schema)model).dependentSchemas(dependentSchemas);\n                                             } else {\n                                                ((Schema)model).getDependentSchemas().putAll(dependentSchemas);\n                                             }\n                                          }\n                                       }\n\n                                       if (isComposedSchema) {\n                                          ComposedSchema composedSchema = (ComposedSchema)model;\n                                          Class<?>[] allOf = resolvedSchemaAnnotation.allOf();\n                                          Class<?>[] anyOf = resolvedSchemaAnnotation.anyOf();\n                                          Class<?>[] oneOf = resolvedSchemaAnnotation.oneOf();\n                                          allOfFiltered = (List)Stream.of(allOf).distinct().filter((c) -> {\n                                             return !this.shouldIgnoreClass(c);\n                                          }).filter((c) -> {\n                                             return !c.equals(Void.class);\n                                          }).collect(Collectors.toList());\n                                          allOfFiltered.forEach((c) -> {\n                                             Schema allOfRef = context.resolve((new AnnotatedType()).components(annotatedType.getComponents()).type(c).jsonViewAnnotation(annotatedType.getJsonViewAnnotation()));\n                                             Schema refSchema = (new Schema()).$ref(\"#/components/schemas/\" + allOfRef.getName());\n                                             if (StringUtils.isBlank(allOfRef.getName())) {\n                                                refSchema = allOfRef;\n                                             }\n\n                                             if (composedSchema.getAllOf() == null || !composedSchema.getAllOf().contains(refSchema)) {\n                                                composedSchema.addAllOfItem(refSchema);\n                                             }\n\n                                             if (this.isSubtype(recurBeanDesc.getClassInfo(), c)) {\n                                                this.removeParentProperties(composedSchema, allOfRef);\n                                             }\n\n                                          });\n                                          List<Class<?>> anyOfFiltered = (List)Stream.of(anyOf).distinct().filter((c) -> {\n                                             return !this.shouldIgnoreClass(c);\n                                          }).filter((c) -> {\n                                             return !c.equals(Void.class);\n                                          }).collect(Collectors.toList());\n                                          anyOfFiltered.forEach((c) -> {\n                                             Schema anyOfRef = context.resolve((new AnnotatedType()).components(annotatedType.getComponents()).type(c).jsonViewAnnotation(annotatedType.getJsonViewAnnotation()));\n                                             if (StringUtils.isNotBlank(anyOfRef.getName())) {\n                                                composedSchema.addAnyOfItem((new Schema()).$ref(\"#/components/schemas/\" + anyOfRef.getName()));\n                                             } else {\n                                                composedSchema.addAnyOfItem(anyOfRef);\n                                             }\n\n                                             if (this.isSubtype(recurBeanDesc.getClassInfo(), c)) {\n                                                this.removeParentProperties(composedSchema, anyOfRef);\n                                             }\n\n                                          });\n                                          List<Class<?>> oneOfFiltered = (List)Stream.of(oneOf).distinct().filter((c) -> {\n                                             return !this.shouldIgnoreClass(c);\n                                          }).filter((c) -> {\n                                             return !c.equals(Void.class);\n                                          }).collect(Collectors.toList());\n                                          oneOfFiltered.forEach((c) -> {\n                                             Schema oneOfRef = context.resolve((new AnnotatedType()).components(annotatedType.getComponents()).type(c).jsonViewAnnotation(annotatedType.getJsonViewAnnotation()));\n                                             if (oneOfRef != null) {\n                                                if (StringUtils.isBlank(oneOfRef.getName())) {\n                                                   composedSchema.addOneOfItem(oneOfRef);\n                                                } else {\n                                                   composedSchema.addOneOfItem((new Schema()).$ref(\"#/components/schemas/\" + oneOfRef.getName()));\n                                                }\n\n                                                if (this.isSubtype(recurBeanDesc.getClassInfo(), c)) {\n                                                   this.removeParentProperties(composedSchema, oneOfRef);\n                                                }\n                                             }\n\n                                          });\n                                          if (!composedModelPropertiesAsSibling && composedSchema.getAllOf() != null && !composedSchema.getAllOf().isEmpty() && composedSchema.getProperties() != null && !composedSchema.getProperties().isEmpty()) {\n                                             ObjectSchema propSchema = new ObjectSchema();\n                                             propSchema.properties(composedSchema.getProperties());\n                                             composedSchema.setProperties((Map)null);\n                                             composedSchema.addAllOfItem(propSchema);\n                                          }\n                                       }\n\n                                       if (!type.isContainerType() && StringUtils.isNotBlank(name)) {\n                                          context.defineModel(name, (Schema)model, annotatedType, (String)null);\n                                       }\n\n                                       if (model != null && annotatedType.isResolveAsRef() && (isComposedSchema || this.isObjectSchema((Schema)model)) && StringUtils.isNotBlank(((Schema)model).getName())) {\n                                          if (context.getDefinedModels().containsKey(((Schema)model).getName())) {\n                                             model = (new Schema()).$ref(RefUtils.constructRef(((Schema)model).getName()));\n                                          }\n                                       } else if (model != null && ((Schema)model).get$ref() != null) {\n                                          model = (new Schema()).$ref(StringUtils.isNotEmpty(((Schema)model).get$ref()) ? ((Schema)model).get$ref() : ((Schema)model).getName());\n                                       }\n\n                                       if (model != null && resolvedArrayAnnotation != null) {\n                                          if (!\"array\".equals(((Schema)model).getType())) {\n                                             io.swagger.v3.oas.models.media.ArraySchema schema = new io.swagger.v3.oas.models.media.ArraySchema();\n                                             schema.setItems((Schema)model);\n                                             this.resolveArraySchema(annotatedType, schema, resolvedArrayAnnotation);\n                                             return schema;\n                                          }\n\n                                          if (model instanceof io.swagger.v3.oas.models.media.ArraySchema) {\n                                             this.resolveArraySchema(annotatedType, (io.swagger.v3.oas.models.media.ArraySchema)model, resolvedArrayAnnotation);\n                                          }\n                                       }\n\n                                       this.resolveDiscriminatorProperty(type, context, (Schema)model);\n                                       model = this.resolveWrapping(type, context, (Schema)model);\n                                       return model;\n                                    }\n\n                                    propDef = (BeanPropertyDefinition)var82.next();\n                                    xmlElement = null;\n                                    propName = propDef.getName();\n                                    annotations = null;\n                                    member = propDef.getPrimaryMember();\n                                    if (member == null) {\n                                       BeanDescription deserBeanDesc = this._mapper.getDeserializationConfig().introspect(type);\n                                       allOfFiltered = deserBeanDesc.findProperties();\n                                       var33 = allOfFiltered.iterator();\n\n                                       while(var33.hasNext()) {\n                                          BeanPropertyDefinition prop = (BeanPropertyDefinition)var33.next();\n                                          if (StringUtils.isNotBlank(prop.getInternalName()) && prop.getInternalName().equals(propDef.getInternalName())) {\n                                             member = prop.getPrimaryMember();\n                                             break;\n                                          }\n                                       }\n                                    }\n\n                                    if (propDef.getPrimaryMember() != null) {\n                                       JsonProperty jsonPropertyAnn = (JsonProperty)propDef.getPrimaryMember().getAnnotation(JsonProperty.class);\n                                       if ((jsonPropertyAnn == null || !jsonPropertyAnn.value().equals(propName)) && member != null) {\n                                          Member innerMember = member.getMember();\n                                          if (innerMember != null) {\n                                             String altName = innerMember.getName();\n                                             if (altName != null) {\n                                                int length = altName.length();\n                                                Iterator var35 = Arrays.asList(\"get\", \"is\").iterator();\n\n                                                while(var35.hasNext()) {\n                                                   String prefix = (String)var35.next();\n                                                   int offset = prefix.length();\n                                                   if (altName.startsWith(prefix) && length > offset && !Character.isUpperCase(altName.charAt(offset))) {\n                                                      propName = altName;\n                                                      break;\n                                                   }\n                                                }\n                                             }\n                                          }\n                                       }\n                                    }\n\n                                    md = propDef.getMetadata();\n                                 } while(member == null);\n                              } while(this.ignore(member, xmlAccessorTypeAnnotation, propName, propertiesToIgnore, propDef));\n\n                              List<Annotation> annotationList = new ArrayList();\n                              var33 = member.annotations().iterator();\n\n                              while(var33.hasNext()) {\n                                 Annotation a = (Annotation)var33.next();\n                                 annotationList.add(a);\n                              }\n\n                              annotations = (Annotation[])annotationList.toArray(new Annotation[annotationList.size()]);\n                           } while(this.hiddenByJsonView(annotations, annotatedType));\n\n                           propType = member.getType();\n                           if (propType != null && \"void\".equals(propType.getRawClass().getName()) && member instanceof AnnotatedMethod) {\n                              propType = ((AnnotatedMethod)member).getParameterType(0);\n                           }\n\n                           String propSchemaName = null;\n                           ctxSchema = AnnotationsUtils.getSchemaAnnotation(annotations);\n                           if (AnnotationsUtils.hasSchemaAnnotation(ctxSchema) && !StringUtils.isBlank(ctxSchema.name())) {\n                              propSchemaName = ctxSchema.name();\n                           }\n\n                           ctxArraySchema = AnnotationsUtils.getArraySchemaAnnotation(annotations);\n                           if (propSchemaName == null && AnnotationsUtils.hasArrayAnnotation(ctxArraySchema) && AnnotationsUtils.hasSchemaAnnotation(ctxArraySchema.schema()) && !StringUtils.isBlank(ctxArraySchema.schema().name())) {\n                              propSchemaName = ctxArraySchema.schema().name();\n                           }\n\n                           if (StringUtils.isNotBlank(propSchemaName)) {\n                              propName = propSchemaName;\n                           }\n\n                           Annotation propSchemaOrArray = AnnotationsUtils.mergeSchemaAnnotations(annotations, propType);\n                           io.swagger.v3.oas.annotations.media.Schema propResolvedSchemaAnnotation = propSchemaOrArray == null ? null : (propSchemaOrArray instanceof ArraySchema ? ((ArraySchema)propSchemaOrArray).schema() : (io.swagger.v3.oas.annotations.media.Schema)propSchemaOrArray);\n                           accessMode = this.resolveAccessMode(propDef, type, propResolvedSchemaAnnotation);\n                           requiredMode = this.resolveRequiredMode(propResolvedSchemaAnnotation);\n                           Annotation[] ctxAnnotation31 = null;\n                           if (this.openapi31) {\n                              List<Annotation> ctxAnnotations31List = new ArrayList();\n                              if (annotations != null) {\n                                 Annotation[] var43 = annotations;\n                                 int var44 = annotations.length;\n\n                                 for(int var45 = 0; var45 < var44; ++var45) {\n                                    Annotation a = var43[var45];\n                                    if (!(a instanceof io.swagger.v3.oas.annotations.media.Schema) && !(a instanceof ArraySchema)) {\n                                       ctxAnnotations31List.add(a);\n                                    }\n                                 }\n\n                                 ctxAnnotation31 = (Annotation[])ctxAnnotations31List.toArray(new Annotation[ctxAnnotations31List.size()]);\n                              }\n                           }\n\n                           AnnotatedType aType = (new AnnotatedType()).type(propType).ctxAnnotations(this.openapi31 ? ctxAnnotation31 : annotations).parent((Schema)model).resolveAsRef(annotatedType.isResolveAsRef()).jsonViewAnnotation(annotatedType.getJsonViewAnnotation()).skipSchemaName(true).schemaProperty(true).components(annotatedType.getComponents()).propertyName(propName);\n                           aType.jsonUnwrappedHandler((t) -> {\n                              JsonUnwrapped uw = (JsonUnwrapped)member.getAnnotation(JsonUnwrapped.class);\n                              if (uw != null && uw.enabled()) {\n                                 t.ctxAnnotations((Annotation[])null).jsonUnwrappedHandler((Function)null).resolveAsRef(false);\n                                 this.handleUnwrapped(props, context.resolve(t), uw.prefix(), uw.suffix(), requiredProps);\n                                 return null;\n                              } else {\n                                 return new Schema();\n                              }\n                           });\n                           property = context.resolve(aType);\n                           property = this.clone(property);\n                           if (this.openapi31) {\n                              Optional<Schema> reResolvedProperty = AnnotationsUtils.getSchemaFromAnnotation(ctxSchema, annotatedType.getComponents(), (JsonView)null, this.openapi31, property, context);\n                              if (reResolvedProperty.isPresent()) {\n                                 property = (Schema)reResolvedProperty.get();\n                              }\n\n                              reResolvedProperty = AnnotationsUtils.getArraySchema(ctxArraySchema, annotatedType.getComponents(), (JsonView)null, this.openapi31, property);\n                              if (reResolvedProperty.isPresent()) {\n                                 property = (Schema)reResolvedProperty.get();\n                              }\n                           }\n                        } while(property == null);\n\n                        Boolean required = md.getRequired();\n                        if (!RequiredMode.NOT_REQUIRED.equals(requiredMode)) {\n                           if (required != null && !Boolean.FALSE.equals(required)) {\n                              this.addRequiredItem((Schema)model, propName);\n                           } else if (propDef.isRequired()) {\n                              this.addRequiredItem((Schema)model, propName);\n                           }\n                        }\n\n                        if ((property.get$ref() == null || this.openapi31) && accessMode != null) {\n                           switch(accessMode) {\n                           case AUTO:\n                           case READ_WRITE:\n                           default:\n                              break;\n                           case READ_ONLY:\n                              property.readOnly(true);\n                              break;\n                           case WRITE_ONLY:\n                              property.writeOnly(true);\n                           }\n                        }\n\n                        BeanDescription propBeanDesc = this._mapper.getSerializationConfig().introspect(propType);\n                        if (property != null && !propType.isContainerType()) {\n                           if (this.isObjectSchema(property)) {\n                              String pName = this._typeName(propType, propBeanDesc);\n                              if (StringUtils.isNotBlank(property.getName())) {\n                                 pName = property.getName();\n                              }\n\n                              if (context.getDefinedModels().containsKey(pName)) {\n                                 property = (new Schema()).$ref(RefUtils.constructRef(pName));\n                                 property = this.clone(property);\n                                 if (this.openapi31) {\n                                    Optional<Schema> reResolvedProperty = AnnotationsUtils.getSchemaFromAnnotation(ctxSchema, annotatedType.getComponents(), (JsonView)null, this.openapi31, property, context);\n                                    if (reResolvedProperty.isPresent()) {\n                                       property = (Schema)reResolvedProperty.get();\n                                    }\n\n                                    reResolvedProperty = AnnotationsUtils.getArraySchema(ctxArraySchema, annotatedType.getComponents(), (JsonView)null, this.openapi31, property);\n                                    if (reResolvedProperty.isPresent()) {\n                                       property = (Schema)reResolvedProperty.get();\n                                    }\n                                 }\n                              }\n                           } else if (property.get$ref() != null) {\n                              if (!this.openapi31) {\n                                 property = (new Schema()).$ref(StringUtils.isNotEmpty(property.get$ref()) ? property.get$ref() : property.getName());\n                              } else if (StringUtils.isEmpty(property.get$ref())) {\n                                 property.$ref(property.getName());\n                              }\n                           }\n                        }\n\n                        property.setName(propName);\n                        JAXBAnnotationsHelper.apply(propBeanDesc.getClassInfo(), annotations, property);\n                        if (property != null && RequiredMode.REQUIRED.equals(requiredMode)) {\n                           this.addRequiredItem((Schema)model, property.getName());\n                        }\n\n                        boolean applyNotNullAnnotations = RequiredMode.AUTO.equals(requiredMode);\n                        annotations = this.addGenericTypeArgumentAnnotationsForOptionalField(propDef, annotations);\n                        this.applyBeanValidatorAnnotations(propDef, property, annotations, (Schema)model, applyNotNullAnnotations);\n                        props.add(property);\n                     }\n                  }\n               }\n            }\n         }\n      }\n   }\n\n   private Annotation[] addGenericTypeArgumentAnnotationsForOptionalField(BeanPropertyDefinition propDef, Annotation[] annotations) {\n      boolean isNotOptionalType = ((Boolean)Optional.ofNullable(propDef).map(BeanPropertyDefinition::getField).map(AnnotatedField::getAnnotated).map((field) -> {\n         return !field.getType().equals(Optional.class);\n      }).orElse(false)).booleanValue();\n      if (isNotOptionalType) {\n         return annotations;\n      } else {\n         Stream<Annotation> genericTypeArgumentAnnotations = this.extractGenericTypeArgumentAnnotations(propDef);\n         return (Annotation[])Stream.concat(Stream.of(annotations), genericTypeArgumentAnnotations).toArray((x$0) -> {\n            return new Annotation[x$0];\n         });\n      }\n   }\n\n   private Stream<Annotation> extractGenericTypeArgumentAnnotations(BeanPropertyDefinition propDef) {\n      return (Stream)Optional.ofNullable(propDef).map(BeanPropertyDefinition::getField).map(AnnotatedField::getAnnotated).map(this::getGenericTypeArgumentAnnotations).orElseGet(() -> {\n         return Stream.of();\n      });\n   }\n\n   private Stream<Annotation> getGenericTypeArgumentAnnotations(Field field) {\n      return (Stream)Optional.of(field.getAnnotatedType()).filter((annotatedType) -> {\n         return annotatedType instanceof AnnotatedParameterizedType;\n      }).map((annotatedType) -> {\n         return (AnnotatedParameterizedType)annotatedType;\n      }).map(AnnotatedParameterizedType::getAnnotatedActualTypeArguments).map((types) -> {\n         return Stream.of(types).flatMap((type) -> {\n            return Stream.of(type.getAnnotations());\n         });\n      }).orElseGet(() -> {\n         return Stream.of();\n      });\n   }\n\n   private boolean shouldResolveEnumAsRef(io.swagger.v3.oas.annotations.media.Schema resolvedSchemaAnnotation) {\n      return resolvedSchemaAnnotation != null && resolvedSchemaAnnotation.enumAsRef() || enumsAsRef;\n   }\n\n   protected Type findJsonValueType(BeanDescription beanDesc) {\n      try {\n         Method m = BeanDescription.class.getMethod(\"findJsonValueAccessor\");\n         AnnotatedMember jsonValueMember = (AnnotatedMember)m.invoke(beanDesc);\n         if (jsonValueMember != null) {\n            return jsonValueMember.getType();\n         }\n      } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException var4) {\n         this.LOGGER.warn(\"jackson BeanDescription.findJsonValueAccessor not found, this could lead to inaccurate result, please update jackson to 2.9+\");\n         AnnotatedMethod jsonValueMethod = beanDesc.findJsonValueMethod();\n         if (jsonValueMethod != null) {\n            return jsonValueMethod.getType();\n         }\n      }\n\n      return null;\n   }\n\n   private Schema clone(Schema property) {\n      return AnnotationsUtils.clone(property, this.openapi31);\n   }\n\n   private boolean isSubtype(AnnotatedClass childClass, Class<?> parentClass) {\n      BeanDescription parentDesc = this._mapper.getSerializationConfig().introspectClassAnnotations(parentClass);\n      List<NamedType> subTypes = this._intr.findSubtypes(parentDesc.getClassInfo());\n      if (subTypes == null) {\n         return false;\n      } else {\n         Iterator var5 = subTypes.iterator();\n\n         Class subtypeType;\n         do {\n            if (!var5.hasNext()) {\n               return false;\n            }\n\n            NamedType subtype = (NamedType)var5.next();\n            subtypeType = subtype.getType();\n         } while(!childClass.getRawType().isAssignableFrom(subtypeType));\n\n         return true;\n      }\n   }\n\n   protected boolean _isOptionalType(JavaType propType) {\n      return Arrays.asList(\"com.google.common.base.Optional\", \"java.util.Optional\").contains(propType.getRawClass().getCanonicalName());\n   }\n\n   protected void _addEnumProps(Class<?> propClass, Schema property) {\n      boolean useIndex = this._mapper.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX);\n      boolean useToString = this._mapper.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);\n      Optional<Method> jsonValueMethod = Arrays.stream(propClass.getDeclaredMethods()).filter((m) -> {\n         return m.isAnnotationPresent(JsonValue.class);\n      }).filter((m) -> {\n         return ((JsonValue)m.getAnnotation(JsonValue.class)).value();\n      }).findFirst();\n      Optional<Field> jsonValueField = Arrays.stream(propClass.getDeclaredFields()).filter((f) -> {\n         return f.isAnnotationPresent(JsonValue.class);\n      }).filter((f) -> {\n         return ((JsonValue)f.getAnnotation(JsonValue.class)).value();\n      }).findFirst();\n      jsonValueMethod.ifPresent((m) -> {\n         m.setAccessible(true);\n      });\n      jsonValueField.ifPresent((m) -> {\n         m.setAccessible(true);\n      });\n      Class<Enum<?>> enumClass = propClass;\n      Enum<?>[] enumConstants = (Enum[])propClass.getEnumConstants();\n      if (enumConstants != null) {\n         String[] enumValues = this._intr.findEnumValues(propClass, enumConstants, new String[enumConstants.length]);\n         Enum[] var10 = enumConstants;\n         int var11 = enumConstants.length;\n\n         for(int var12 = 0; var12 < var11; ++var12) {\n            Enum<?> en = var10[var12];\n            Field enumField = ReflectionUtils.findField(en.name(), enumClass);\n            if (null == enumField || !enumField.isAnnotationPresent(Hidden.class)) {\n               String enumValue = enumValues[en.ordinal()];\n               String methodValue = (String)jsonValueMethod.flatMap((m) -> {\n                  return ReflectionUtils.safeInvoke(m, en, new Object[0]);\n               }).map(Object::toString).orElse((Object)null);\n               String fieldValue = (String)jsonValueField.flatMap((f) -> {\n                  return ReflectionUtils.safeGet(f, en);\n               }).map(Object::toString).orElse((Object)null);\n               String n;\n               if (methodValue != null) {\n                  n = methodValue;\n               } else if (fieldValue != null) {\n                  n = fieldValue;\n               } else if (enumValue != null) {\n                  n = enumValue;\n               } else if (useIndex) {\n                  n = String.valueOf(en.ordinal());\n               } else if (useToString) {\n                  n = en.toString();\n               } else {\n                  n = this._intr.findEnumValue(en);\n               }\n\n               if (property instanceof StringSchema) {\n                  StringSchema sp = (StringSchema)property;\n                  sp.addEnumItem(n);\n               }\n            }\n         }\n      }\n\n   }\n\n   protected boolean ignore(Annotated member, XmlAccessorType xmlAccessorTypeAnnotation, String propName, Set<String> propertiesToIgnore) {\n      return this.ignore(member, xmlAccessorTypeAnnotation, propName, propertiesToIgnore, (BeanPropertyDefinition)null);\n   }\n\n   protected boolean hasHiddenAnnotation(Annotated annotated) {\n      return annotated.hasAnnotation(Hidden.class) || annotated.hasAnnotation(io.swagger.v3.oas.annotations.media.Schema.class) && ((io.swagger.v3.oas.annotations.media.Schema)annotated.getAnnotation(io.swagger.v3.oas.annotations.media.Schema.class)).hidden();\n   }\n\n   protected boolean ignore(Annotated member, XmlAccessorType xmlAccessorTypeAnnotation, String propName, Set<String> propertiesToIgnore, BeanPropertyDefinition propDef) {\n      if (propertiesToIgnore.contains(propName)) {\n         return true;\n      } else if (member.hasAnnotation(JsonIgnore.class) && ((JsonIgnore)member.getAnnotation(JsonIgnore.class)).value()) {\n         return true;\n      } else if (this.hasHiddenAnnotation(member)) {\n         return true;\n      } else {\n         if (propDef != null) {\n            if (propDef.hasGetter() && this.hasHiddenAnnotation(propDef.getGetter())) {\n               return true;\n            }\n\n            if (propDef.hasSetter() && this.hasHiddenAnnotation(propDef.getSetter())) {\n               return true;\n            }\n\n            if (propDef.hasConstructorParameter() && this.hasHiddenAnnotation(propDef.getConstructorParameter())) {\n               return true;\n            }\n\n            if (propDef.hasField() && this.hasHiddenAnnotation(propDef.getField())) {\n               return true;\n            }\n         }\n\n         if (xmlAccessorTypeAnnotation == null) {\n            return false;\n         } else {\n            return xmlAccessorTypeAnnotation.value().equals(XmlAccessType.NONE) && !member.hasAnnotation(XmlElement.class) && !member.hasAnnotation(XmlAttribute.class) && !member.hasAnnotation(XmlElementRef.class) && !member.hasAnnotation(XmlElementRefs.class) && !member.hasAnnotation(JsonProperty.class);\n         }\n      }\n   }\n\n   private void handleUnwrapped(List<Schema> props, Schema innerModel, String prefix, String suffix, List<String> requiredProps) {\n      if (StringUtils.isBlank(suffix) && StringUtils.isBlank(prefix)) {\n         if (innerModel.getProperties() != null) {\n            props.addAll(innerModel.getProperties().values());\n            if (innerModel.getRequired() != null) {\n               requiredProps.addAll(innerModel.getRequired());\n            }\n         }\n      } else {\n         if (prefix == null) {\n            prefix = \"\";\n         }\n\n         if (suffix == null) {\n            suffix = \"\";\n         }\n\n         if (innerModel.getProperties() != null) {\n            Iterator var6 = innerModel.getProperties().values().iterator();\n\n            while(var6.hasNext()) {\n               Schema prop = (Schema)var6.next();\n\n               try {\n                  Schema clonedProp = (Schema)Json.mapper().readValue(Json.pretty(prop), Schema.class);\n                  clonedProp.setName(prefix + prop.getName() + suffix);\n                  props.add(clonedProp);\n               } catch (IOException var9) {\n                  this.LOGGER.error(\"Exception cloning property\", var9);\n                  return;\n               }\n            }\n         }\n      }\n\n   }\n\n   protected void applyBeanValidatorAnnotations(BeanPropertyDefinition propDef, Schema property, Annotation[] annotations, Schema parent, boolean applyNotNullAnnotations) {\n      this.applyBeanValidatorAnnotations(property, annotations, parent, applyNotNullAnnotations);\n      if (Objects.nonNull(property.getItems())) {\n         Annotation[] genericTypeArgumentAnnotations = (Annotation[])this.extractGenericTypeArgumentAnnotations(propDef).toArray((x$0) -> {\n            return new Annotation[x$0];\n         });\n         this.applyBeanValidatorAnnotations(property.getItems(), genericTypeArgumentAnnotations, property, applyNotNullAnnotations);\n      }\n\n   }\n\n   protected void applyBeanValidatorAnnotations(Schema property, Annotation[] annotations, Schema parent, boolean applyNotNullAnnotations) {\n      Map<String, Annotation> annos = new HashMap();\n      if (annotations != null) {\n         Annotation[] var6 = annotations;\n         int var7 = annotations.length;\n\n         for(int var8 = 0; var8 < var7; ++var8) {\n            Annotation anno = var6[var8];\n            annos.put(anno.annotationType().getName(), anno);\n         }\n      }\n\n      if (parent != null && annotations != null && applyNotNullAnnotations) {\n         boolean requiredItem = Arrays.stream(annotations).anyMatch((annotation) -> {\n            return NOT_NULL_ANNOTATIONS.contains(annotation.annotationType().getSimpleName());\n         });\n         if (requiredItem) {\n            this.addRequiredItem(parent, property.getName());\n         }\n      }\n\n      if (annos.containsKey(\"javax.validation.constraints.Min\") && (\"integer\".equals(property.getType()) || \"number\".equals(property.getType()))) {\n         Min min = (Min)annos.get(\"javax.validation.constraints.Min\");\n         property.setMinimum(new BigDecimal(min.value()));\n      }\n\n      if (annos.containsKey(\"javax.validation.constraints.Max\") && (\"integer\".equals(property.getType()) || \"number\".equals(property.getType()))) {\n         Max max = (Max)annos.get(\"javax.validation.constraints.Max\");\n         property.setMaximum(new BigDecimal(max.value()));\n      }\n\n      if (annos.containsKey(\"javax.validation.constraints.Size\")) {\n         Size size = (Size)annos.get(\"javax.validation.constraints.Size\");\n         if (!\"integer\".equals(property.getType()) && !\"number\".equals(property.getType())) {\n            if (property instanceof StringSchema) {\n               StringSchema sp = (StringSchema)property;\n               sp.minLength(size.min());\n               sp.maxLength(size.max());\n            } else if (property instanceof io.swagger.v3.oas.models.media.ArraySchema) {\n               io.swagger.v3.oas.models.media.ArraySchema sp = (io.swagger.v3.oas.models.media.ArraySchema)property;\n               sp.setMinItems(size.min());\n               sp.setMaxItems(size.max());\n            }\n         } else {\n            property.setMinimum(new BigDecimal(size.min()));\n            property.setMaximum(new BigDecimal(size.max()));\n         }\n      }\n\n      NumberSchema ap;\n      if (annos.containsKey(\"javax.validation.constraints.DecimalMin\")) {\n         DecimalMin min = (DecimalMin)annos.get(\"javax.validation.constraints.DecimalMin\");\n         if (property instanceof NumberSchema) {\n            ap = (NumberSchema)property;\n            ap.setMinimum(new BigDecimal(min.value()));\n            ap.setExclusiveMinimum(!min.inclusive());\n         }\n      }\n\n      if (annos.containsKey(\"javax.validation.constraints.DecimalMax\")) {\n         DecimalMax max = (DecimalMax)annos.get(\"javax.validation.constraints.DecimalMax\");\n         if (property instanceof NumberSchema) {\n            ap = (NumberSchema)property;\n            ap.setMaximum(new BigDecimal(max.value()));\n            ap.setExclusiveMaximum(!max.inclusive());\n         }\n      }\n\n      if (annos.containsKey(\"javax.validation.constraints.Pattern\")) {\n         Pattern pattern = (Pattern)annos.get(\"javax.validation.constraints.Pattern\");\n         if (property instanceof StringSchema) {\n            property.setPattern(pattern.regexp());\n         }\n\n         if (property.getItems() != null && property.getItems() instanceof StringSchema) {\n            property.getItems().setPattern(pattern.regexp());\n         }\n      }\n\n   }\n\n   private boolean resolveSubtypes(Schema model, BeanDescription bean, ModelConverterContext context, JsonView jsonViewAnnotation) {\n      List<NamedType> types = this._intr.findSubtypes(bean.getClassInfo());\n      if (types == null) {\n         return false;\n      } else {\n         this.removeSelfFromSubTypes(types, bean);\n         this.removeSuperClassAndInterfaceSubTypes(types, bean);\n         int count = false;\n         Class<?> beanClass = bean.getClassInfo().getAnnotated();\n         Iterator var8 = types.iterator();\n\n         while(true) {\n            NamedType subtype;\n            Class subtypeType;\n            do {\n               if (!var8.hasNext()) {\n                  return count;\n               }\n\n               subtype = (NamedType)var8.next();\n               subtypeType = subtype.getType();\n            } while(!beanClass.isAssignableFrom(subtypeType));\n\n            Schema subtypeModel = context.resolve((new AnnotatedType()).type(subtypeType).jsonViewAnnotation(jsonViewAnnotation));\n            if (StringUtils.isBlank(subtypeModel.getName()) || subtypeModel.getName().equals(model.getName())) {\n               subtypeModel.setName(this._typeNameResolver.nameForType(this._mapper.constructType(subtypeType), new Options[]{Options.SKIP_API_MODEL}));\n            }\n\n            ComposedSchema composedSchema = null;\n            if (subtypeModel instanceof ComposedSchema) {\n               composedSchema = (ComposedSchema)subtypeModel;\n            } else {\n               composedSchema = (ComposedSchema)(new ComposedSchema()).title(subtypeModel.getTitle()).name(subtypeModel.getName()).deprecated(subtypeModel.getDeprecated()).additionalProperties(subtypeModel.getAdditionalProperties()).description(subtypeModel.getDescription()).discriminator(subtypeModel.getDiscriminator()).exclusiveMaximum(subtypeModel.getExclusiveMaximum()).exclusiveMinimum(subtypeModel.getExclusiveMinimum()).externalDocs(subtypeModel.getExternalDocs()).format(subtypeModel.getFormat()).maximum(subtypeModel.getMaximum()).maxItems(subtypeModel.getMaxItems()).maxLength(subtypeModel.getMaxLength()).maxProperties(subtypeModel.getMaxProperties()).minimum(subtypeModel.getMinimum()).minItems(subtypeModel.getMinItems()).minLength(subtypeModel.getMinLength()).minProperties(subtypeModel.getMinProperties()).multipleOf(subtypeModel.getMultipleOf()).not(subtypeModel.getNot()).nullable(subtypeModel.getNullable()).pattern(subtypeModel.getPattern()).properties(subtypeModel.getProperties()).readOnly(subtypeModel.getReadOnly()).required(subtypeModel.getRequired()).type(subtypeModel.getType()).uniqueItems(subtypeModel.getUniqueItems()).writeOnly(subtypeModel.getWriteOnly()).xml(subtypeModel.getXml()).extensions(subtypeModel.getExtensions());\n               if (subtypeModel.getExample() != null || subtypeModel.getExampleSetFlag()) {\n                  composedSchema.example(subtypeModel.getExample());\n               }\n\n               composedSchema.setEnum(subtypeModel.getEnum());\n            }\n\n            Schema refSchema = (new Schema()).$ref(\"#/components/schemas/\" + model.getName());\n            if (composedSchema.getAllOf() == null || !composedSchema.getAllOf().contains(refSchema)) {\n               composedSchema.addAllOfItem(refSchema);\n            }\n\n            this.removeParentProperties(composedSchema, model);\n            if (!composedModelPropertiesAsSibling && composedSchema.getAllOf() != null && !composedSchema.getAllOf().isEmpty() && composedSchema.getProperties() != null && !composedSchema.getProperties().isEmpty()) {\n               ObjectSchema propSchema = new ObjectSchema();\n               propSchema.properties(composedSchema.getProperties());\n               composedSchema.setProperties((Map)null);\n               composedSchema.addAllOfItem(propSchema);\n            }\n\n            Class<?> currentType = subtype.getType();\n            if (StringUtils.isNotBlank(composedSchema.getName())) {\n               context.defineModel(composedSchema.getName(), composedSchema, (new AnnotatedType()).type(currentType), (String)null);\n            }\n         }\n      }\n   }\n\n   private void removeSelfFromSubTypes(List<NamedType> types, BeanDescription bean) {\n      Class<?> beanClass = bean.getType().getRawClass();\n      types.removeIf((type) -> {\n         return beanClass.equals(type.getType());\n      });\n   }\n\n   private void removeSuperClassAndInterfaceSubTypes(List<NamedType> types, BeanDescription bean) {\n      Class<?> beanClass = bean.getType().getRawClass();\n      Class<?> superClass = beanClass.getSuperclass();\n      if (superClass != null && !superClass.equals(Object.class)) {\n         this.removeSuperSubTypes(types, superClass);\n      }\n\n      if (!types.isEmpty()) {\n         Class<?>[] superInterfaces = beanClass.getInterfaces();\n         Class[] var6 = superInterfaces;\n         int var7 = superInterfaces.length;\n\n         for(int var8 = 0; var8 < var7; ++var8) {\n            Class<?> superInterface = var6[var8];\n            this.removeSuperSubTypes(types, superInterface);\n            if (types.isEmpty()) {\n               break;\n            }\n         }\n      }\n\n   }\n\n   private void removeSuperSubTypes(List<NamedType> resultTypes, Class<?> superClass) {\n      JavaType superType = this._mapper.constructType(superClass);\n      BeanDescription superBean = this._mapper.getSerializationConfig().introspect(superType);\n      List<NamedType> superTypes = this._intr.findSubtypes(superBean.getClassInfo());\n      if (superTypes != null) {\n         resultTypes.removeAll(superTypes);\n      }\n\n   }\n\n   private void removeParentProperties(Schema child, Schema parent) {\n      Map<String, Schema> baseProps = parent.getProperties();\n      Map<String, Schema> subtypeProps = child.getProperties();\n      if (baseProps != null && subtypeProps != null) {\n         Iterator var5 = baseProps.entrySet().iterator();\n\n         while(var5.hasNext()) {\n            Entry<String, Schema> entry = (Entry)var5.next();\n            if (((Schema)entry.getValue()).equals(subtypeProps.get(entry.getKey()))) {\n               subtypeProps.remove(entry.getKey());\n            }\n         }\n      }\n\n      if (subtypeProps == null || subtypeProps.isEmpty()) {\n         child.setProperties((Map)null);\n      }\n\n   }\n\n   protected List<Class<?>> getComposedSchemaReferencedClasses(Class<?> clazz, Annotation[] ctxAnnotations, io.swagger.v3.oas.annotations.media.Schema schemaAnnotation) {\n      if (schemaAnnotation != null) {\n         Class<?>[] allOf = schemaAnnotation.allOf();\n         Class<?>[] anyOf = schemaAnnotation.anyOf();\n         Class<?>[] oneOf = schemaAnnotation.oneOf();\n         List<Class<?>> parentClasses = (List)Stream.of(allOf, anyOf, oneOf).flatMap(Stream::of).distinct().filter((c) -> {\n            return !this.shouldIgnoreClass(c);\n         }).filter((c) -> {\n            return !c.equals(Void.class);\n         }).collect(Collectors.toList());\n         if (!parentClasses.isEmpty()) {\n            return parentClasses;\n         }\n      }\n\n      return null;\n   }\n\n   protected String resolveDescription(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && !\"\".equals(schema.description()) ? schema.description() : null;\n   }\n\n   protected String resolveTitle(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && StringUtils.isNotBlank(schema.title()) ? schema.title() : null;\n   }\n\n   protected String resolveFormat(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && StringUtils.isNotBlank(schema.format()) ? schema.format() : null;\n   }\n\n   protected Map<String, Schema> resolvePatternProperties(JavaType a, Annotation[] annotations, ModelConverterContext context) {\n      Map<String, PatternProperty> propList = new LinkedHashMap();\n      PatternProperties props = (PatternProperties)a.getRawClass().getAnnotation(PatternProperties.class);\n      int var8;\n      PatternProperty prop;\n      if (props != null && props.value().length > 0) {\n         PatternProperty[] var6 = props.value();\n         int var7 = var6.length;\n\n         for(var8 = 0; var8 < var7; ++var8) {\n            prop = var6[var8];\n            propList.put(prop.regex(), prop);\n         }\n      }\n\n      PatternProperty singleProp = (PatternProperty)a.getRawClass().getAnnotation(PatternProperty.class);\n      if (singleProp != null) {\n         propList.put(singleProp.regex(), singleProp);\n      }\n\n      props = (PatternProperties)AnnotationsUtils.getAnnotation(PatternProperties.class, annotations);\n      if (props != null && props.value().length > 0) {\n         PatternProperty[] var15 = props.value();\n         var8 = var15.length;\n\n         for(int var18 = 0; var18 < var8; ++var18) {\n            PatternProperty prop = var15[var18];\n            propList.put(prop.regex(), prop);\n         }\n      }\n\n      singleProp = (PatternProperty)AnnotationsUtils.getAnnotation(PatternProperty.class, annotations);\n      if (singleProp != null) {\n         propList.put(singleProp.regex(), singleProp);\n      }\n\n      if (propList.isEmpty()) {\n         return null;\n      } else {\n         Map<String, Schema> patternProperties = new LinkedHashMap();\n         Iterator var17 = propList.values().iterator();\n\n         while(var17.hasNext()) {\n            prop = (PatternProperty)var17.next();\n            String key = prop.regex();\n            if (!StringUtils.isBlank(key)) {\n               Annotation[] propAnnotations = new Annotation[]{prop.schema(), prop.array()};\n               AnnotatedType propType = (new AnnotatedType()).type(String.class).ctxAnnotations(propAnnotations).resolveAsRef(true);\n               Schema resolvedPropSchema = context.resolve(propType);\n               if (resolvedPropSchema != null) {\n                  patternProperties.put(key, resolvedPropSchema);\n               }\n            }\n         }\n\n         return patternProperties;\n      }\n   }\n\n   protected Map<String, Schema> resolveSchemaProperties(JavaType a, Annotation[] annotations, ModelConverterContext context) {\n      Map<String, SchemaProperty> propList = new LinkedHashMap();\n      SchemaProperties props = (SchemaProperties)a.getRawClass().getAnnotation(SchemaProperties.class);\n      int var8;\n      SchemaProperty prop;\n      if (props != null && props.value().length > 0) {\n         SchemaProperty[] var6 = props.value();\n         int var7 = var6.length;\n\n         for(var8 = 0; var8 < var7; ++var8) {\n            prop = var6[var8];\n            propList.put(prop.name(), prop);\n         }\n      }\n\n      SchemaProperty singleProp = (SchemaProperty)a.getRawClass().getAnnotation(SchemaProperty.class);\n      if (singleProp != null) {\n         propList.put(singleProp.name(), singleProp);\n      }\n\n      props = (SchemaProperties)AnnotationsUtils.getAnnotation(SchemaProperties.class, annotations);\n      if (props != null && props.value().length > 0) {\n         SchemaProperty[] var15 = props.value();\n         var8 = var15.length;\n\n         for(int var18 = 0; var18 < var8; ++var18) {\n            SchemaProperty prop = var15[var18];\n            propList.put(prop.name(), prop);\n         }\n      }\n\n      singleProp = (SchemaProperty)AnnotationsUtils.getAnnotation(SchemaProperty.class, annotations);\n      if (singleProp != null) {\n         propList.put(singleProp.name(), singleProp);\n      }\n\n      if (propList.isEmpty()) {\n         return null;\n      } else {\n         Map<String, Schema> schemaProperties = new LinkedHashMap();\n         Iterator var17 = propList.values().iterator();\n\n         while(var17.hasNext()) {\n            prop = (SchemaProperty)var17.next();\n            String key = prop.name();\n            if (!StringUtils.isBlank(key)) {\n               Annotation[] propAnnotations = new Annotation[]{prop.schema(), prop.array()};\n               AnnotatedType propType = (new AnnotatedType()).type(String.class).ctxAnnotations(propAnnotations).resolveAsRef(true);\n               Schema resolvedPropSchema = context.resolve(propType);\n               if (resolvedPropSchema != null) {\n                  schemaProperties.put(key, resolvedPropSchema);\n               }\n            }\n         }\n\n         return schemaProperties;\n      }\n   }\n\n   protected Map<String, Schema> resolveDependentSchemas(JavaType a, Annotation[] annotations, ModelConverterContext context, Components components, JsonView jsonViewAnnotation, boolean openapi31) {\n      Map<String, DependentSchema> dependentSchemaMap = new LinkedHashMap();\n      DependentSchemas dependentSchemasAnnotation = (DependentSchemas)a.getRawClass().getAnnotation(DependentSchemas.class);\n      int var11;\n      DependentSchema dependentSchemaAnnotation;\n      if (dependentSchemasAnnotation != null && dependentSchemasAnnotation.value().length > 0) {\n         DependentSchema[] var9 = dependentSchemasAnnotation.value();\n         int var10 = var9.length;\n\n         for(var11 = 0; var11 < var10; ++var11) {\n            dependentSchemaAnnotation = var9[var11];\n            dependentSchemaMap.put(dependentSchemaAnnotation.name(), dependentSchemaAnnotation);\n         }\n      }\n\n      DependentSchema singleDependentSchema = (DependentSchema)a.getRawClass().getAnnotation(DependentSchema.class);\n      if (singleDependentSchema != null) {\n         dependentSchemaMap.put(singleDependentSchema.name(), singleDependentSchema);\n      }\n\n      dependentSchemasAnnotation = (DependentSchemas)AnnotationsUtils.getAnnotation(DependentSchemas.class, annotations);\n      if (dependentSchemasAnnotation != null && dependentSchemasAnnotation.value().length > 0) {\n         DependentSchema[] var18 = dependentSchemasAnnotation.value();\n         var11 = var18.length;\n\n         for(int var21 = 0; var21 < var11; ++var21) {\n            DependentSchema dependentSchemaAnnotation = var18[var21];\n            dependentSchemaMap.put(dependentSchemaAnnotation.name(), dependentSchemaAnnotation);\n         }\n      }\n\n      singleDependentSchema = (DependentSchema)AnnotationsUtils.getAnnotation(DependentSchema.class, annotations);\n      if (singleDependentSchema != null) {\n         dependentSchemaMap.put(singleDependentSchema.name(), singleDependentSchema);\n      }\n\n      if (dependentSchemaMap.isEmpty()) {\n         return null;\n      } else {\n         Map<String, Schema> dependentSchemas = new LinkedHashMap();\n         Iterator var20 = dependentSchemaMap.values().iterator();\n\n         while(var20.hasNext()) {\n            dependentSchemaAnnotation = (DependentSchema)var20.next();\n            String name = dependentSchemaAnnotation.name();\n            if (!StringUtils.isBlank(name)) {\n               Annotation[] var10000 = new Annotation[]{dependentSchemaAnnotation.schema(), dependentSchemaAnnotation.array()};\n               Schema existingSchema = null;\n               Optional<Schema> resolvedPropSchema = AnnotationsUtils.getSchemaFromAnnotation(dependentSchemaAnnotation.schema(), components, jsonViewAnnotation, openapi31, (Schema)null, context);\n               if (resolvedPropSchema.isPresent()) {\n                  existingSchema = (Schema)resolvedPropSchema.get();\n                  dependentSchemas.put(name, existingSchema);\n               }\n\n               resolvedPropSchema = AnnotationsUtils.getArraySchema(dependentSchemaAnnotation.array(), components, jsonViewAnnotation, openapi31, existingSchema);\n               if (resolvedPropSchema.isPresent()) {\n                  dependentSchemas.put(name, (Schema)resolvedPropSchema.get());\n               }\n            }\n         }\n\n         return dependentSchemas;\n      }\n   }\n\n   protected Object resolveDefaultValue(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      if (schema != null && !schema.defaultValue().isEmpty()) {\n         try {\n            ObjectMapper mapper = ObjectMapperFactory.buildStrictGenericObjectMapper();\n            return mapper.readTree(schema.defaultValue());\n         } catch (IOException var9) {\n            return schema.defaultValue();\n         }\n      } else if (a == null) {\n         return null;\n      } else {\n         XmlElement elem = (XmlElement)a.getAnnotation(XmlElement.class);\n         if (elem == null && annotations != null) {\n            Annotation[] var5 = annotations;\n            int var6 = annotations.length;\n\n            for(int var7 = 0; var7 < var6; ++var7) {\n               Annotation ann = var5[var7];\n               if (ann instanceof XmlElement) {\n                  elem = (XmlElement)ann;\n                  break;\n               }\n            }\n         }\n\n         return elem != null && !elem.defaultValue().isEmpty() && !\"\\u0000\".equals(elem.defaultValue()) ? elem.defaultValue() : null;\n      }\n   }\n\n   protected Object resolveExample(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      if (schema != null && !schema.example().isEmpty()) {\n         try {\n            ObjectMapper mapper = ObjectMapperFactory.buildStrictGenericObjectMapper();\n            return mapper.readTree(schema.example());\n         } catch (IOException var5) {\n            return schema.example();\n         }\n      } else {\n         return null;\n      }\n   }\n\n   protected RequiredMode resolveRequiredMode(io.swagger.v3.oas.annotations.media.Schema schema) {\n      if (schema != null && !schema.requiredMode().equals(RequiredMode.AUTO)) {\n         return schema.requiredMode();\n      } else {\n         return schema != null && schema.required() ? RequiredMode.REQUIRED : RequiredMode.AUTO;\n      }\n   }\n\n   protected AccessMode resolveAccessMode(BeanPropertyDefinition propDef, JavaType type, io.swagger.v3.oas.annotations.media.Schema schema) {\n      if (schema != null && !schema.accessMode().equals(AccessMode.AUTO)) {\n         return schema.accessMode();\n      } else if (schema != null && schema.readOnly()) {\n         return AccessMode.READ_ONLY;\n      } else if (schema != null && schema.writeOnly()) {\n         return AccessMode.WRITE_ONLY;\n      } else if (propDef == null) {\n         return null;\n      } else {\n         Access access = null;\n         if (propDef instanceof POJOPropertyBuilder) {\n            access = ((POJOPropertyBuilder)propDef).findAccess();\n         }\n\n         boolean hasGetter = propDef.hasGetter();\n         boolean hasSetter = propDef.hasSetter();\n         boolean hasConstructorParameter = propDef.hasConstructorParameter();\n         boolean hasField = propDef.hasField();\n         if (access == null) {\n            BeanDescription beanDesc = this._mapper.getDeserializationConfig().introspect(type);\n            List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n            Iterator var11 = properties.iterator();\n\n            while(var11.hasNext()) {\n               BeanPropertyDefinition prop = (BeanPropertyDefinition)var11.next();\n               if (StringUtils.isNotBlank(prop.getInternalName()) && prop.getInternalName().equals(propDef.getInternalName())) {\n                  if (prop instanceof POJOPropertyBuilder) {\n                     access = ((POJOPropertyBuilder)prop).findAccess();\n                  }\n\n                  hasGetter = hasGetter || prop.hasGetter();\n                  hasSetter = hasSetter || prop.hasSetter();\n                  hasConstructorParameter = hasConstructorParameter || prop.hasConstructorParameter();\n                  hasField = hasField || prop.hasField();\n                  break;\n               }\n            }\n         }\n\n         if (access != null) {\n            switch(access) {\n            case AUTO:\n               return AccessMode.AUTO;\n            case READ_ONLY:\n               return AccessMode.READ_ONLY;\n            case READ_WRITE:\n               return AccessMode.READ_WRITE;\n            case WRITE_ONLY:\n               return AccessMode.WRITE_ONLY;\n            default:\n               return AccessMode.AUTO;\n            }\n         } else {\n            return hasGetter || hasField || !hasConstructorParameter && !hasSetter ? null : AccessMode.WRITE_ONLY;\n         }\n      }\n   }\n\n   protected Boolean resolveReadOnly(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      if (schema != null && schema.accessMode().equals(AccessMode.READ_ONLY)) {\n         return true;\n      } else if (schema != null && schema.accessMode().equals(AccessMode.WRITE_ONLY)) {\n         return null;\n      } else if (schema != null && schema.accessMode().equals(AccessMode.READ_WRITE)) {\n         return null;\n      } else {\n         return schema != null && schema.readOnly() ? schema.readOnly() : null;\n      }\n   }\n\n   protected Boolean resolveNullable(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && schema.nullable() ? schema.nullable() : null;\n   }\n\n   protected BigDecimal resolveMultipleOf(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && schema.multipleOf() != 0.0D ? new BigDecimal(schema.multipleOf()) : null;\n   }\n\n   protected Integer resolveMaxLength(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && schema.maxLength() != Integer.MAX_VALUE && schema.maxLength() > 0 ? schema.maxLength() : null;\n   }\n\n   protected Integer resolveMinLength(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && schema.minLength() > 0 ? schema.minLength() : null;\n   }\n\n   protected BigDecimal resolveMinimum(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      if (schema != null && NumberUtils.isCreatable(schema.minimum())) {\n         String filteredMinimum = schema.minimum().replace(\",\", \"\");\n         return new BigDecimal(filteredMinimum);\n      } else {\n         return null;\n      }\n   }\n\n   protected BigDecimal resolveMaximum(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      if (schema != null && NumberUtils.isCreatable(schema.maximum())) {\n         String filteredMaximum = schema.maximum().replace(\",\", \"\");\n         return new BigDecimal(filteredMaximum);\n      } else {\n         return null;\n      }\n   }\n\n   protected Boolean resolveExclusiveMinimum(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && schema.exclusiveMinimum() ? schema.exclusiveMinimum() : null;\n   }\n\n   protected Boolean resolveExclusiveMaximum(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && schema.exclusiveMaximum() ? schema.exclusiveMaximum() : null;\n   }\n\n   protected String resolvePattern(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && StringUtils.isNotBlank(schema.pattern()) ? schema.pattern() : null;\n   }\n\n   protected Integer resolveMinProperties(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && schema.minProperties() > 0 ? schema.minProperties() : null;\n   }\n\n   protected Integer resolveMaxProperties(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && schema.maxProperties() > 0 ? schema.maxProperties() : null;\n   }\n\n   protected List<String> resolveRequiredProperties(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && schema.requiredProperties() != null && schema.requiredProperties().length > 0 && StringUtils.isNotBlank(schema.requiredProperties()[0]) ? Arrays.asList(schema.requiredProperties()) : null;\n   }\n\n   protected Boolean resolveWriteOnly(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      if (schema != null && schema.accessMode().equals(AccessMode.READ_ONLY)) {\n         return null;\n      } else if (schema != null && schema.accessMode().equals(AccessMode.WRITE_ONLY)) {\n         return true;\n      } else if (schema != null && schema.accessMode().equals(AccessMode.READ_WRITE)) {\n         return null;\n      } else {\n         return schema != null && schema.writeOnly() ? schema.writeOnly() : null;\n      }\n   }\n\n   protected ExternalDocumentation resolveExternalDocumentation(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      ExternalDocumentation external = null;\n      if (a != null) {\n         io.swagger.v3.oas.annotations.ExternalDocumentation externalDocumentation = (io.swagger.v3.oas.annotations.ExternalDocumentation)a.getAnnotation(io.swagger.v3.oas.annotations.ExternalDocumentation.class);\n         external = this.resolveExternalDocumentation(externalDocumentation);\n      }\n\n      if (external == null && schema != null) {\n         external = this.resolveExternalDocumentation(schema.externalDocs());\n      }\n\n      return external;\n   }\n\n   protected ExternalDocumentation resolveExternalDocumentation(io.swagger.v3.oas.annotations.ExternalDocumentation externalDocumentation) {\n      if (externalDocumentation == null) {\n         return null;\n      } else {\n         boolean isEmpty = true;\n         ExternalDocumentation external = new ExternalDocumentation();\n         if (StringUtils.isNotBlank(externalDocumentation.description())) {\n            isEmpty = false;\n            external.setDescription(externalDocumentation.description());\n         }\n\n         if (StringUtils.isNotBlank(externalDocumentation.url())) {\n            isEmpty = false;\n            external.setUrl(externalDocumentation.url());\n         }\n\n         return isEmpty ? null : external;\n      }\n   }\n\n   protected Boolean resolveDeprecated(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && schema.deprecated() ? schema.deprecated() : null;\n   }\n\n   protected List<String> resolveAllowableValues(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && schema.allowableValues() != null && schema.allowableValues().length > 0 ? Arrays.asList(schema.allowableValues()) : null;\n   }\n\n   protected Map<String, Object> resolveExtensions(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && schema.extensions() != null && schema.extensions().length > 0 ? AnnotationsUtils.getExtensions(this.openapi31, schema.extensions()) : null;\n   }\n\n   protected void resolveDiscriminatorProperty(JavaType type, ModelConverterContext context, Schema model) {\n      JsonTypeInfo typeInfo = (JsonTypeInfo)type.getRawClass().getDeclaredAnnotation(JsonTypeInfo.class);\n      if (typeInfo != null) {\n         String typeInfoProp = typeInfo.property();\n         if (StringUtils.isNotBlank(typeInfoProp)) {\n            Schema modelToUpdate = model;\n            if (StringUtils.isNotBlank(model.get$ref())) {\n               modelToUpdate = (Schema)context.getDefinedModels().get(model.get$ref().substring(21));\n            }\n\n            if (modelToUpdate.getProperties() == null || !modelToUpdate.getProperties().keySet().contains(typeInfoProp)) {\n               Schema discriminatorSchema = (new StringSchema()).name(typeInfoProp);\n               modelToUpdate.addProperties(typeInfoProp, discriminatorSchema);\n               if (modelToUpdate.getRequired() == null || !modelToUpdate.getRequired().contains(typeInfoProp)) {\n                  modelToUpdate.addRequiredItem(typeInfoProp);\n               }\n            }\n         }\n      }\n\n   }\n\n   protected Schema resolveWrapping(JavaType type, ModelConverterContext context, Schema model) {\n      JsonTypeInfo typeInfo = (JsonTypeInfo)type.getRawClass().getDeclaredAnnotation(JsonTypeInfo.class);\n      if (typeInfo != null) {\n         Id id = typeInfo.use();\n         As as = typeInfo.include();\n         if (As.WRAPPER_OBJECT.equals(as)) {\n            String name = model.getName();\n            if (Id.CLASS.equals(id)) {\n               name = type.getRawClass().getName();\n            }\n\n            JsonTypeName typeName = (JsonTypeName)type.getRawClass().getDeclaredAnnotation(JsonTypeName.class);\n            if (Id.NAME.equals(id) && typeName != null) {\n               name = typeName.value();\n            }\n\n            if (Id.NAME.equals(id) && name == null) {\n               name = type.getRawClass().getSimpleName();\n            }\n\n            Schema wrapperSchema = new ObjectSchema();\n            wrapperSchema.name(model.getName());\n            wrapperSchema.addProperties(name, model);\n            return wrapperSchema;\n         }\n      }\n\n      return model;\n   }\n\n   protected Discriminator resolveDiscriminator(JavaType type, ModelConverterContext context) {\n      io.swagger.v3.oas.annotations.media.Schema declaredSchemaAnnotation = AnnotationsUtils.getSchemaDeclaredAnnotation(type.getRawClass());\n      String disc = declaredSchemaAnnotation == null ? \"\" : declaredSchemaAnnotation.discriminatorProperty();\n      if (disc.isEmpty()) {\n         JsonTypeInfo typeInfo = (JsonTypeInfo)type.getRawClass().getDeclaredAnnotation(JsonTypeInfo.class);\n         if (typeInfo != null) {\n            disc = typeInfo.property();\n         }\n      }\n\n      if (disc.isEmpty()) {\n         return null;\n      } else {\n         Discriminator discriminator = (new Discriminator()).propertyName(disc);\n         if (declaredSchemaAnnotation != null) {\n            DiscriminatorMapping[] mappings = declaredSchemaAnnotation.discriminatorMapping();\n            if (mappings != null && mappings.length > 0) {\n               DiscriminatorMapping[] var7 = mappings;\n               int var8 = mappings.length;\n\n               for(int var9 = 0; var9 < var8; ++var9) {\n                  DiscriminatorMapping mapping = var7[var9];\n                  if (!mapping.value().isEmpty() && !mapping.schema().equals(Void.class)) {\n                     discriminator.mapping(mapping.value(), RefUtils.constructRef(context.resolve((new AnnotatedType()).type(mapping.schema())).getName()));\n                  }\n               }\n            }\n         }\n\n         return discriminator;\n      }\n   }\n\n   protected XML resolveXml(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      XmlRootElement rootAnnotation = null;\n      XmlSchema xmlSchema = null;\n      if (a != null) {\n         rootAnnotation = (XmlRootElement)a.getAnnotation(XmlRootElement.class);\n         Class<?> rawType = a.getRawType();\n         if (rawType != null) {\n            Package aPackage = rawType.getPackage();\n            if (aPackage != null) {\n               xmlSchema = (XmlSchema)aPackage.getAnnotation(XmlSchema.class);\n            }\n         }\n      }\n\n      if (rootAnnotation == null && annotations != null) {\n         Annotation[] var10 = annotations;\n         int var12 = annotations.length;\n\n         for(int var8 = 0; var8 < var12; ++var8) {\n            Annotation ann = var10[var8];\n            if (ann instanceof XmlRootElement) {\n               rootAnnotation = (XmlRootElement)ann;\n               break;\n            }\n         }\n      }\n\n      if (rootAnnotation != null && !\"\".equals(rootAnnotation.name()) && !\"##default\".equals(rootAnnotation.name())) {\n         XML xml = (new XML()).name(rootAnnotation.name());\n         if (xmlSchema != null && this.isNonTrivialXmlNamespace(xmlSchema.namespace())) {\n            xml.namespace(xmlSchema.namespace());\n         }\n\n         if (this.isNonTrivialXmlNamespace(rootAnnotation.namespace())) {\n            xml.namespace(rootAnnotation.namespace());\n         }\n\n         return xml;\n      } else {\n         return null;\n      }\n   }\n\n   private boolean isNonTrivialXmlNamespace(String namespace) {\n      return namespace != null && !\"\".equals(namespace) && !\"##default\".equals(namespace);\n   }\n\n   protected Set<String> resolveIgnoredProperties(Annotations a, Annotation[] annotations) {\n      Set<String> propertiesToIgnore = new HashSet();\n      JsonIgnoreProperties ignoreProperties = (JsonIgnoreProperties)a.get(JsonIgnoreProperties.class);\n      if (ignoreProperties != null && !ignoreProperties.allowGetters()) {\n         propertiesToIgnore.addAll(Arrays.asList(ignoreProperties.value()));\n      }\n\n      propertiesToIgnore.addAll(this.resolveIgnoredProperties(annotations));\n      return propertiesToIgnore;\n   }\n\n   protected Set<String> resolveIgnoredProperties(Annotation[] annotations) {\n      Set<String> propertiesToIgnore = new HashSet();\n      if (annotations != null) {\n         Annotation[] var3 = annotations;\n         int var4 = annotations.length;\n\n         for(int var5 = 0; var5 < var4; ++var5) {\n            Annotation annotation = var3[var5];\n            if (annotation instanceof JsonIgnoreProperties && !((JsonIgnoreProperties)annotation).allowGetters()) {\n               propertiesToIgnore.addAll(Arrays.asList(((JsonIgnoreProperties)annotation).value()));\n               break;\n            }\n         }\n      }\n\n      return propertiesToIgnore;\n   }\n\n   protected Integer resolveMinItems(AnnotatedType a, ArraySchema arraySchema) {\n      return arraySchema != null && arraySchema.minItems() < Integer.MAX_VALUE ? arraySchema.minItems() : null;\n   }\n\n   protected Integer resolveMaxItems(AnnotatedType a, ArraySchema arraySchema) {\n      return arraySchema != null && arraySchema.maxItems() > 0 ? arraySchema.maxItems() : null;\n   }\n\n   protected Boolean resolveUniqueItems(AnnotatedType a, ArraySchema arraySchema) {\n      return arraySchema != null && arraySchema.uniqueItems() ? arraySchema.uniqueItems() : null;\n   }\n\n   protected Map<String, Object> resolveExtensions(AnnotatedType a, ArraySchema arraySchema) {\n      return arraySchema != null && arraySchema.extensions() != null && arraySchema.extensions().length > 0 ? AnnotationsUtils.getExtensions(this.openapi31, arraySchema.extensions()) : null;\n   }\n\n   protected Integer resolveMaxContains(AnnotatedType a, ArraySchema arraySchema) {\n      return arraySchema != null && arraySchema.maxContains() > 0 ? arraySchema.maxContains() : null;\n   }\n\n   protected Integer resolveMinContains(AnnotatedType a, ArraySchema arraySchema) {\n      return arraySchema != null && arraySchema.minContains() > 0 ? arraySchema.minContains() : null;\n   }\n\n   protected BigDecimal resolveExclusiveMaximumValue(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && schema.exclusiveMaximumValue() > 0 ? new BigDecimal(schema.exclusiveMaximumValue()) : null;\n   }\n\n   protected BigDecimal resolveExclusiveMinimumValue(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && schema.exclusiveMinimumValue() > 0 ? new BigDecimal(schema.exclusiveMinimumValue()) : null;\n   }\n\n   protected String resolveId(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && StringUtils.isNotBlank(schema.$id()) ? schema.$id() : null;\n   }\n\n   protected String resolve$schema(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && StringUtils.isNotBlank(schema.$schema()) ? schema.$schema() : null;\n   }\n\n   protected String resolve$anchor(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && StringUtils.isNotBlank(schema.$anchor()) ? schema.$anchor() : null;\n   }\n\n   protected String resolve$comment(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && StringUtils.isNotBlank(schema.$comment()) ? schema.$comment() : null;\n   }\n\n   protected String resolve$vocabulary(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && StringUtils.isNotBlank(schema.$vocabulary()) ? schema.$vocabulary() : null;\n   }\n\n   protected String resolve$dynamicAnchor(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && StringUtils.isNotBlank(schema.$dynamicAnchor()) ? schema.$dynamicAnchor() : null;\n   }\n\n   protected String resolveContentEncoding(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && StringUtils.isNotBlank(schema.contentEncoding()) ? schema.contentEncoding() : null;\n   }\n\n   protected String resolveContentMediaType(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && StringUtils.isNotBlank(schema.contentMediaType()) ? schema.contentMediaType() : null;\n   }\n\n   protected void resolveContains(AnnotatedType annotatedType, io.swagger.v3.oas.models.media.ArraySchema arraySchema, ArraySchema arraySchemaAnnotation) {\n      io.swagger.v3.oas.annotations.media.Schema containsAnnotation = arraySchemaAnnotation.contains();\n      Schema contains = new Schema();\n      if (containsAnnotation.types().length > 0) {\n         String[] var6 = containsAnnotation.types();\n         int var7 = var6.length;\n\n         for(int var8 = 0; var8 < var7; ++var8) {\n            String type = var6[var8];\n            contains.addType(type);\n         }\n      }\n\n      arraySchema.setContains(contains);\n      this.resolveSchemaMembers(contains, (Annotated)null, (Annotation[])null, (io.swagger.v3.oas.annotations.media.Schema)containsAnnotation);\n      Integer maxContains = this.resolveMaxContains(annotatedType, arraySchemaAnnotation);\n      if (maxContains != null) {\n         arraySchema.setMaxContains(maxContains);\n      }\n\n      Integer minContains = this.resolveMinContains(annotatedType, arraySchemaAnnotation);\n      if (minContains != null) {\n         arraySchema.setMinContains(minContains);\n      }\n\n   }\n\n   protected void resolveUnevaluatedItems(AnnotatedType annotatedType, io.swagger.v3.oas.models.media.ArraySchema arraySchema, ArraySchema arraySchemaAnnotation) {\n      io.swagger.v3.oas.annotations.media.Schema unevaluatedItemsAnnotation = arraySchemaAnnotation.unevaluatedItems();\n      Schema unevaluatedItems = new Schema();\n      if (StringUtils.isNotBlank(unevaluatedItemsAnnotation.type())) {\n         unevaluatedItems.addType(unevaluatedItemsAnnotation.type());\n      }\n\n      if (unevaluatedItemsAnnotation.types().length > 0) {\n         String[] var6 = unevaluatedItemsAnnotation.types();\n         int var7 = var6.length;\n\n         for(int var8 = 0; var8 < var7; ++var8) {\n            String type = var6[var8];\n            unevaluatedItems.addType(type);\n         }\n      }\n\n      arraySchema.setUnevaluatedItems(unevaluatedItems);\n      this.resolveSchemaMembers(unevaluatedItems, (Annotated)null, (Annotation[])null, (io.swagger.v3.oas.annotations.media.Schema)unevaluatedItemsAnnotation);\n   }\n\n   protected String resolveConst(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      return schema != null && StringUtils.isNotBlank(schema._const()) ? schema._const() : null;\n   }\n\n   protected Map<String, List<String>> resolveDependentRequired(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schema) {\n      if (schema.dependentRequiredMap().length == 0) {\n         return null;\n      } else {\n         Map<String, List<String>> dependentRequiredMap = new HashMap();\n         DependentRequired[] var5 = schema.dependentRequiredMap();\n         int var6 = var5.length;\n\n         for(int var7 = 0; var7 < var6; ++var7) {\n            DependentRequired dependentRequired = var5[var7];\n            String name = dependentRequired.name();\n            if (dependentRequired.value().length != 0) {\n               List<String> values = Arrays.asList(dependentRequired.value());\n               dependentRequiredMap.put(name, values);\n            }\n         }\n\n         return dependentRequiredMap;\n      }\n   }\n\n   protected Map<String, Schema> resolveDependentSchemas(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schemaAnnotation, AnnotatedType annotatedType, ModelConverterContext context, Iterator<ModelConverter> next) {\n      if (schemaAnnotation.dependentSchemas().length == 0) {\n         return null;\n      } else {\n         Map<String, Schema> dependentSchemas = new HashMap();\n         StringToClassMapItem[] var8 = schemaAnnotation.dependentSchemas();\n         int var9 = var8.length;\n\n         for(int var10 = 0; var10 < var9; ++var10) {\n            StringToClassMapItem mapItem = var8[var10];\n            String key = mapItem.key();\n            if (mapItem.value() != null && !Void.class.equals(mapItem.value())) {\n               Schema schema = this.resolve(new AnnotatedType(mapItem.value()), context, next);\n               if (schema != null) {\n                  dependentSchemas.put(key, schema);\n               }\n            }\n         }\n\n         return dependentSchemas;\n      }\n   }\n\n   protected Map<String, Schema> resolvePatternProperties(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schemaAnnotation, AnnotatedType annotatedType, ModelConverterContext context, Iterator<ModelConverter> next) {\n      if (schemaAnnotation.patternProperties().length == 0) {\n         return null;\n      } else {\n         Map<String, Schema> patternPropertyMap = new HashMap();\n         StringToClassMapItem[] var8 = schemaAnnotation.patternProperties();\n         int var9 = var8.length;\n\n         for(int var10 = 0; var10 < var9; ++var10) {\n            StringToClassMapItem patternPropertyItem = var8[var10];\n            String key = patternPropertyItem.key();\n            if (!Void.class.equals(patternPropertyItem.value())) {\n               Schema schema = this.resolve(new AnnotatedType(patternPropertyItem.value()), context, next);\n               if (schema != null) {\n                  patternPropertyMap.put(key, schema);\n               }\n            }\n         }\n\n         return patternPropertyMap;\n      }\n   }\n\n   protected Map<String, Schema> resolveProperties(Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schemaAnnotation, AnnotatedType annotatedType, ModelConverterContext context, Iterator<ModelConverter> next) {\n      if (schemaAnnotation.properties().length == 0) {\n         return null;\n      } else {\n         Map<String, Schema> propertyMap = new HashMap();\n         StringToClassMapItem[] var8 = schemaAnnotation.properties();\n         int var9 = var8.length;\n\n         for(int var10 = 0; var10 < var9; ++var10) {\n            StringToClassMapItem propertyItem = var8[var10];\n            String key = propertyItem.key();\n            if (!Void.class.equals(propertyItem.value())) {\n               Schema schema = this.resolve(new AnnotatedType(propertyItem.value()), context, next);\n               if (schema != null) {\n                  propertyMap.put(key, schema);\n               }\n            }\n         }\n\n         return propertyMap;\n      }\n   }\n\n   protected void resolveSchemaMembers(Schema schema, AnnotatedType annotatedType) {\n      this.resolveSchemaMembers(schema, (AnnotatedType)annotatedType, (ModelConverterContext)null, (Iterator)null);\n   }\n\n   protected void resolveSchemaMembers(Schema schema, AnnotatedType annotatedType, ModelConverterContext context, Iterator<ModelConverter> next) {\n      JavaType type;\n      if (annotatedType.getType() instanceof JavaType) {\n         type = (JavaType)annotatedType.getType();\n      } else {\n         type = this._mapper.constructType(annotatedType.getType());\n      }\n\n      Annotation resolvedSchemaOrArrayAnnotation = AnnotationsUtils.mergeSchemaAnnotations(annotatedType.getCtxAnnotations(), type);\n      io.swagger.v3.oas.annotations.media.Schema schemaAnnotation = resolvedSchemaOrArrayAnnotation == null ? null : (resolvedSchemaOrArrayAnnotation instanceof ArraySchema ? ((ArraySchema)resolvedSchemaOrArrayAnnotation).schema() : (io.swagger.v3.oas.annotations.media.Schema)resolvedSchemaOrArrayAnnotation);\n      BeanDescription beanDesc = this._mapper.getSerializationConfig().introspect(type);\n      Annotated a = beanDesc.getClassInfo();\n      Annotation[] annotations = annotatedType.getCtxAnnotations();\n      this.resolveSchemaMembers(schema, (Annotated)a, (Annotation[])annotations, (io.swagger.v3.oas.annotations.media.Schema)schemaAnnotation);\n      if (this.openapi31 && schema != null && schemaAnnotation != null) {\n         Schema additionalPropertiesSchema;\n         if (!Void.class.equals(schemaAnnotation.contentSchema())) {\n            additionalPropertiesSchema = this.resolve(new AnnotatedType(schemaAnnotation.contentSchema()), context, next);\n            additionalPropertiesSchema = this.buildRefSchemaIfObject(additionalPropertiesSchema, context);\n            schema.setContentSchema(additionalPropertiesSchema);\n         }\n\n         if (!Void.class.equals(schemaAnnotation.propertyNames())) {\n            additionalPropertiesSchema = this.resolve(new AnnotatedType(schemaAnnotation.propertyNames()), context, next);\n            additionalPropertiesSchema = this.buildRefSchemaIfObject(additionalPropertiesSchema, context);\n            schema.setPropertyNames(additionalPropertiesSchema);\n         }\n\n         if (!Void.class.equals(schemaAnnotation._if())) {\n            additionalPropertiesSchema = this.resolve(new AnnotatedType(schemaAnnotation._if()), context, next);\n            additionalPropertiesSchema = this.buildRefSchemaIfObject(additionalPropertiesSchema, context);\n            schema.setIf(additionalPropertiesSchema);\n         }\n\n         if (!Void.class.equals(schemaAnnotation._else())) {\n            additionalPropertiesSchema = this.resolve(new AnnotatedType(schemaAnnotation._else()), context, next);\n            additionalPropertiesSchema = this.buildRefSchemaIfObject(additionalPropertiesSchema, context);\n            schema.setElse(additionalPropertiesSchema);\n         }\n\n         if (!Void.class.equals(schemaAnnotation.then())) {\n            additionalPropertiesSchema = this.resolve(new AnnotatedType(schemaAnnotation.then()), context, next);\n            additionalPropertiesSchema = this.buildRefSchemaIfObject(additionalPropertiesSchema, context);\n            schema.setThen(additionalPropertiesSchema);\n         }\n\n         if (!Void.class.equals(schemaAnnotation.unevaluatedProperties())) {\n            additionalPropertiesSchema = this.resolve(new AnnotatedType(schemaAnnotation.unevaluatedProperties()), context, next);\n            additionalPropertiesSchema = this.buildRefSchemaIfObject(additionalPropertiesSchema, context);\n            schema.setUnevaluatedProperties(additionalPropertiesSchema);\n         }\n\n         if (schemaAnnotation.additionalProperties().equals(AdditionalPropertiesValue.TRUE)) {\n            schema.additionalProperties(true);\n         } else if (schemaAnnotation.additionalProperties().equals(AdditionalPropertiesValue.FALSE)) {\n            schema.additionalProperties(false);\n         } else if (!schemaAnnotation.additionalPropertiesSchema().equals(Void.class)) {\n            additionalPropertiesSchema = this.resolve(new AnnotatedType(schemaAnnotation.additionalPropertiesSchema()), context, next);\n            additionalPropertiesSchema = this.buildRefSchemaIfObject(additionalPropertiesSchema, context);\n            schema.additionalProperties(additionalPropertiesSchema);\n         }\n\n         Map<String, List<String>> dependentRequired = this.resolveDependentRequired(a, annotations, schemaAnnotation);\n         if (dependentRequired != null && !dependentRequired.isEmpty()) {\n            schema.setDependentRequired(dependentRequired);\n         }\n\n         Map<String, Schema> dependentSchemas = this.resolveDependentSchemas(a, annotations, schemaAnnotation, annotatedType, context, next);\n         Iterator var14;\n         String key;\n         if (dependentSchemas != null) {\n            Map<String, Schema> processedDependentSchemas = new LinkedHashMap();\n            var14 = dependentSchemas.keySet().iterator();\n\n            while(var14.hasNext()) {\n               key = (String)var14.next();\n               Schema val = (Schema)dependentSchemas.get(key);\n               processedDependentSchemas.put(key, this.buildRefSchemaIfObject(val, context));\n            }\n\n            if (processedDependentSchemas != null && !processedDependentSchemas.isEmpty()) {\n               if (schema.getDependentSchemas() == null) {\n                  schema.setDependentSchemas(processedDependentSchemas);\n               } else {\n                  schema.getDependentSchemas().putAll(processedDependentSchemas);\n               }\n            }\n         }\n\n         Map<String, Schema> patternProperties = this.resolvePatternProperties(a, annotations, schemaAnnotation, annotatedType, context, next);\n         if (patternProperties != null && !patternProperties.isEmpty()) {\n            var14 = patternProperties.keySet().iterator();\n\n            while(var14.hasNext()) {\n               key = (String)var14.next();\n               schema.addPatternProperty(key, this.buildRefSchemaIfObject((Schema)patternProperties.get(key), context));\n            }\n         }\n\n         Map<String, Schema> properties = this.resolveProperties(a, annotations, schemaAnnotation, annotatedType, context, next);\n         if (properties != null && !properties.isEmpty()) {\n            Iterator var20 = properties.keySet().iterator();\n\n            while(var20.hasNext()) {\n               String key = (String)var20.next();\n               schema.addProperty(key, this.buildRefSchemaIfObject((Schema)properties.get(key), context));\n            }\n         }\n      }\n\n   }\n\n   protected void resolveSchemaMembers(Schema schema, Annotated a, Annotation[] annotations, io.swagger.v3.oas.annotations.media.Schema schemaAnnotation) {\n      String description = this.resolveDescription(a, annotations, schemaAnnotation);\n      if (StringUtils.isNotBlank(description)) {\n         schema.description(description);\n      }\n\n      String title = this.resolveTitle(a, annotations, schemaAnnotation);\n      if (StringUtils.isNotBlank(title)) {\n         schema.title(title);\n      }\n\n      String format = this.resolveFormat(a, annotations, schemaAnnotation);\n      if (StringUtils.isNotBlank(format) && StringUtils.isBlank(schema.getFormat())) {\n         schema.format(format);\n      }\n\n      Object defaultValue = this.resolveDefaultValue(a, annotations, schemaAnnotation);\n      if (defaultValue != null) {\n         schema.setDefault(defaultValue);\n      }\n\n      Object example = this.resolveExample(a, annotations, schemaAnnotation);\n      if (example != null) {\n         schema.example(example);\n      }\n\n      Boolean readOnly = this.resolveReadOnly(a, annotations, schemaAnnotation);\n      if (readOnly != null) {\n         schema.readOnly(readOnly);\n      }\n\n      Boolean nullable = this.resolveNullable(a, annotations, schemaAnnotation);\n      if (nullable != null) {\n         schema.nullable(nullable);\n      }\n\n      BigDecimal multipleOf = this.resolveMultipleOf(a, annotations, schemaAnnotation);\n      if (multipleOf != null) {\n         schema.multipleOf(multipleOf);\n      }\n\n      Integer maxLength = this.resolveMaxLength(a, annotations, schemaAnnotation);\n      if (maxLength != null) {\n         schema.maxLength(maxLength);\n      }\n\n      Integer minLength = this.resolveMinLength(a, annotations, schemaAnnotation);\n      if (minLength != null) {\n         schema.minLength(minLength);\n      }\n\n      BigDecimal minimum = this.resolveMinimum(a, annotations, schemaAnnotation);\n      if (minimum != null) {\n         schema.minimum(minimum);\n      }\n\n      BigDecimal maximum = this.resolveMaximum(a, annotations, schemaAnnotation);\n      if (maximum != null) {\n         schema.maximum(maximum);\n      }\n\n      Boolean exclusiveMinimum = this.resolveExclusiveMinimum(a, annotations, schemaAnnotation);\n      if (exclusiveMinimum != null) {\n         schema.exclusiveMinimum(exclusiveMinimum);\n      }\n\n      Boolean exclusiveMaximum = this.resolveExclusiveMaximum(a, annotations, schemaAnnotation);\n      if (exclusiveMaximum != null) {\n         schema.exclusiveMaximum(exclusiveMaximum);\n      }\n\n      String pattern = this.resolvePattern(a, annotations, schemaAnnotation);\n      if (StringUtils.isNotBlank(pattern)) {\n         schema.pattern(pattern);\n      }\n\n      Integer minProperties = this.resolveMinProperties(a, annotations, schemaAnnotation);\n      if (minProperties != null) {\n         schema.minProperties(minProperties);\n      }\n\n      Integer maxProperties = this.resolveMaxProperties(a, annotations, schemaAnnotation);\n      if (maxProperties != null) {\n         schema.maxProperties(maxProperties);\n      }\n\n      List<String> requiredProperties = this.resolveRequiredProperties(a, annotations, schemaAnnotation);\n      if (requiredProperties != null) {\n         Iterator var23 = requiredProperties.iterator();\n\n         while(var23.hasNext()) {\n            String prop = (String)var23.next();\n            this.addRequiredItem(schema, prop);\n         }\n      }\n\n      Boolean writeOnly = this.resolveWriteOnly(a, annotations, schemaAnnotation);\n      if (writeOnly != null) {\n         schema.writeOnly(writeOnly);\n      }\n\n      ExternalDocumentation externalDocs = this.resolveExternalDocumentation(a, annotations, schemaAnnotation);\n      if (externalDocs != null) {\n         schema.externalDocs(externalDocs);\n      }\n\n      Boolean deprecated = this.resolveDeprecated(a, annotations, schemaAnnotation);\n      if (deprecated != null) {\n         schema.deprecated(deprecated);\n      }\n\n      List<String> allowableValues = this.resolveAllowableValues(a, annotations, schemaAnnotation);\n      if (allowableValues != null) {\n         Iterator var27 = allowableValues.iterator();\n\n         while(var27.hasNext()) {\n            String prop = (String)var27.next();\n            schema.addEnumItemObject(prop);\n         }\n      }\n\n      Map<String, Object> extensions = this.resolveExtensions(a, annotations, schemaAnnotation);\n      if (extensions != null) {\n         Objects.requireNonNull(schema);\n         extensions.forEach(schema::addExtension);\n      }\n\n      if (this.openapi31 && schemaAnnotation != null) {\n         String[] var42 = schemaAnnotation.types();\n         int var29 = var42.length;\n\n         String $schema;\n         for(int var30 = 0; var30 < var29; ++var30) {\n            $schema = var42[var30];\n            schema.addType($schema);\n         }\n\n         BigDecimal exclusiveMaximumValue = this.resolveExclusiveMaximumValue(a, annotations, schemaAnnotation);\n         if (exclusiveMaximumValue != null) {\n            schema.setExclusiveMaximumValue(exclusiveMaximumValue);\n         }\n\n         BigDecimal exclusiveMinimumValue = this.resolveExclusiveMinimumValue(a, annotations, schemaAnnotation);\n         if (exclusiveMinimumValue != null) {\n            schema.setExclusiveMinimumValue(exclusiveMinimumValue);\n         }\n\n         String $id = this.resolveId(a, annotations, schemaAnnotation);\n         if ($id != null) {\n            schema.set$id($id);\n         }\n\n         $schema = this.resolve$schema(a, annotations, schemaAnnotation);\n         if ($schema != null) {\n            schema.set$schema($schema);\n         }\n\n         String $anchor = this.resolve$anchor(a, annotations, schemaAnnotation);\n         if ($anchor != null) {\n            schema.set$anchor($anchor);\n         }\n\n         String $comment = this.resolve$comment(a, annotations, schemaAnnotation);\n         if ($comment != null) {\n            schema.set$comment($comment);\n         }\n\n         String $vocabulary = this.resolve$vocabulary(a, annotations, schemaAnnotation);\n         if ($vocabulary != null) {\n            schema.set$vocabulary($vocabulary);\n         }\n\n         String $dynamicAnchor = this.resolve$dynamicAnchor(a, annotations, schemaAnnotation);\n         if ($dynamicAnchor != null) {\n            schema.$dynamicAnchor($dynamicAnchor);\n         }\n\n         String contentEncoding = this.resolveContentEncoding(a, annotations, schemaAnnotation);\n         if (contentEncoding != null) {\n            schema.setContentEncoding(contentEncoding);\n         }\n\n         String contentMediaType = this.resolveContentMediaType(a, annotations, schemaAnnotation);\n         if (contentMediaType != null) {\n            schema.setContentMediaType(contentMediaType);\n         }\n\n         if (schemaAnnotation.examples().length > 0) {\n            if (schema.getExamples() != null && !schema.getExamples().isEmpty()) {\n               schema.getExamples().addAll(Arrays.asList(schemaAnnotation.examples()));\n            } else {\n               schema.setExamples(Arrays.asList(schemaAnnotation.examples()));\n            }\n         }\n\n         String _const = this.resolveConst(a, annotations, schemaAnnotation);\n         if (_const != null) {\n            schema.setConst(_const);\n         }\n      }\n\n   }\n\n   protected void addRequiredItem(Schema model, String propName) {\n      if (model != null && propName != null && !StringUtils.isBlank(propName)) {\n         if (model.getRequired() == null || model.getRequired().isEmpty()) {\n            model.addRequiredItem(propName);\n         }\n\n         Stream var10000 = model.getRequired().stream();\n         Objects.requireNonNull(propName);\n         if (var10000.noneMatch(propName::equals)) {\n            model.addRequiredItem(propName);\n         }\n\n      }\n   }\n\n   protected boolean shouldIgnoreClass(Type type) {\n      if (type instanceof Class) {\n         Class<?> cls = (Class)type;\n         if (cls.getName().equals(\"javax.ws.rs.Response\")) {\n            return true;\n         }\n      } else if (type instanceof ResolvedType) {\n         ResolvedType rt = (ResolvedType)type;\n         this.LOGGER.trace(\"Can't check class {}, {}\", type, rt.getRawClass().getName());\n         if (rt.getRawClass().equals(Class.class)) {\n            return true;\n         }\n      }\n\n      return false;\n   }\n\n   private List<String> getIgnoredProperties(BeanDescription beanDescription) {\n      AnnotationIntrospector introspector = this._mapper.getSerializationConfig().getAnnotationIntrospector();\n      Value v = introspector.findPropertyIgnorals(beanDescription.getClassInfo());\n      Set<String> ignored = null;\n      if (v != null) {\n         ignored = v.findIgnoredForSerialization();\n      }\n\n      return (List)(ignored == null ? Collections.emptyList() : new ArrayList(ignored));\n   }\n\n   protected String decorateModelName(AnnotatedType type, String originalName) {\n      if (StringUtils.isBlank(originalName)) {\n         return originalName;\n      } else {\n         String name = originalName;\n         if (type.getJsonViewAnnotation() != null && type.getJsonViewAnnotation().value().length > 0) {\n            String COMBINER = \"-or-\";\n            StringBuilder sb = new StringBuilder();\n            Class[] var6 = type.getJsonViewAnnotation().value();\n            int var7 = var6.length;\n\n            for(int var8 = 0; var8 < var7; ++var8) {\n               Class<?> view = var6[var8];\n               sb.append(view.getSimpleName()).append(COMBINER);\n            }\n\n            String suffix = sb.substring(0, sb.length() - COMBINER.length());\n            name = originalName + \"_\" + suffix;\n         }\n\n         return name;\n      }\n   }\n\n   protected boolean hiddenByJsonView(Annotation[] annotations, AnnotatedType type) {\n      JsonView jsonView = type.getJsonViewAnnotation();\n      if (jsonView == null) {\n         return false;\n      } else {\n         Class<?>[] filters = jsonView.value();\n         boolean containsJsonViewAnnotation = !type.isIncludePropertiesWithoutJSONView();\n         Annotation[] var6 = annotations;\n         int var7 = annotations.length;\n\n         for(int var8 = 0; var8 < var7; ++var8) {\n            Annotation ant = var6[var8];\n            if (ant instanceof JsonView) {\n               containsJsonViewAnnotation = true;\n               Class<?>[] views = ((JsonView)ant).value();\n               Class[] var11 = filters;\n               int var12 = filters.length;\n\n               for(int var13 = 0; var13 < var12; ++var13) {\n                  Class<?> f = var11[var13];\n                  Class[] var15 = views;\n                  int var16 = views.length;\n\n                  for(int var17 = 0; var17 < var16; ++var17) {\n                     Class<?> v = var15[var17];\n                     if (v == f || v.isAssignableFrom(f)) {\n                        return false;\n                     }\n                  }\n               }\n            }\n         }\n\n         return containsJsonViewAnnotation;\n      }\n   }\n\n   private void resolveArraySchema(AnnotatedType annotatedType, io.swagger.v3.oas.models.media.ArraySchema schema, ArraySchema resolvedArrayAnnotation) {\n      Integer minItems = this.resolveMinItems(annotatedType, resolvedArrayAnnotation);\n      if (minItems != null) {\n         schema.minItems(minItems);\n      }\n\n      Integer maxItems = this.resolveMaxItems(annotatedType, resolvedArrayAnnotation);\n      if (maxItems != null) {\n         schema.maxItems(maxItems);\n      }\n\n      Boolean uniqueItems = this.resolveUniqueItems(annotatedType, resolvedArrayAnnotation);\n      if (uniqueItems != null) {\n         schema.uniqueItems(uniqueItems);\n      }\n\n      Map<String, Object> extensions = this.resolveExtensions(annotatedType, resolvedArrayAnnotation);\n      if (extensions != null) {\n         schema.extensions(extensions);\n      }\n\n      if (resolvedArrayAnnotation != null) {\n         if (AnnotationsUtils.hasSchemaAnnotation(resolvedArrayAnnotation.arraySchema())) {\n            this.resolveSchemaMembers(schema, (Annotated)null, (Annotation[])null, (io.swagger.v3.oas.annotations.media.Schema)resolvedArrayAnnotation.arraySchema());\n         }\n\n         if (this.openapi31) {\n            if (AnnotationsUtils.hasSchemaAnnotation(resolvedArrayAnnotation.contains())) {\n               this.resolveContains(annotatedType, schema, resolvedArrayAnnotation);\n            }\n\n            if (AnnotationsUtils.hasSchemaAnnotation(resolvedArrayAnnotation.unevaluatedItems())) {\n               this.resolveUnevaluatedItems(annotatedType, schema, resolvedArrayAnnotation);\n            }\n\n            int var9;\n            int var10;\n            if (resolvedArrayAnnotation.prefixItems().length > 0) {\n               io.swagger.v3.oas.annotations.media.Schema[] var8 = resolvedArrayAnnotation.prefixItems();\n               var9 = var8.length;\n\n               for(var10 = 0; var10 < var9; ++var10) {\n                  io.swagger.v3.oas.annotations.media.Schema prefixItemAnnotation = var8[var10];\n                  Schema prefixItem = new Schema();\n                  if (StringUtils.isNotBlank(prefixItemAnnotation.type())) {\n                     prefixItem.addType(prefixItemAnnotation.type());\n                  }\n\n                  this.resolveSchemaMembers(prefixItem, (Annotated)null, (Annotation[])null, (io.swagger.v3.oas.annotations.media.Schema)prefixItemAnnotation);\n                  schema.addPrefixItem(prefixItem);\n               }\n            }\n\n            if (schema.getItems() != null && AnnotationsUtils.hasSchemaAnnotation(resolvedArrayAnnotation.items())) {\n               String[] var13 = resolvedArrayAnnotation.items().types();\n               var9 = var13.length;\n\n               for(var10 = 0; var10 < var9; ++var10) {\n                  String type = var13[var10];\n                  schema.getItems().addType(type);\n               }\n            }\n         }\n      }\n\n   }\n\n   public ModelResolver openapi31(boolean openapi31) {\n      this.openapi31 = openapi31;\n      return this;\n   }\n\n   public boolean isOpenapi31() {\n      return this.openapi31;\n   }\n\n   public void setOpenapi31(boolean openapi31) {\n      this.openapi31 = openapi31;\n   }\n\n   protected boolean isObjectSchema(Schema schema) {\n      return \"object\".equals(schema.getType()) || schema.getType() == null && schema.getProperties() != null && !schema.getProperties().isEmpty();\n   }\n\n   protected Schema buildRefSchemaIfObject(Schema schema, ModelConverterContext context) {\n      if (schema == null) {\n         return null;\n      } else {\n         Schema result = schema;\n         if (this.isObjectSchema(schema) && StringUtils.isNotBlank(schema.getName()) && context.getDefinedModels().containsKey(schema.getName())) {\n            result = (new Schema()).$ref(RefUtils.constructRef(schema.getName()));\n         }\n\n         return result;\n      }\n   }\n\n   private class GeneratorWrapper {\n      private final List<ModelResolver.GeneratorWrapper.Base> wrappers;\n\n      private GeneratorWrapper() {\n         this.wrappers = new ArrayList();\n      }\n\n      public Schema processJsonIdentity(AnnotatedType type, ModelConverterContext context, ObjectMapper mapper, JsonIdentityInfo identityInfo, JsonIdentityReference identityReference) {\n         ModelResolver.GeneratorWrapper.Base wrapper = identityInfo != null ? this.getWrapper(identityInfo.generator()) : null;\n         if (wrapper == null) {\n            return null;\n         } else {\n            return identityReference != null && identityReference.alwaysAsId() ? wrapper.processAsId(identityInfo.property(), type, context, mapper) : wrapper.processAsProperty(identityInfo.property(), type, context, mapper);\n         }\n      }\n\n      private ModelResolver.GeneratorWrapper.Base getWrapper(Class<? extends ObjectIdGenerator> generator) {\n         if (PropertyGenerator.class.isAssignableFrom(generator)) {\n            return new ModelResolver.GeneratorWrapper.PropertyGeneratorWrapper(generator);\n         } else if (IntSequenceGenerator.class.isAssignableFrom(generator)) {\n            return new ModelResolver.GeneratorWrapper.IntGeneratorWrapper(generator);\n         } else if (UUIDGenerator.class.isAssignableFrom(generator)) {\n            return new ModelResolver.GeneratorWrapper.UUIDGeneratorWrapper(generator);\n         } else {\n            return None.class.isAssignableFrom(generator) ? new ModelResolver.GeneratorWrapper.NoneGeneratorWrapper(generator) : null;\n         }\n      }\n\n      protected Schema process(Schema id, String propertyName, AnnotatedType type, ModelConverterContext context) {\n         type = this.removeJsonIdentityAnnotations(type);\n         Schema model = context.resolve(type);\n         if (model == null) {\n            model = ModelResolver.this.resolve(type, context, (Iterator)null);\n         }\n\n         model.addProperties(propertyName, id);\n         return (new Schema()).$ref(StringUtils.isNotEmpty(model.get$ref()) ? model.get$ref() : model.getName());\n      }\n\n      private AnnotatedType removeJsonIdentityAnnotations(AnnotatedType type) {\n         return (new AnnotatedType()).jsonUnwrappedHandler(type.getJsonUnwrappedHandler()).jsonViewAnnotation(type.getJsonViewAnnotation()).name(type.getName()).parent(type.getParent()).resolveAsRef(false).schemaProperty(type.isSchemaProperty()).skipOverride(type.isSkipOverride()).skipSchemaName(type.isSkipSchemaName()).type(type.getType()).skipJsonIdentity(true).propertyName(type.getPropertyName()).components(type.getComponents()).ctxAnnotations(AnnotationsUtils.removeAnnotations(type.getCtxAnnotations(), new Class[]{JsonIdentityInfo.class, JsonIdentityReference.class}));\n      }\n\n      // $FF: synthetic method\n      GeneratorWrapper(Object x1) {\n         this();\n      }\n\n      private abstract class Base<T> {\n         private final Class<? extends ObjectIdGenerator> generator;\n\n         Base(Class<? extends ObjectIdGenerator> var1) {\n            this.generator = generator;\n         }\n\n         protected abstract Schema processAsProperty(String var1, AnnotatedType var2, ModelConverterContext var3, ObjectMapper var4);\n\n         protected abstract Schema processAsId(String var1, AnnotatedType var2, ModelConverterContext var3, ObjectMapper var4);\n      }\n\n      private final class NoneGeneratorWrapper extends ModelResolver.GeneratorWrapper.Base<None> {\n         public NoneGeneratorWrapper(Class<? extends ObjectIdGenerator> var1) {\n            super(generator);\n         }\n\n         protected Schema processAsProperty(String propertyName, AnnotatedType type, ModelConverterContext context, ObjectMapper mapper) {\n            return null;\n         }\n\n         protected Schema processAsId(String propertyName, AnnotatedType type, ModelConverterContext context, ObjectMapper mapper) {\n            return null;\n         }\n      }\n\n      private final class UUIDGeneratorWrapper extends ModelResolver.GeneratorWrapper.Base<UUIDGenerator> {\n         public UUIDGeneratorWrapper(Class<? extends ObjectIdGenerator> var1) {\n            super(generator);\n         }\n\n         protected Schema processAsProperty(String propertyName, AnnotatedType type, ModelConverterContext context, ObjectMapper mapper) {\n            Schema id = new UUIDSchema();\n            return GeneratorWrapper.this.process(id, propertyName, type, context);\n         }\n\n         protected Schema processAsId(String propertyName, AnnotatedType type, ModelConverterContext context, ObjectMapper mapper) {\n            return new UUIDSchema();\n         }\n      }\n\n      private final class IntGeneratorWrapper extends ModelResolver.GeneratorWrapper.Base<IntSequenceGenerator> {\n         public IntGeneratorWrapper(Class<? extends ObjectIdGenerator> var1) {\n            super(generator);\n         }\n\n         protected Schema processAsProperty(String propertyName, AnnotatedType type, ModelConverterContext context, ObjectMapper mapper) {\n            Schema id = new IntegerSchema();\n            return GeneratorWrapper.this.process(id, propertyName, type, context);\n         }\n\n         protected Schema processAsId(String propertyName, AnnotatedType type, ModelConverterContext context, ObjectMapper mapper) {\n            return new IntegerSchema();\n         }\n      }\n\n      private final class PropertyGeneratorWrapper extends ModelResolver.GeneratorWrapper.Base<PropertyGenerator> {\n         public PropertyGeneratorWrapper(Class<? extends ObjectIdGenerator> var1) {\n            super(generator);\n         }\n\n         protected Schema processAsProperty(String propertyName, AnnotatedType type, ModelConverterContext context, ObjectMapper mapper) {\n            return null;\n         }\n\n         protected Schema processAsId(String propertyName, AnnotatedType type, ModelConverterContext context, ObjectMapper mapper) {\n            JavaType javaType;\n            if (type.getType() instanceof JavaType) {\n               javaType = (JavaType)type.getType();\n            } else {\n               javaType = mapper.constructType(type.getType());\n            }\n\n            BeanDescription beanDesc = mapper.getSerializationConfig().introspect(javaType);\n            Iterator var7 = beanDesc.findProperties().iterator();\n\n            BeanPropertyDefinition def;\n            String name;\n            do {\n               if (!var7.hasNext()) {\n                  return null;\n               }\n\n               def = (BeanPropertyDefinition)var7.next();\n               name = def.getName();\n            } while(name == null || !name.equals(propertyName));\n\n            AnnotatedMember propMember = def.getPrimaryMember();\n            JavaType propType = propMember.getType();\n            if (PrimitiveType.fromType(propType) != null) {\n               return PrimitiveType.createProperty(propType);\n            } else {\n               List<Annotation> list = new ArrayList();\n               Iterator var13 = propMember.annotations().iterator();\n\n               while(var13.hasNext()) {\n                  Annotation a = (Annotation)var13.next();\n                  list.add(a);\n               }\n\n               Annotation[] annotations = (Annotation[])list.toArray(new Annotation[list.size()]);\n               AnnotatedType aType = (new AnnotatedType()).type(propType).ctxAnnotations(annotations).jsonViewAnnotation(type.getJsonViewAnnotation()).schemaProperty(true).components(type.getComponents()).propertyName(type.getPropertyName());\n               return context.resolve(aType);\n            }\n         }\n      }\n   }\n}\n"}