{"id":"1810672","content":"package org.springframework.aop.aspectj;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Predicate;\nimport org.aopalliance.intercept.MethodInvocation;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.aspectj.util.FuzzyBoolean;\nimport org.aspectj.weaver.ast.Test;\nimport org.aspectj.weaver.patterns.ExposedState;\nimport org.aspectj.weaver.patterns.NamePattern;\nimport org.aspectj.weaver.reflect.ShadowMatchImpl;\nimport org.aspectj.weaver.reflect.ReflectionWorld.ReflectionWorldException;\nimport org.aspectj.weaver.tools.ContextBasedMatcher;\nimport org.aspectj.weaver.tools.JoinPointMatch;\nimport org.aspectj.weaver.tools.MatchingContext;\nimport org.aspectj.weaver.tools.PointcutDesignatorHandler;\nimport org.aspectj.weaver.tools.PointcutExpression;\nimport org.aspectj.weaver.tools.PointcutParameter;\nimport org.aspectj.weaver.tools.PointcutParser;\nimport org.aspectj.weaver.tools.PointcutPrimitive;\nimport org.aspectj.weaver.tools.ShadowMatch;\nimport org.springframework.aop.ClassFilter;\nimport org.springframework.aop.IntroductionAwareMethodMatcher;\nimport org.springframework.aop.MethodMatcher;\nimport org.springframework.aop.ProxyMethodInvocation;\nimport org.springframework.aop.framework.autoproxy.ProxyCreationContext;\nimport org.springframework.aop.interceptor.ExposeInvocationInterceptor;\nimport org.springframework.aop.support.AbstractExpressionPointcut;\nimport org.springframework.aop.support.AopUtils;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.annotation.BeanFactoryAnnotationUtils;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.StringUtils;\n\npublic class AspectJExpressionPointcut extends AbstractExpressionPointcut implements ClassFilter, IntroductionAwareMethodMatcher, BeanFactoryAware {\n   private static final Set<PointcutPrimitive> SUPPORTED_PRIMITIVES = new HashSet();\n   private static final Log logger;\n   @Nullable\n   private Class<?> pointcutDeclarationScope;\n   private String[] pointcutParameterNames = new String[0];\n   private Class<?>[] pointcutParameterTypes = new Class[0];\n   @Nullable\n   private BeanFactory beanFactory;\n   @Nullable\n   private transient ClassLoader pointcutClassLoader;\n   @Nullable\n   private transient PointcutExpression pointcutExpression;\n   private transient Map<Method, ShadowMatch> shadowMatchCache = new ConcurrentHashMap(32);\n\n   public AspectJExpressionPointcut() {\n   }\n\n   public AspectJExpressionPointcut(Class<?> declarationScope, String[] paramNames, Class<?>[] paramTypes) {\n      this.pointcutDeclarationScope = declarationScope;\n      if (paramNames.length != paramTypes.length) {\n         throw new IllegalStateException(\"Number of pointcut parameter names must match number of pointcut parameter types\");\n      } else {\n         this.pointcutParameterNames = paramNames;\n         this.pointcutParameterTypes = paramTypes;\n      }\n   }\n\n   public void setPointcutDeclarationScope(Class<?> pointcutDeclarationScope) {\n      this.pointcutDeclarationScope = pointcutDeclarationScope;\n   }\n\n   public void setParameterNames(String... names) {\n      this.pointcutParameterNames = names;\n   }\n\n   public void setParameterTypes(Class... types) {\n      this.pointcutParameterTypes = types;\n   }\n\n   public void setBeanFactory(BeanFactory beanFactory) {\n      this.beanFactory = beanFactory;\n   }\n\n   public ClassFilter getClassFilter() {\n      this.obtainPointcutExpression();\n      return this;\n   }\n\n   public MethodMatcher getMethodMatcher() {\n      this.obtainPointcutExpression();\n      return this;\n   }\n\n   private PointcutExpression obtainPointcutExpression() {\n      if (this.getExpression() == null) {\n         throw new IllegalStateException(\"Must set property 'expression' before attempting to match\");\n      } else {\n         if (this.pointcutExpression == null) {\n            this.pointcutClassLoader = this.determinePointcutClassLoader();\n            this.pointcutExpression = this.buildPointcutExpression(this.pointcutClassLoader);\n         }\n\n         return this.pointcutExpression;\n      }\n   }\n\n   @Nullable\n   private ClassLoader determinePointcutClassLoader() {\n      if (this.beanFactory instanceof ConfigurableBeanFactory) {\n         return ((ConfigurableBeanFactory)this.beanFactory).getBeanClassLoader();\n      } else {\n         return this.pointcutDeclarationScope != null ? this.pointcutDeclarationScope.getClassLoader() : ClassUtils.getDefaultClassLoader();\n      }\n   }\n\n   private PointcutExpression buildPointcutExpression(@Nullable ClassLoader classLoader) {\n      PointcutParser parser = this.initializePointcutParser(classLoader);\n      PointcutParameter[] pointcutParameters = new PointcutParameter[this.pointcutParameterNames.length];\n\n      for(int i = 0; i < pointcutParameters.length; ++i) {\n         pointcutParameters[i] = parser.createPointcutParameter(this.pointcutParameterNames[i], this.pointcutParameterTypes[i]);\n      }\n\n      return parser.parsePointcutExpression(this.replaceBooleanOperators(this.resolveExpression()), this.pointcutDeclarationScope, pointcutParameters);\n   }\n\n   private String resolveExpression() {\n      String expression = this.getExpression();\n      Assert.state(expression != null, \"No expression set\");\n      return expression;\n   }\n\n   private PointcutParser initializePointcutParser(@Nullable ClassLoader classLoader) {\n      PointcutParser parser = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(SUPPORTED_PRIMITIVES, classLoader);\n      parser.registerPointcutDesignatorHandler(new AspectJExpressionPointcut.BeanPointcutDesignatorHandler());\n      return parser;\n   }\n\n   private String replaceBooleanOperators(String pcExpr) {\n      String result = StringUtils.replace(pcExpr, \" and \", \" && \");\n      result = StringUtils.replace(result, \" or \", \" || \");\n      result = StringUtils.replace(result, \" not \", \" ! \");\n      return result;\n   }\n\n   public PointcutExpression getPointcutExpression() {\n      return this.obtainPointcutExpression();\n   }\n\n   public boolean matches(Class<?> targetClass) {\n      PointcutExpression pointcutExpression = this.obtainPointcutExpression();\n\n      try {\n         try {\n            return pointcutExpression.couldMatchJoinPointsInType(targetClass);\n         } catch (ReflectionWorldException var5) {\n            logger.debug(\"PointcutExpression matching rejected target class - trying fallback expression\", var5);\n            PointcutExpression fallbackExpression = this.getFallbackPointcutExpression(targetClass);\n            if (fallbackExpression != null) {\n               return fallbackExpression.couldMatchJoinPointsInType(targetClass);\n            }\n         }\n      } catch (Throwable var6) {\n         logger.debug(\"PointcutExpression matching rejected target class\", var6);\n      }\n\n      return false;\n   }\n\n   public boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions) {\n      this.obtainPointcutExpression();\n      ShadowMatch shadowMatch = this.getTargetShadowMatch(method, targetClass);\n      if (shadowMatch.alwaysMatches()) {\n         return true;\n      } else if (shadowMatch.neverMatches()) {\n         return false;\n      } else if (hasIntroductions) {\n         return true;\n      } else {\n         RuntimeTestWalker walker = this.getRuntimeTestWalker(shadowMatch);\n         return !walker.testsSubtypeSensitiveVars() || walker.testTargetInstanceOfResidue(targetClass);\n      }\n   }\n\n   public boolean matches(Method method, Class<?> targetClass) {\n      return this.matches(method, targetClass, false);\n   }\n\n   public boolean isRuntime() {\n      return this.obtainPointcutExpression().mayNeedDynamicTest();\n   }\n\n   public boolean matches(Method method, Class<?> targetClass, Object... args) {\n      this.obtainPointcutExpression();\n      ShadowMatch shadowMatch = this.getTargetShadowMatch(method, targetClass);\n      ProxyMethodInvocation pmi = null;\n      Object targetObject = null;\n      Object thisObject = null;\n\n      try {\n         MethodInvocation mi = ExposeInvocationInterceptor.currentInvocation();\n         targetObject = mi.getThis();\n         if (!(mi instanceof ProxyMethodInvocation)) {\n            throw new IllegalStateException(\"MethodInvocation is not a Spring ProxyMethodInvocation: \" + mi);\n         }\n\n         pmi = (ProxyMethodInvocation)mi;\n         thisObject = pmi.getProxy();\n      } catch (IllegalStateException var11) {\n         if (logger.isDebugEnabled()) {\n            logger.debug(\"Could not access current invocation - matching with limited context: \" + var11);\n         }\n      }\n\n      try {\n         JoinPointMatch joinPointMatch = shadowMatch.matchesJoinPoint(thisObject, targetObject, args);\n         if (pmi != null && thisObject != null) {\n            RuntimeTestWalker originalMethodResidueTest = this.getRuntimeTestWalker(this.getShadowMatch(method, method));\n            if (!originalMethodResidueTest.testThisInstanceOfResidue(thisObject.getClass())) {\n               return false;\n            }\n\n            if (joinPointMatch.matches()) {\n               this.bindParameters(pmi, joinPointMatch);\n            }\n         }\n\n         return joinPointMatch.matches();\n      } catch (Throwable var10) {\n         if (logger.isDebugEnabled()) {\n            logger.debug(\"Failed to evaluate join point for arguments \" + Arrays.toString(args) + \" - falling back to non-match\", var10);\n         }\n\n         return false;\n      }\n   }\n\n   @Nullable\n   protected String getCurrentProxiedBeanName() {\n      return ProxyCreationContext.getCurrentProxiedBeanName();\n   }\n\n   @Nullable\n   private PointcutExpression getFallbackPointcutExpression(Class<?> targetClass) {\n      try {\n         ClassLoader classLoader = targetClass.getClassLoader();\n         if (classLoader != null && classLoader != this.pointcutClassLoader) {\n            return this.buildPointcutExpression(classLoader);\n         }\n      } catch (Throwable var3) {\n         logger.debug(\"Failed to create fallback PointcutExpression\", var3);\n      }\n\n      return null;\n   }\n\n   private RuntimeTestWalker getRuntimeTestWalker(ShadowMatch shadowMatch) {\n      return shadowMatch instanceof AspectJExpressionPointcut.DefensiveShadowMatch ? new RuntimeTestWalker(((AspectJExpressionPointcut.DefensiveShadowMatch)shadowMatch).primary) : new RuntimeTestWalker(shadowMatch);\n   }\n\n   private void bindParameters(ProxyMethodInvocation invocation, JoinPointMatch jpm) {\n      invocation.setUserAttribute(this.resolveExpression(), jpm);\n   }\n\n   private ShadowMatch getTargetShadowMatch(Method method, Class<?> targetClass) {\n      Method targetMethod = AopUtils.getMostSpecificMethod(method, targetClass);\n      if (targetMethod.getDeclaringClass().isInterface()) {\n         Set<Class<?>> ifcs = ClassUtils.getAllInterfacesForClassAsSet(targetClass);\n         if (ifcs.size() > 1) {\n            try {\n               Class<?> compositeInterface = ClassUtils.createCompositeInterface(ClassUtils.toClassArray(ifcs), targetClass.getClassLoader());\n               targetMethod = ClassUtils.getMostSpecificMethod(targetMethod, compositeInterface);\n            } catch (IllegalArgumentException var6) {\n               ;\n            }\n         }\n      }\n\n      return this.getShadowMatch(targetMethod, method);\n   }\n\n   private ShadowMatch getShadowMatch(Method targetMethod, Method originalMethod) {\n      ShadowMatch shadowMatch = (ShadowMatch)this.shadowMatchCache.get(targetMethod);\n      if (shadowMatch == null) {\n         Map var4 = this.shadowMatchCache;\n         synchronized(this.shadowMatchCache) {\n            PointcutExpression fallbackExpression = null;\n            shadowMatch = (ShadowMatch)this.shadowMatchCache.get(targetMethod);\n            if (shadowMatch == null) {\n               Method methodToMatch = targetMethod;\n\n               try {\n                  try {\n                     shadowMatch = this.obtainPointcutExpression().matchesMethodExecution(methodToMatch);\n                  } catch (ReflectionWorldException var13) {\n                     try {\n                        fallbackExpression = this.getFallbackPointcutExpression(methodToMatch.getDeclaringClass());\n                        if (fallbackExpression != null) {\n                           shadowMatch = fallbackExpression.matchesMethodExecution(methodToMatch);\n                        }\n                     } catch (ReflectionWorldException var12) {\n                        fallbackExpression = null;\n                     }\n                  }\n\n                  if (targetMethod != originalMethod && (shadowMatch == null || ((ShadowMatch)shadowMatch).neverMatches() && Proxy.isProxyClass(targetMethod.getDeclaringClass()))) {\n                     methodToMatch = originalMethod;\n\n                     try {\n                        shadowMatch = this.obtainPointcutExpression().matchesMethodExecution(methodToMatch);\n                     } catch (ReflectionWorldException var11) {\n                        try {\n                           fallbackExpression = this.getFallbackPointcutExpression(methodToMatch.getDeclaringClass());\n                           if (fallbackExpression != null) {\n                              shadowMatch = fallbackExpression.matchesMethodExecution(methodToMatch);\n                           }\n                        } catch (ReflectionWorldException var10) {\n                           fallbackExpression = null;\n                        }\n                     }\n                  }\n               } catch (Throwable var14) {\n                  logger.debug(\"PointcutExpression matching rejected target method\", var14);\n                  fallbackExpression = null;\n               }\n\n               if (shadowMatch == null) {\n                  shadowMatch = new ShadowMatchImpl(FuzzyBoolean.NO, (Test)null, (ExposedState)null, (PointcutParameter[])null);\n               } else if (((ShadowMatch)shadowMatch).maybeMatches() && fallbackExpression != null) {\n                  shadowMatch = new AspectJExpressionPointcut.DefensiveShadowMatch((ShadowMatch)shadowMatch, fallbackExpression.matchesMethodExecution(methodToMatch));\n               }\n\n               this.shadowMatchCache.put(targetMethod, shadowMatch);\n            }\n         }\n      }\n\n      return (ShadowMatch)shadowMatch;\n   }\n\n   public boolean equals(@Nullable Object other) {\n      if (this == other) {\n         return true;\n      } else if (!(other instanceof AspectJExpressionPointcut)) {\n         return false;\n      } else {\n         AspectJExpressionPointcut otherPc = (AspectJExpressionPointcut)other;\n         return ObjectUtils.nullSafeEquals(this.getExpression(), otherPc.getExpression()) && ObjectUtils.nullSafeEquals(this.pointcutDeclarationScope, otherPc.pointcutDeclarationScope) && ObjectUtils.nullSafeEquals(this.pointcutParameterNames, otherPc.pointcutParameterNames) && ObjectUtils.nullSafeEquals(this.pointcutParameterTypes, otherPc.pointcutParameterTypes);\n      }\n   }\n\n   public int hashCode() {\n      int hashCode = ObjectUtils.nullSafeHashCode(this.getExpression());\n      hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.pointcutDeclarationScope);\n      hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.pointcutParameterNames);\n      hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.pointcutParameterTypes);\n      return hashCode;\n   }\n\n   public String toString() {\n      StringBuilder sb = new StringBuilder(\"AspectJExpressionPointcut: (\");\n\n      for(int i = 0; i < this.pointcutParameterTypes.length; ++i) {\n         sb.append(this.pointcutParameterTypes[i].getName());\n         sb.append(' ');\n         sb.append(this.pointcutParameterNames[i]);\n         if (i + 1 < this.pointcutParameterTypes.length) {\n            sb.append(\", \");\n         }\n      }\n\n      sb.append(\") \");\n      if (this.getExpression() != null) {\n         sb.append(this.getExpression());\n      } else {\n         sb.append(\"<pointcut expression not set>\");\n      }\n\n      return sb.toString();\n   }\n\n   private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n      ois.defaultReadObject();\n      this.shadowMatchCache = new ConcurrentHashMap(32);\n   }\n\n   static {\n      SUPPORTED_PRIMITIVES.add(PointcutPrimitive.EXECUTION);\n      SUPPORTED_PRIMITIVES.add(PointcutPrimitive.ARGS);\n      SUPPORTED_PRIMITIVES.add(PointcutPrimitive.REFERENCE);\n      SUPPORTED_PRIMITIVES.add(PointcutPrimitive.THIS);\n      SUPPORTED_PRIMITIVES.add(PointcutPrimitive.TARGET);\n      SUPPORTED_PRIMITIVES.add(PointcutPrimitive.WITHIN);\n      SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_ANNOTATION);\n      SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_WITHIN);\n      SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_ARGS);\n      SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_TARGET);\n      logger = LogFactory.getLog(AspectJExpressionPointcut.class);\n   }\n\n   private static class DefensiveShadowMatch implements ShadowMatch {\n      private final ShadowMatch primary;\n      private final ShadowMatch other;\n\n      public DefensiveShadowMatch(ShadowMatch primary, ShadowMatch other) {\n         this.primary = primary;\n         this.other = other;\n      }\n\n      public boolean alwaysMatches() {\n         return this.primary.alwaysMatches();\n      }\n\n      public boolean maybeMatches() {\n         return this.primary.maybeMatches();\n      }\n\n      public boolean neverMatches() {\n         return this.primary.neverMatches();\n      }\n\n      public JoinPointMatch matchesJoinPoint(Object thisObject, Object targetObject, Object[] args) {\n         try {\n            return this.primary.matchesJoinPoint(thisObject, targetObject, args);\n         } catch (ReflectionWorldException var5) {\n            return this.other.matchesJoinPoint(thisObject, targetObject, args);\n         }\n      }\n\n      public void setMatchingContext(MatchingContext aMatchContext) {\n         this.primary.setMatchingContext(aMatchContext);\n         this.other.setMatchingContext(aMatchContext);\n      }\n   }\n\n   private class BeanContextMatcher implements ContextBasedMatcher {\n      private final NamePattern expressionPattern;\n\n      public BeanContextMatcher(String expression) {\n         this.expressionPattern = new NamePattern(expression);\n      }\n\n      /** @deprecated */\n      @Deprecated\n      public boolean couldMatchJoinPointsInType(Class someClass) {\n         return this.contextMatch(someClass) == org.aspectj.weaver.tools.FuzzyBoolean.YES;\n      }\n\n      /** @deprecated */\n      @Deprecated\n      public boolean couldMatchJoinPointsInType(Class someClass, MatchingContext context) {\n         return this.contextMatch(someClass) == org.aspectj.weaver.tools.FuzzyBoolean.YES;\n      }\n\n      public boolean matchesDynamically(MatchingContext context) {\n         return true;\n      }\n\n      public org.aspectj.weaver.tools.FuzzyBoolean matchesStatically(MatchingContext context) {\n         return this.contextMatch((Class)null);\n      }\n\n      public boolean mayNeedDynamicTest() {\n         return false;\n      }\n\n      private org.aspectj.weaver.tools.FuzzyBoolean contextMatch(@Nullable Class<?> targetType) {\n         String advisedBeanName = AspectJExpressionPointcut.this.getCurrentProxiedBeanName();\n         if (advisedBeanName == null) {\n            return org.aspectj.weaver.tools.FuzzyBoolean.MAYBE;\n         } else if (BeanFactoryUtils.isGeneratedBeanName(advisedBeanName)) {\n            return org.aspectj.weaver.tools.FuzzyBoolean.NO;\n         } else if (targetType != null) {\n            boolean isFactory = FactoryBean.class.isAssignableFrom(targetType);\n            return org.aspectj.weaver.tools.FuzzyBoolean.fromBoolean(this.matchesBean(isFactory ? \"&\" + advisedBeanName : advisedBeanName));\n         } else {\n            return org.aspectj.weaver.tools.FuzzyBoolean.fromBoolean(this.matchesBean(advisedBeanName) || this.matchesBean(\"&\" + advisedBeanName));\n         }\n      }\n\n      private boolean matchesBean(String advisedBeanName) {\n         NamePattern var10000 = this.expressionPattern;\n         this.expressionPattern.getClass();\n         return BeanFactoryAnnotationUtils.isQualifierMatch(var10000::matches, advisedBeanName, AspectJExpressionPointcut.this.beanFactory);\n      }\n   }\n\n   private class BeanPointcutDesignatorHandler implements PointcutDesignatorHandler {\n      private static final String BEAN_DESIGNATOR_NAME = \"bean\";\n\n      private BeanPointcutDesignatorHandler() {\n      }\n\n      public String getDesignatorName() {\n         return \"bean\";\n      }\n\n      public ContextBasedMatcher parse(String expression) {\n         return AspectJExpressionPointcut.this.new BeanContextMatcher(expression);\n      }\n\n      // $FF: synthetic method\n      BeanPointcutDesignatorHandler(Object x1) {\n         this();\n      }\n   }\n}\n"}