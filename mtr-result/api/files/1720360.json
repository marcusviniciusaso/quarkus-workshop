{"id":"1720360","content":"package org.springframework.boot.loader;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Constructor;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.net.URLDecoder;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.util.jar.Manifest;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.springframework.boot.loader.archive.Archive;\nimport org.springframework.boot.loader.archive.ExplodedArchive;\nimport org.springframework.boot.loader.archive.JarFileArchive;\nimport org.springframework.boot.loader.archive.Archive.Entry;\nimport org.springframework.boot.loader.archive.Archive.EntryFilter;\nimport org.springframework.boot.loader.util.SystemPropertyUtils;\n\npublic class PropertiesLauncher extends Launcher {\n   private static final Class<?>[] PARENT_ONLY_PARAMS = new Class[]{ClassLoader.class};\n   private static final Class<?>[] URLS_AND_PARENT_PARAMS = new Class[]{URL[].class, ClassLoader.class};\n   private static final Class<?>[] NO_PARAMS = new Class[0];\n   private static final URL[] NO_URLS = new URL[0];\n   private static final String DEBUG = \"loader.debug\";\n   public static final String MAIN = \"loader.main\";\n   public static final String PATH = \"loader.path\";\n   public static final String HOME = \"loader.home\";\n   public static final String ARGS = \"loader.args\";\n   public static final String CONFIG_NAME = \"loader.config.name\";\n   public static final String CONFIG_LOCATION = \"loader.config.location\";\n   public static final String SET_SYSTEM_PROPERTIES = \"loader.system\";\n   private static final Pattern WORD_SEPARATOR = Pattern.compile(\"\\\\W+\");\n   private static final String NESTED_ARCHIVE_SEPARATOR;\n   private final File home;\n   private List<String> paths = new ArrayList();\n   private final Properties properties = new Properties();\n   private final Archive parent;\n   private volatile PropertiesLauncher.ClassPathArchives classPathArchives;\n\n   public PropertiesLauncher() {\n      try {\n         this.home = this.getHomeDirectory();\n         this.initializeProperties();\n         this.initializePaths();\n         this.parent = this.createArchive();\n      } catch (Exception var2) {\n         throw new IllegalStateException(var2);\n      }\n   }\n\n   protected File getHomeDirectory() {\n      try {\n         return new File(this.getPropertyWithDefault(\"loader.home\", \"${user.dir}\"));\n      } catch (Exception var2) {\n         throw new IllegalStateException(var2);\n      }\n   }\n\n   private void initializeProperties() throws Exception {\n      List<String> configs = new ArrayList();\n      if (this.getProperty(\"loader.config.location\") != null) {\n         configs.add(this.getProperty(\"loader.config.location\"));\n      } else {\n         String[] names = this.getPropertyWithDefault(\"loader.config.name\", \"loader\").split(\",\");\n         String[] var3 = names;\n         int var4 = names.length;\n\n         for(int var5 = 0; var5 < var4; ++var5) {\n            String name = var3[var5];\n            configs.add(\"file:\" + this.getHomeDirectory() + \"/\" + name + \".properties\");\n            configs.add(\"classpath:\" + name + \".properties\");\n            configs.add(\"classpath:BOOT-INF/classes/\" + name + \".properties\");\n         }\n      }\n\n      Iterator var17 = configs.iterator();\n\n      while(true) {\n         if (var17.hasNext()) {\n            String config = (String)var17.next();\n            InputStream resource = this.getResource(config);\n            Throwable var20 = null;\n\n            try {\n               if (resource == null) {\n                  this.debug(\"Not found: \" + config);\n                  continue;\n               }\n\n               this.debug(\"Found: \" + config);\n               this.loadResource(resource);\n            } catch (Throwable var15) {\n               var20 = var15;\n               throw var15;\n            } finally {\n               if (resource != null) {\n                  if (var20 != null) {\n                     try {\n                        resource.close();\n                     } catch (Throwable var14) {\n                        var20.addSuppressed(var14);\n                     }\n                  } else {\n                     resource.close();\n                  }\n               }\n\n            }\n\n            return;\n         }\n\n         return;\n      }\n   }\n\n   private void loadResource(InputStream resource) throws Exception {\n      this.properties.load(resource);\n      Iterator var2 = Collections.list(this.properties.propertyNames()).iterator();\n\n      Object key;\n      String value;\n      while(var2.hasNext()) {\n         key = var2.next();\n         value = this.properties.getProperty((String)key);\n         String value = SystemPropertyUtils.resolvePlaceholders(this.properties, value);\n         if (value != null) {\n            this.properties.put(key, value);\n         }\n      }\n\n      if (\"true\".equals(this.getProperty(\"loader.system\"))) {\n         this.debug(\"Adding resolved properties to System properties\");\n         var2 = Collections.list(this.properties.propertyNames()).iterator();\n\n         while(var2.hasNext()) {\n            key = var2.next();\n            value = this.properties.getProperty((String)key);\n            System.setProperty((String)key, value);\n         }\n      }\n\n   }\n\n   private InputStream getResource(String config) throws Exception {\n      if (config.startsWith(\"classpath:\")) {\n         return this.getClasspathResource(config.substring(\"classpath:\".length()));\n      } else {\n         config = this.handleUrl(config);\n         return this.isUrl(config) ? this.getURLResource(config) : this.getFileResource(config);\n      }\n   }\n\n   private String handleUrl(String path) throws UnsupportedEncodingException {\n      if (path.startsWith(\"jar:file:\") || path.startsWith(\"file:\")) {\n         path = URLDecoder.decode(path, \"UTF-8\");\n         if (path.startsWith(\"file:\")) {\n            path = path.substring(\"file:\".length());\n            if (path.startsWith(\"//\")) {\n               path = path.substring(2);\n            }\n         }\n      }\n\n      return path;\n   }\n\n   private boolean isUrl(String config) {\n      return config.contains(\"://\");\n   }\n\n   private InputStream getClasspathResource(String config) {\n      while(config.startsWith(\"/\")) {\n         config = config.substring(1);\n      }\n\n      config = \"/\" + config;\n      this.debug(\"Trying classpath: \" + config);\n      return this.getClass().getResourceAsStream(config);\n   }\n\n   private InputStream getFileResource(String config) throws Exception {\n      File file = new File(config);\n      this.debug(\"Trying file: \" + config);\n      return file.canRead() ? new FileInputStream(file) : null;\n   }\n\n   private InputStream getURLResource(String config) throws Exception {\n      URL url = new URL(config);\n      if (this.exists(url)) {\n         URLConnection con = url.openConnection();\n\n         try {\n            return con.getInputStream();\n         } catch (IOException var5) {\n            if (con instanceof HttpURLConnection) {\n               ((HttpURLConnection)con).disconnect();\n            }\n\n            throw var5;\n         }\n      } else {\n         return null;\n      }\n   }\n\n   private boolean exists(URL url) throws IOException {\n      URLConnection connection = url.openConnection();\n\n      boolean var9;\n      try {\n         connection.setUseCaches(connection.getClass().getSimpleName().startsWith(\"JNLP\"));\n         if (connection instanceof HttpURLConnection) {\n            HttpURLConnection httpConnection = (HttpURLConnection)connection;\n            httpConnection.setRequestMethod(\"HEAD\");\n            int responseCode = httpConnection.getResponseCode();\n            boolean var5;\n            if (responseCode == 200) {\n               var5 = true;\n               return var5;\n            }\n\n            if (responseCode == 404) {\n               var5 = false;\n               return var5;\n            }\n         }\n\n         var9 = connection.getContentLength() >= 0;\n      } finally {\n         if (connection instanceof HttpURLConnection) {\n            ((HttpURLConnection)connection).disconnect();\n         }\n\n      }\n\n      return var9;\n   }\n\n   private void initializePaths() throws Exception {\n      String path = this.getProperty(\"loader.path\");\n      if (path != null) {\n         this.paths = this.parsePathsProperty(path);\n      }\n\n      this.debug(\"Nested archive paths: \" + this.paths);\n   }\n\n   private List<String> parsePathsProperty(String commaSeparatedPaths) {\n      List<String> paths = new ArrayList();\n      String[] var3 = commaSeparatedPaths.split(\",\");\n      int var4 = var3.length;\n\n      for(int var5 = 0; var5 < var4; ++var5) {\n         String path = var3[var5];\n         path = this.cleanupPath(path);\n         path = path != null && !path.isEmpty() ? path : \"/\";\n         paths.add(path);\n      }\n\n      if (paths.isEmpty()) {\n         paths.add(\"lib\");\n      }\n\n      return paths;\n   }\n\n   protected String[] getArgs(String... args) throws Exception {\n      String loaderArgs = this.getProperty(\"loader.args\");\n      if (loaderArgs != null) {\n         String[] defaultArgs = loaderArgs.split(\"\\\\s+\");\n         String[] additionalArgs = args;\n         args = new String[defaultArgs.length + args.length];\n         System.arraycopy(defaultArgs, 0, args, 0, defaultArgs.length);\n         System.arraycopy(additionalArgs, 0, args, defaultArgs.length, additionalArgs.length);\n      }\n\n      return args;\n   }\n\n   protected String getMainClass() throws Exception {\n      String mainClass = this.getProperty(\"loader.main\", \"Start-Class\");\n      if (mainClass == null) {\n         throw new IllegalStateException(\"No 'loader.main' or 'Start-Class' specified\");\n      } else {\n         return mainClass;\n      }\n   }\n\n   protected ClassLoader createClassLoader(Iterator<Archive> archives) throws Exception {\n      String customLoaderClassName = this.getProperty(\"loader.classLoader\");\n      if (customLoaderClassName == null) {\n         return super.createClassLoader(archives);\n      } else {\n         LinkedHashSet urls = new LinkedHashSet();\n\n         while(archives.hasNext()) {\n            urls.add(((Archive)archives.next()).getUrl());\n         }\n\n         ClassLoader loader = new LaunchedURLClassLoader((URL[])urls.toArray(NO_URLS), this.getClass().getClassLoader());\n         this.debug(\"Classpath for custom loader: \" + urls);\n         ClassLoader loader = this.wrapWithCustomClassLoader(loader, customLoaderClassName);\n         this.debug(\"Using custom class loader: \" + customLoaderClassName);\n         return loader;\n      }\n   }\n\n   private ClassLoader wrapWithCustomClassLoader(ClassLoader parent, String className) throws Exception {\n      Class<ClassLoader> type = Class.forName(className, true, parent);\n      ClassLoader classLoader = this.newClassLoader(type, PARENT_ONLY_PARAMS, parent);\n      if (classLoader == null) {\n         classLoader = this.newClassLoader(type, URLS_AND_PARENT_PARAMS, NO_URLS, parent);\n      }\n\n      if (classLoader == null) {\n         classLoader = this.newClassLoader(type, NO_PARAMS);\n      }\n\n      if (classLoader == null) {\n         throw new IllegalArgumentException(\"Unable to create class loader for \" + className);\n      } else {\n         return classLoader;\n      }\n   }\n\n   private ClassLoader newClassLoader(Class<ClassLoader> loaderClass, Class<?>[] parameterTypes, Object... initargs) throws Exception {\n      try {\n         Constructor<ClassLoader> constructor = loaderClass.getDeclaredConstructor(parameterTypes);\n         constructor.setAccessible(true);\n         return (ClassLoader)constructor.newInstance(initargs);\n      } catch (NoSuchMethodException var5) {\n         return null;\n      }\n   }\n\n   private String getProperty(String propertyKey) throws Exception {\n      return this.getProperty(propertyKey, (String)null, (String)null);\n   }\n\n   private String getProperty(String propertyKey, String manifestKey) throws Exception {\n      return this.getProperty(propertyKey, manifestKey, (String)null);\n   }\n\n   private String getPropertyWithDefault(String propertyKey, String defaultValue) throws Exception {\n      return this.getProperty(propertyKey, (String)null, defaultValue);\n   }\n\n   private String getProperty(String propertyKey, String manifestKey, String defaultValue) throws Exception {\n      if (manifestKey == null) {\n         manifestKey = propertyKey.replace('.', '-');\n         manifestKey = toCamelCase(manifestKey);\n      }\n\n      String property = SystemPropertyUtils.getProperty(propertyKey);\n      String value;\n      if (property != null) {\n         value = SystemPropertyUtils.resolvePlaceholders(this.properties, property);\n         this.debug(\"Property '\" + propertyKey + \"' from environment: \" + value);\n         return value;\n      } else if (this.properties.containsKey(propertyKey)) {\n         value = SystemPropertyUtils.resolvePlaceholders(this.properties, this.properties.getProperty(propertyKey));\n         this.debug(\"Property '\" + propertyKey + \"' from properties: \" + value);\n         return value;\n      } else {\n         try {\n            if (this.home != null) {\n               label164: {\n                  ExplodedArchive archive = new ExplodedArchive(this.home, false);\n                  Throwable var6 = null;\n\n                  String var9;\n                  try {\n                     Manifest manifest = archive.getManifest();\n                     if (manifest == null) {\n                        break label164;\n                     }\n\n                     String value = manifest.getMainAttributes().getValue(manifestKey);\n                     if (value == null) {\n                        break label164;\n                     }\n\n                     this.debug(\"Property '\" + manifestKey + \"' from home directory manifest: \" + value);\n                     var9 = SystemPropertyUtils.resolvePlaceholders(this.properties, value);\n                  } catch (Throwable var20) {\n                     var6 = var20;\n                     throw var20;\n                  } finally {\n                     if (archive != null) {\n                        if (var6 != null) {\n                           try {\n                              archive.close();\n                           } catch (Throwable var19) {\n                              var6.addSuppressed(var19);\n                           }\n                        } else {\n                           archive.close();\n                        }\n                     }\n\n                  }\n\n                  return var9;\n               }\n            }\n         } catch (IllegalStateException var22) {\n            ;\n         }\n\n         Manifest manifest = this.createArchive().getManifest();\n         if (manifest != null) {\n            String value = manifest.getMainAttributes().getValue(manifestKey);\n            if (value != null) {\n               this.debug(\"Property '\" + manifestKey + \"' from archive manifest: \" + value);\n               return SystemPropertyUtils.resolvePlaceholders(this.properties, value);\n            }\n         }\n\n         return defaultValue != null ? SystemPropertyUtils.resolvePlaceholders(this.properties, defaultValue) : defaultValue;\n      }\n   }\n\n   protected Iterator<Archive> getClassPathArchivesIterator() throws Exception {\n      PropertiesLauncher.ClassPathArchives classPathArchives = this.classPathArchives;\n      if (classPathArchives == null) {\n         classPathArchives = new PropertiesLauncher.ClassPathArchives();\n         this.classPathArchives = classPathArchives;\n      }\n\n      return classPathArchives.iterator();\n   }\n\n   public static void main(String[] args) throws Exception {\n      PropertiesLauncher launcher = new PropertiesLauncher();\n      args = launcher.getArgs(args);\n      launcher.launch(args);\n   }\n\n   public static String toCamelCase(CharSequence string) {\n      if (string == null) {\n         return null;\n      } else {\n         StringBuilder builder = new StringBuilder();\n         Matcher matcher = WORD_SEPARATOR.matcher(string);\n\n         int pos;\n         for(pos = 0; matcher.find(); pos = matcher.end()) {\n            builder.append(capitalize(string.subSequence(pos, matcher.end()).toString()));\n         }\n\n         builder.append(capitalize(string.subSequence(pos, string.length()).toString()));\n         return builder.toString();\n      }\n   }\n\n   private static String capitalize(String str) {\n      return Character.toUpperCase(str.charAt(0)) + str.substring(1);\n   }\n\n   private void debug(String message) {\n      if (Boolean.getBoolean(\"loader.debug\")) {\n         System.out.println(message);\n      }\n\n   }\n\n   private String cleanupPath(String path) {\n      path = path.trim();\n      if (path.startsWith(\"./\")) {\n         path = path.substring(2);\n      }\n\n      String lowerCasePath = path.toLowerCase(Locale.ENGLISH);\n      if (!lowerCasePath.endsWith(\".jar\") && !lowerCasePath.endsWith(\".zip\")) {\n         if (path.endsWith(\"/*\")) {\n            path = path.substring(0, path.length() - 1);\n         } else if (!path.endsWith(\"/\") && !path.equals(\".\")) {\n            path = path + \"/\";\n         }\n\n         return path;\n      } else {\n         return path;\n      }\n   }\n\n   void close() throws Exception {\n      if (this.classPathArchives != null) {\n         this.classPathArchives.close();\n      }\n\n      if (this.parent != null) {\n         this.parent.close();\n      }\n\n   }\n\n   static {\n      NESTED_ARCHIVE_SEPARATOR = \"!\" + File.separator;\n   }\n\n   private static final class ArchiveEntryFilter implements EntryFilter {\n      private static final String DOT_JAR = \".jar\";\n      private static final String DOT_ZIP = \".zip\";\n\n      private ArchiveEntryFilter() {\n      }\n\n      public boolean matches(Entry entry) {\n         return entry.getName().endsWith(\".jar\") || entry.getName().endsWith(\".zip\");\n      }\n\n      // $FF: synthetic method\n      ArchiveEntryFilter(Object x0) {\n         this();\n      }\n   }\n\n   private static final class PrefixMatchingArchiveFilter implements EntryFilter {\n      private final String prefix;\n      private final PropertiesLauncher.ArchiveEntryFilter filter;\n\n      private PrefixMatchingArchiveFilter(String prefix) {\n         this.filter = new PropertiesLauncher.ArchiveEntryFilter();\n         this.prefix = prefix;\n      }\n\n      public boolean matches(Entry entry) {\n         if (entry.isDirectory()) {\n            return entry.getName().equals(this.prefix);\n         } else {\n            return entry.getName().startsWith(this.prefix) && this.filter.matches(entry);\n         }\n      }\n\n      // $FF: synthetic method\n      PrefixMatchingArchiveFilter(String x0, Object x1) {\n         this(x0);\n      }\n   }\n\n   private class ClassPathArchives implements Iterable<Archive> {\n      private final List<Archive> classPathArchives = new ArrayList();\n      private final List<JarFileArchive> jarFileArchives = new ArrayList();\n\n      ClassPathArchives() throws Exception {\n         Iterator var2 = PropertiesLauncher.this.paths.iterator();\n\n         while(var2.hasNext()) {\n            String path = (String)var2.next();\n            Iterator var4 = this.getClassPathArchives(path).iterator();\n\n            while(var4.hasNext()) {\n               Archive archive = (Archive)var4.next();\n               this.addClassPathArchive(archive);\n            }\n         }\n\n         this.addNestedEntries();\n      }\n\n      private void addClassPathArchive(Archive archive) throws IOException {\n         if (!(archive instanceof ExplodedArchive)) {\n            this.classPathArchives.add(archive);\n         } else {\n            this.classPathArchives.add(archive);\n            this.classPathArchives.addAll(this.asList(archive.getNestedArchives((EntryFilter)null, new PropertiesLauncher.ArchiveEntryFilter())));\n         }\n      }\n\n      private List<Archive> getClassPathArchives(String path) throws Exception {\n         String root = PropertiesLauncher.this.cleanupPath(PropertiesLauncher.this.handleUrl(path));\n         List<Archive> lib = new ArrayList();\n         File file = new File(root);\n         if (!\"/\".equals(root)) {\n            if (!this.isAbsolutePath(root)) {\n               file = new File(PropertiesLauncher.this.home, root);\n            }\n\n            if (file.isDirectory()) {\n               PropertiesLauncher.this.debug(\"Adding classpath entries from \" + file);\n               Archive archivex = new ExplodedArchive(file, false);\n               lib.add(archivex);\n            }\n         }\n\n         Archive archive = this.getArchive(file);\n         if (archive != null) {\n            PropertiesLauncher.this.debug(\"Adding classpath entries from archive \" + archive.getUrl() + root);\n            lib.add(archive);\n         }\n\n         List<Archive> nestedArchives = this.getNestedArchives(root);\n         if (nestedArchives != null) {\n            PropertiesLauncher.this.debug(\"Adding classpath entries from nested \" + root);\n            lib.addAll(nestedArchives);\n         }\n\n         return lib;\n      }\n\n      private boolean isAbsolutePath(String root) {\n         return root.contains(\":\") || root.startsWith(\"/\");\n      }\n\n      private Archive getArchive(File file) throws IOException {\n         if (this.isNestedArchivePath(file)) {\n            return null;\n         } else {\n            String name = file.getName().toLowerCase(Locale.ENGLISH);\n            return !name.endsWith(\".jar\") && !name.endsWith(\".zip\") ? null : this.getJarFileArchive(file);\n         }\n      }\n\n      private boolean isNestedArchivePath(File file) {\n         return file.getPath().contains(PropertiesLauncher.NESTED_ARCHIVE_SEPARATOR);\n      }\n\n      private List<Archive> getNestedArchives(String path) throws Exception {\n         Archive parent = PropertiesLauncher.this.parent;\n         String root = path;\n         if ((path.equals(\"/\") || !path.startsWith(\"/\")) && !((Archive)parent).getUrl().toURI().equals(PropertiesLauncher.this.home.toURI())) {\n            int index = path.indexOf(33);\n            File file;\n            if (index != -1) {\n               file = new File(PropertiesLauncher.this.home, path.substring(0, index));\n               if (path.startsWith(\"jar:file:\")) {\n                  file = new File(path.substring(\"jar:file:\".length(), index));\n               }\n\n               parent = this.getJarFileArchive(file);\n\n               for(root = path.substring(index + 1); root.startsWith(\"/\"); root = root.substring(1)) {\n                  ;\n               }\n            }\n\n            if (root.endsWith(\".jar\")) {\n               file = new File(PropertiesLauncher.this.home, root);\n               if (file.exists()) {\n                  parent = this.getJarFileArchive(file);\n                  root = \"\";\n               }\n            }\n\n            if (root.equals(\"/\") || root.equals(\"./\") || root.equals(\".\")) {\n               root = \"\";\n            }\n\n            EntryFilter filter = new PropertiesLauncher.PrefixMatchingArchiveFilter(root);\n            List<Archive> archives = this.asList(((Archive)parent).getNestedArchives((EntryFilter)null, filter));\n            if ((root == null || root.isEmpty() || \".\".equals(root)) && !path.endsWith(\".jar\") && parent != PropertiesLauncher.this.parent) {\n               archives.add(parent);\n            }\n\n            return archives;\n         } else {\n            return null;\n         }\n      }\n\n      private void addNestedEntries() {\n         try {\n            Iterator archives = PropertiesLauncher.this.parent.getNestedArchives((EntryFilter)null, JarLauncher.NESTED_ARCHIVE_ENTRY_FILTER);\n\n            while(archives.hasNext()) {\n               this.classPathArchives.add(archives.next());\n            }\n         } catch (IOException var2) {\n            ;\n         }\n\n      }\n\n      private List<Archive> asList(Iterator<Archive> iterator) {\n         ArrayList list = new ArrayList();\n\n         while(iterator.hasNext()) {\n            list.add(iterator.next());\n         }\n\n         return list;\n      }\n\n      private JarFileArchive getJarFileArchive(File file) throws IOException {\n         JarFileArchive archive = new JarFileArchive(file);\n         this.jarFileArchives.add(archive);\n         return archive;\n      }\n\n      public Iterator<Archive> iterator() {\n         return this.classPathArchives.iterator();\n      }\n\n      void close() throws IOException {\n         Iterator var1 = this.jarFileArchives.iterator();\n\n         while(var1.hasNext()) {\n            JarFileArchive archive = (JarFileArchive)var1.next();\n            archive.close();\n         }\n\n      }\n   }\n}\n"}