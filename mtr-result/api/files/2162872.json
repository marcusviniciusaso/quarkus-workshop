{"id":"2162872","content":"package org.springdoc.api;\n\nimport com.fasterxml.jackson.annotation.JsonView;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLGenerator.Feature;\nimport io.swagger.v3.core.filter.SpecFilter;\nimport io.swagger.v3.core.util.ReflectionUtils;\nimport io.swagger.v3.oas.annotations.Hidden;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.callbacks.Callback;\nimport io.swagger.v3.oas.annotations.enums.ParameterIn;\nimport io.swagger.v3.oas.annotations.parameters.RequestBody;\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.OpenAPI;\nimport io.swagger.v3.oas.models.PathItem;\nimport io.swagger.v3.oas.models.Paths;\nimport io.swagger.v3.oas.models.SpecVersion;\nimport io.swagger.v3.oas.models.PathItem.HttpMethod;\nimport io.swagger.v3.oas.models.media.StringSchema;\nimport io.swagger.v3.oas.models.parameters.Parameter;\nimport io.swagger.v3.oas.models.responses.ApiResponses;\nimport io.swagger.v3.oas.models.servers.Server;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Method;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URLDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.Map.Entry;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.BinaryOperator;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springdoc.core.AbstractRequestService;\nimport org.springdoc.core.Constants;\nimport org.springdoc.core.GenericParameterService;\nimport org.springdoc.core.GenericResponseService;\nimport org.springdoc.core.MethodAttributes;\nimport org.springdoc.core.OpenAPIService;\nimport org.springdoc.core.OperationService;\nimport org.springdoc.core.SpringDocConfigProperties;\nimport org.springdoc.core.SpringDocProviders;\nimport org.springdoc.core.SpringDocUtils;\nimport org.springdoc.core.SpringDocConfigProperties.GroupConfig;\nimport org.springdoc.core.SpringDocConfigProperties.ApiDocs.OpenApiVersion;\nimport org.springdoc.core.annotations.RouterOperations;\nimport org.springdoc.core.converters.SchemaPropertyDeprecatingConverter;\nimport org.springdoc.core.customizers.DataRestRouterOperationCustomizer;\nimport org.springdoc.core.customizers.OpenApiLocaleCustomizer;\nimport org.springdoc.core.customizers.OperationCustomizer;\nimport org.springdoc.core.customizers.RouterOperationCustomizer;\nimport org.springdoc.core.customizers.SpringDocCustomizers;\nimport org.springdoc.core.fn.AbstractRouterFunctionVisitor;\nimport org.springdoc.core.fn.RouterFunctionData;\nimport org.springdoc.core.fn.RouterOperation;\nimport org.springdoc.core.providers.ActuatorProvider;\nimport org.springdoc.core.providers.CloudFunctionProvider;\nimport org.springdoc.core.providers.JavadocProvider;\nimport org.springdoc.core.providers.ObjectMapperProvider;\nimport org.springframework.aop.support.AopUtils;\nimport org.springframework.beans.factory.ObjectFactory;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.core.annotation.AnnotatedElementUtils;\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.core.env.Environment;\nimport org.springframework.util.AntPathMatcher;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.method.HandlerMethod;\n\npublic abstract class AbstractOpenApiResource extends SpecFilter {\n   private static final Logger LOGGER = LoggerFactory.getLogger(AbstractOpenApiResource.class);\n   private static final Set<Class<?>> ADDITIONAL_REST_CONTROLLERS = new CopyOnWriteArraySet();\n   private static final Set<Class<?>> HIDDEN_REST_CONTROLLERS = new CopyOnWriteArraySet();\n   private static Class<?> modelAndViewClass;\n   protected final SpringDocConfigProperties springDocConfigProperties;\n   protected final String groupName;\n   protected final SpringDocProviders springDocProviders;\n   private final ObjectFactory<OpenAPIService> openAPIBuilderObjectFactory;\n   private final AbstractRequestService requestBuilder;\n   private final GenericResponseService responseBuilder;\n   private final OperationService operationParser;\n   private final AntPathMatcher antPathMatcher = new AntPathMatcher();\n   protected OpenAPIService openAPIService;\n   protected final SpringDocCustomizers springDocCustomizers;\n   private final Lock reentrantLock = new ReentrantLock();\n\n   protected AbstractOpenApiResource(String groupName, ObjectFactory<OpenAPIService> openAPIBuilderObjectFactory, AbstractRequestService requestBuilder, GenericResponseService responseBuilder, OperationService operationParser, SpringDocConfigProperties springDocConfigProperties, SpringDocProviders springDocProviders, SpringDocCustomizers springDocCustomizers) {\n      this.groupName = (String)Objects.requireNonNull(groupName, \"groupName\");\n      this.openAPIBuilderObjectFactory = openAPIBuilderObjectFactory;\n      this.openAPIService = (OpenAPIService)openAPIBuilderObjectFactory.getObject();\n      this.requestBuilder = requestBuilder;\n      this.responseBuilder = responseBuilder;\n      this.operationParser = operationParser;\n      this.springDocProviders = springDocProviders;\n      this.springDocConfigProperties = springDocConfigProperties;\n      this.springDocCustomizers = springDocCustomizers;\n      if (springDocConfigProperties.isPreLoadingEnabled()) {\n         if (CollectionUtils.isEmpty(springDocConfigProperties.getPreLoadingLocales())) {\n            Executors.newSingleThreadExecutor().execute(this::getOpenApi);\n         } else {\n            Iterator var9 = springDocConfigProperties.getPreLoadingLocales().iterator();\n\n            while(var9.hasNext()) {\n               String locale = (String)var9.next();\n               Executors.newSingleThreadExecutor().execute(() -> {\n                  this.getOpenApi(Locale.forLanguageTag(locale));\n               });\n            }\n         }\n      }\n\n   }\n\n   public static void addRestControllers(Class... classes) {\n      ADDITIONAL_REST_CONTROLLERS.addAll(Arrays.asList(classes));\n   }\n\n   public static void addHiddenRestControllers(Class... classes) {\n      HIDDEN_REST_CONTROLLERS.addAll(Arrays.asList(classes));\n   }\n\n   public static void addHiddenRestControllers(String... classes) {\n      Set<Class<?>> hiddenClasses = new HashSet();\n      String[] var2 = classes;\n      int var3 = classes.length;\n\n      for(int var4 = 0; var4 < var3; ++var4) {\n         String aClass = var2[var4];\n\n         try {\n            hiddenClasses.add(Class.forName(aClass));\n         } catch (ClassNotFoundException var7) {\n            LOGGER.warn(\"The following class doesn't exist and cannot be hidden: {}\", aClass);\n         }\n      }\n\n      HIDDEN_REST_CONTROLLERS.addAll(hiddenClasses);\n   }\n\n   public static boolean containsResponseBody(HandlerMethod handlerMethod) {\n      ResponseBody responseBodyAnnotation = (ResponseBody)AnnotationUtils.findAnnotation(handlerMethod.getBeanType(), ResponseBody.class);\n      if (responseBodyAnnotation == null) {\n         responseBodyAnnotation = (ResponseBody)AnnotationUtils.findAnnotation(handlerMethod.getMethod(), ResponseBody.class);\n      }\n\n      return responseBodyAnnotation != null;\n   }\n\n   public static boolean isHiddenRestControllers(Class<?> rawClass) {\n      return HIDDEN_REST_CONTROLLERS.stream().anyMatch((clazz) -> {\n         return clazz.isAssignableFrom(rawClass);\n      });\n   }\n\n   public static void setModelAndViewClass(Class<?> modelAndViewClass) {\n      modelAndViewClass = modelAndViewClass;\n   }\n\n   private void getOpenApi() {\n      this.getOpenApi(Locale.getDefault());\n   }\n\n   protected OpenAPI getOpenApi(Locale locale) {\n      this.reentrantLock.lock();\n\n      OpenAPI var16;\n      try {\n         Locale finalLocale = locale == null ? Locale.getDefault() : locale;\n         OpenAPI openAPI;\n         if (this.openAPIService.getCachedOpenAPI(finalLocale) != null && !this.springDocConfigProperties.isCacheDisabled()) {\n            LOGGER.debug(\"Fetching openApi document from cache\");\n            openAPI = this.openAPIService.getCachedOpenAPI(finalLocale);\n            this.openAPIService.updateServers(openAPI);\n         } else {\n            Instant start = Instant.now();\n            openAPI = this.openAPIService.build(finalLocale);\n            Map<String, Object> mappingsMap = (Map)this.openAPIService.getMappingsMap().entrySet().stream().filter((controller) -> {\n               return AnnotationUtils.findAnnotation(controller.getValue().getClass(), Hidden.class) == null;\n            }).filter((controller) -> {\n               return !isHiddenRestControllers(controller.getValue().getClass());\n            }).collect(Collectors.toMap(Entry::getKey, Entry::getValue, (a1, a2) -> {\n               return a1;\n            }));\n            Map<String, Object> findControllerAdvice = this.openAPIService.getControllerAdviceMap();\n            if (OpenApiVersion.OPENAPI_3_1 == this.springDocConfigProperties.getApiDocs().getVersion()) {\n               openAPI.openapi(OpenApiVersion.OPENAPI_3_1.getVersion());\n               openAPI.specVersion(SpecVersion.V31);\n            }\n\n            if (this.springDocConfigProperties.isDefaultOverrideWithGenericResponse()) {\n               if (!CollectionUtils.isEmpty(mappingsMap)) {\n                  findControllerAdvice.putAll(mappingsMap);\n               }\n\n               this.responseBuilder.buildGenericResponse(openAPI.getComponents(), findControllerAdvice, finalLocale);\n            }\n\n            this.getPaths(mappingsMap, finalLocale, openAPI);\n            Optional<CloudFunctionProvider> cloudFunctionProviderOptional = this.springDocProviders.getSpringCloudFunctionProvider();\n            cloudFunctionProviderOptional.ifPresent((cloudFunctionProvider) -> {\n               List<RouterOperation> routerOperationList = cloudFunctionProvider.getRouterOperations(openAPI);\n               if (!CollectionUtils.isEmpty(routerOperationList)) {\n                  this.calculatePath(routerOperationList, locale, openAPI);\n               }\n\n            });\n            if (!CollectionUtils.isEmpty(openAPI.getServers())) {\n               this.openAPIService.setServersPresent(true);\n            } else {\n               this.openAPIService.setServersPresent(false);\n            }\n\n            this.openAPIService.updateServers(openAPI);\n            if (this.springDocConfigProperties.isRemoveBrokenReferenceDefinitions()) {\n               this.removeBrokenReferenceDefinitions(openAPI);\n            }\n\n            List<Server> servers = openAPI.getServers();\n            List serversCopy = null;\n\n            try {\n               serversCopy = (List)this.springDocProviders.jsonMapper().readValue(this.springDocProviders.jsonMapper().writeValueAsString(servers), new TypeReference<List<Server>>() {\n               });\n            } catch (JsonProcessingException var14) {\n               LOGGER.warn(\"Json Processing Exception occurred: {}\", var14.getMessage());\n            }\n\n            this.openAPIService.getContext().getBeansOfType(OpenApiLocaleCustomizer.class).values().forEach((openApiLocaleCustomizer) -> {\n               openApiLocaleCustomizer.customise(openAPI, finalLocale);\n            });\n            this.springDocCustomizers.getOpenApiCustomizers().ifPresent((apiCustomisers) -> {\n               apiCustomisers.forEach((openApiCustomiser) -> {\n                  openApiCustomiser.customise(openAPI);\n               });\n            });\n            if (!CollectionUtils.isEmpty(openAPI.getServers()) && !openAPI.getServers().equals(serversCopy)) {\n               this.openAPIService.setServersPresent(true);\n            }\n\n            this.openAPIService.setCachedOpenAPI(openAPI, finalLocale);\n            LOGGER.info(\"Init duration for springdoc-openapi is: {} ms\", Duration.between(start, Instant.now()).toMillis());\n         }\n\n         var16 = openAPI;\n      } finally {\n         this.reentrantLock.unlock();\n      }\n\n      return var16;\n   }\n\n   protected abstract void getPaths(Map<String, Object> var1, Locale var2, OpenAPI var3);\n\n   protected void calculatePath(HandlerMethod handlerMethod, RouterOperation routerOperation, Locale locale, OpenAPI openAPI) {\n      routerOperation = this.customizeRouterOperation(routerOperation, handlerMethod);\n      String operationPath = routerOperation.getPath();\n      Set<RequestMethod> requestMethods = new TreeSet(Arrays.asList(routerOperation.getMethods()));\n      Operation apiOperation = routerOperation.getOperation();\n      String[] methodConsumes = routerOperation.getConsumes();\n      String[] methodProduces = routerOperation.getProduces();\n      String[] headers = routerOperation.getHeaders();\n      Map<String, String> queryParams = routerOperation.getQueryParams();\n      Components components = openAPI.getComponents();\n      Paths paths = openAPI.getPaths();\n      Map<HttpMethod, io.swagger.v3.oas.models.Operation> operationMap = null;\n      if (paths.containsKey(operationPath)) {\n         PathItem pathItem = (PathItem)paths.get(operationPath);\n         operationMap = pathItem.readOperationsMap();\n      }\n\n      JavadocProvider javadocProvider = this.operationParser.getJavadocProvider();\n      Iterator var16 = requestMethods.iterator();\n\n      while(true) {\n         RequestMethod requestMethod;\n         io.swagger.v3.oas.models.Operation existingOperation;\n         Method method;\n         do {\n            if (!var16.hasNext()) {\n               return;\n            }\n\n            requestMethod = (RequestMethod)var16.next();\n            existingOperation = this.getExistingOperation(operationMap, requestMethod);\n            method = handlerMethod.getMethod();\n         } while(this.operationParser.isHidden(method));\n\n         RequestMapping reqMappingClass = (RequestMapping)AnnotatedElementUtils.findMergedAnnotation(handlerMethod.getBeanType(), RequestMapping.class);\n         MethodAttributes methodAttributes = new MethodAttributes(this.springDocConfigProperties.getDefaultConsumesMediaType(), this.springDocConfigProperties.getDefaultProducesMediaType(), methodConsumes, methodProduces, headers, locale);\n         methodAttributes.setMethodOverloaded(existingOperation != null);\n         if (javadocProvider != null) {\n            methodAttributes.setJavadocReturn(javadocProvider.getMethodJavadocReturn(handlerMethod.getMethod()));\n         }\n\n         if (reqMappingClass != null) {\n            methodAttributes.setClassConsumes(reqMappingClass.consumes());\n            methodAttributes.setClassProduces(reqMappingClass.produces());\n         }\n\n         methodAttributes.calculateHeadersForClass(method.getDeclaringClass());\n         methodAttributes.calculateConsumesProduces(method);\n         io.swagger.v3.oas.models.Operation operation = existingOperation != null ? existingOperation : new io.swagger.v3.oas.models.Operation();\n         if (SchemaPropertyDeprecatingConverter.isDeprecated(method)) {\n            operation.setDeprecated(true);\n         }\n\n         if (apiOperation == null || StringUtils.isBlank(apiOperation.operationId())) {\n            apiOperation = (Operation)AnnotatedElementUtils.findMergedAnnotation(method, Operation.class);\n         }\n\n         this.calculateJsonView(apiOperation, methodAttributes, method);\n         if (apiOperation != null) {\n            openAPI = this.operationParser.parse(apiOperation, operation, openAPI, methodAttributes);\n         }\n\n         this.fillParametersList(operation, queryParams, methodAttributes);\n         operation = this.openAPIService.buildTags(handlerMethod, operation, openAPI, locale);\n         RequestBody requestBodyDoc = (RequestBody)AnnotatedElementUtils.findMergedAnnotation(method, RequestBody.class);\n         this.requestBuilder.getRequestBodyBuilder().buildRequestBodyFromDoc(requestBodyDoc, methodAttributes, components, methodAttributes.getJsonViewAnnotationForRequestBody(), locale).ifPresent(operation::setRequestBody);\n         operation = this.requestBuilder.build(handlerMethod, requestMethod, operation, methodAttributes, openAPI);\n         ApiResponses apiResponses = this.responseBuilder.build(components, handlerMethod, operation, methodAttributes);\n         operation.setResponses(apiResponses);\n         if (javadocProvider != null) {\n            String description = javadocProvider.getMethodJavadocDescription(handlerMethod.getMethod());\n            String summary = javadocProvider.getFirstSentence(description);\n            boolean emptyOverrideDescription = StringUtils.isEmpty(operation.getDescription());\n            boolean emptyOverrideSummary = StringUtils.isEmpty(operation.getSummary());\n            if (!StringUtils.isEmpty(description) && emptyOverrideDescription) {\n               operation.setDescription(description);\n            }\n\n            if (!StringUtils.isEmpty(summary) && emptyOverrideSummary && emptyOverrideDescription) {\n               operation.setSummary(javadocProvider.getFirstSentence(description));\n            }\n         }\n\n         Set<Callback> apiCallbacks = AnnotatedElementUtils.findMergedRepeatableAnnotations(method, Callback.class);\n         this.buildCallbacks(openAPI, methodAttributes, operation, apiCallbacks);\n         operation = this.customizeOperation(operation, handlerMethod);\n         PathItem pathItemObject = this.buildPathItem(requestMethod, operation, operationPath, paths);\n         paths.addPathItem(operationPath, pathItemObject);\n      }\n   }\n\n   private void buildCallbacks(OpenAPI openAPI, MethodAttributes methodAttributes, io.swagger.v3.oas.models.Operation operation, Set<Callback> apiCallbacks) {\n      if (!CollectionUtils.isEmpty(apiCallbacks)) {\n         this.operationParser.buildCallbacks(apiCallbacks, openAPI, methodAttributes).ifPresent(operation::setCallbacks);\n      }\n\n   }\n\n   protected void calculatePath(List<RouterOperation> routerOperationList, Locale locale, OpenAPI openAPI) {\n      ApplicationContext applicationContext = this.openAPIService.getContext();\n      if (!CollectionUtils.isEmpty(routerOperationList)) {\n         Collections.sort(routerOperationList);\n         Iterator var5 = routerOperationList.iterator();\n\n         while(true) {\n            while(var5.hasNext()) {\n               RouterOperation routerOperation = (RouterOperation)var5.next();\n               if (routerOperation.getBeanClass() != null && !Void.class.equals(routerOperation.getBeanClass())) {\n                  Object handlerBean = applicationContext.getBean(routerOperation.getBeanClass());\n                  HandlerMethod handlerMethod = null;\n                  if (StringUtils.isNotBlank(routerOperation.getBeanMethod())) {\n                     try {\n                        if (ArrayUtils.isEmpty(routerOperation.getParameterTypes())) {\n                           Method[] declaredMethods = AopUtils.getTargetClass(handlerBean).getDeclaredMethods();\n                           Optional<Method> methodOptional = Arrays.stream(declaredMethods).filter((method) -> {\n                              return routerOperation.getBeanMethod().equals(method.getName()) && method.getParameters().length == 0;\n                           }).findAny();\n                           if (!methodOptional.isPresent()) {\n                              methodOptional = Arrays.stream(declaredMethods).filter((method1) -> {\n                                 return routerOperation.getBeanMethod().equals(method1.getName());\n                              }).findAny();\n                           }\n\n                           if (methodOptional.isPresent()) {\n                              handlerMethod = new HandlerMethod(handlerBean, (Method)methodOptional.get());\n                           }\n                        } else {\n                           handlerMethod = new HandlerMethod(handlerBean, routerOperation.getBeanMethod(), routerOperation.getParameterTypes());\n                        }\n                     } catch (NoSuchMethodException var11) {\n                        LOGGER.error(var11.getMessage());\n                     }\n\n                     if (handlerMethod != null && this.isFilterCondition(handlerMethod, routerOperation.getPath(), routerOperation.getProduces(), routerOperation.getConsumes(), routerOperation.getHeaders())) {\n                        this.calculatePath(handlerMethod, routerOperation, locale, openAPI);\n                     }\n                  }\n               } else if (routerOperation.getOperation() != null && StringUtils.isNotBlank(routerOperation.getOperation().operationId()) && this.isFilterCondition(routerOperation.getPath(), routerOperation.getProduces(), routerOperation.getConsumes(), routerOperation.getHeaders())) {\n                  this.calculatePath(routerOperation, locale, openAPI);\n               } else if (routerOperation.getOperationModel() != null && StringUtils.isNotBlank(routerOperation.getOperationModel().getOperationId()) && this.isFilterCondition(routerOperation.getPath(), routerOperation.getProduces(), routerOperation.getConsumes(), routerOperation.getHeaders())) {\n                  this.calculatePath(routerOperation, locale, openAPI);\n               }\n            }\n\n            return;\n         }\n      }\n   }\n\n   protected void calculatePath(RouterOperation routerOperation, Locale locale, OpenAPI openAPI) {\n      routerOperation = this.customizeDataRestRouterOperation(routerOperation);\n      String operationPath = routerOperation.getPath();\n      Operation apiOperation = routerOperation.getOperation();\n      String[] methodConsumes = routerOperation.getConsumes();\n      String[] methodProduces = routerOperation.getProduces();\n      String[] headers = routerOperation.getHeaders();\n      Map<String, String> queryParams = routerOperation.getQueryParams();\n      Paths paths = openAPI.getPaths();\n      Map<HttpMethod, io.swagger.v3.oas.models.Operation> operationMap = null;\n      if (paths.containsKey(operationPath)) {\n         PathItem pathItem = (PathItem)paths.get(operationPath);\n         operationMap = pathItem.readOperationsMap();\n      }\n\n      RequestMethod[] var21 = routerOperation.getMethods();\n      int var13 = var21.length;\n\n      for(int var14 = 0; var14 < var13; ++var14) {\n         RequestMethod requestMethod = var21[var14];\n         io.swagger.v3.oas.models.Operation existingOperation = this.getExistingOperation(operationMap, requestMethod);\n         MethodAttributes methodAttributes = new MethodAttributes(this.springDocConfigProperties.getDefaultConsumesMediaType(), this.springDocConfigProperties.getDefaultProducesMediaType(), methodConsumes, methodProduces, headers, locale);\n         methodAttributes.setMethodOverloaded(existingOperation != null);\n         io.swagger.v3.oas.models.Operation operation = this.getOperation(routerOperation, existingOperation);\n         if (apiOperation != null) {\n            openAPI = this.operationParser.parse(apiOperation, operation, openAPI, methodAttributes);\n         }\n\n         String operationId = this.operationParser.getOperationId(operation.getOperationId(), openAPI);\n         operation.setOperationId(operationId);\n         this.fillParametersList(operation, queryParams, methodAttributes);\n         if (!CollectionUtils.isEmpty(operation.getParameters())) {\n            operation.getParameters().stream().filter((parameter) -> {\n               return StringUtils.isEmpty(parameter.get$ref());\n            }).forEach((parameter) -> {\n               if (parameter.getSchema() == null) {\n                  parameter.setSchema(new StringSchema());\n               }\n\n               if (parameter.getIn() == null) {\n                  parameter.setIn(ParameterIn.QUERY.toString());\n               }\n\n            });\n         }\n\n         PathItem pathItemObject = this.buildPathItem(requestMethod, operation, operationPath, paths);\n         paths.addPathItem(operationPath, pathItemObject);\n      }\n\n   }\n\n   protected void calculatePath(HandlerMethod handlerMethod, String operationPath, Set<RequestMethod> requestMethods, String[] consumes, String[] produces, String[] headers, String[] params, Locale locale, OpenAPI openAPI) {\n      this.calculatePath(handlerMethod, new RouterOperation(operationPath, (RequestMethod[])requestMethods.toArray(new RequestMethod[requestMethods.size()]), consumes, produces, headers, params), locale, openAPI);\n   }\n\n   protected void getRouterFunctionPaths(String beanName, AbstractRouterFunctionVisitor routerFunctionVisitor, Locale locale, OpenAPI openAPI) {\n      boolean withRouterOperation = routerFunctionVisitor.getRouterFunctionDatas().stream().anyMatch((routerFunctionData) -> {\n         return routerFunctionData.getAttributes().containsKey(Constants.OPERATION_ATTRIBUTE);\n      });\n      if (withRouterOperation) {\n         List<RouterOperation> operationList = (List)routerFunctionVisitor.getRouterFunctionDatas().stream().map(RouterOperation::new).collect(Collectors.toList());\n         this.calculatePath(operationList, locale, openAPI);\n      } else {\n         List<org.springdoc.core.annotations.RouterOperation> routerOperationList = new ArrayList();\n         ApplicationContext applicationContext = this.openAPIService.getContext();\n         RouterOperations routerOperations = (RouterOperations)applicationContext.findAnnotationOnBean(beanName, RouterOperations.class);\n         if (routerOperations == null) {\n            org.springdoc.core.annotations.RouterOperation routerOperation = (org.springdoc.core.annotations.RouterOperation)applicationContext.findAnnotationOnBean(beanName, org.springdoc.core.annotations.RouterOperation.class);\n            if (routerOperation != null) {\n               routerOperationList.add(routerOperation);\n            }\n         } else {\n            routerOperationList.addAll(Arrays.asList(routerOperations.value()));\n         }\n\n         if (routerOperationList.size() == 1) {\n            this.calculatePath((List)routerOperationList.stream().map((routerOperationx) -> {\n               return new RouterOperation(routerOperationx, (RouterFunctionData)routerFunctionVisitor.getRouterFunctionDatas().get(0));\n            }).collect(Collectors.toList()), locale, openAPI);\n         } else {\n            List<RouterOperation> operationList = (List)routerOperationList.stream().map(RouterOperation::new).collect(Collectors.toList());\n            this.mergeRouters(routerFunctionVisitor.getRouterFunctionDatas(), operationList);\n            this.calculatePath(operationList, locale, openAPI);\n         }\n      }\n\n   }\n\n   protected boolean isFilterCondition(HandlerMethod handlerMethod, String operationPath, String[] produces, String[] consumes, String[] headers) {\n      return this.isMethodToFilter(handlerMethod) && this.isPackageToScan(handlerMethod.getBeanType().getPackage()) && this.isFilterCondition(operationPath, produces, consumes, headers);\n   }\n\n   protected boolean isMethodToFilter(HandlerMethod handlerMethod) {\n      return ((Boolean)this.springDocCustomizers.getMethodFilters().map(Collection::stream).map((stream) -> {\n         return stream.allMatch((m) -> {\n            return m.isMethodToInclude(handlerMethod.getMethod());\n         });\n      }).orElse(true)).booleanValue();\n   }\n\n   protected boolean isConditionToMatch(String[] existingConditions, AbstractOpenApiResource.ConditionType conditionType) {\n      List<String> conditionsToMatch = this.getConditionsToMatch(conditionType);\n      if (CollectionUtils.isEmpty(conditionsToMatch)) {\n         Optional<GroupConfig> optionalGroupConfig = this.springDocConfigProperties.getGroupConfigs().stream().filter((groupConfig) -> {\n            return this.groupName.equals(groupConfig.getGroup());\n         }).findAny();\n         if (optionalGroupConfig.isPresent()) {\n            conditionsToMatch = this.getConditionsToMatch(conditionType, (GroupConfig)optionalGroupConfig.get());\n         }\n      }\n\n      return CollectionUtils.isEmpty(conditionsToMatch) || !ArrayUtils.isEmpty(existingConditions) && conditionsToMatch.size() == existingConditions.length && conditionsToMatch.containsAll(Arrays.asList(existingConditions));\n   }\n\n   protected boolean isPackageToScan(Package aPackage) {\n      if (aPackage == null) {\n         return true;\n      } else {\n         String packageName = aPackage.getName();\n         List<String> packagesToScan = this.springDocConfigProperties.getPackagesToScan();\n         List<String> packagesToExclude = this.springDocConfigProperties.getPackagesToExclude();\n         Optional optionalGroupConfig;\n         if (CollectionUtils.isEmpty(packagesToScan)) {\n            optionalGroupConfig = this.springDocConfigProperties.getGroupConfigs().stream().filter((groupConfig) -> {\n               return this.groupName.equals(groupConfig.getGroup());\n            }).findAny();\n            if (optionalGroupConfig.isPresent()) {\n               packagesToScan = ((GroupConfig)optionalGroupConfig.get()).getPackagesToScan();\n            }\n         }\n\n         if (CollectionUtils.isEmpty(packagesToExclude)) {\n            optionalGroupConfig = this.springDocConfigProperties.getGroupConfigs().stream().filter((groupConfig) -> {\n               return this.groupName.equals(groupConfig.getGroup());\n            }).findAny();\n            if (optionalGroupConfig.isPresent()) {\n               packagesToExclude = ((GroupConfig)optionalGroupConfig.get()).getPackagesToExclude();\n            }\n         }\n\n         boolean include = CollectionUtils.isEmpty(packagesToScan) || packagesToScan.stream().anyMatch((pack) -> {\n            return packageName.equals(pack) || packageName.startsWith(pack + \".\");\n         });\n         boolean exclude = !CollectionUtils.isEmpty(packagesToExclude) && packagesToExclude.stream().anyMatch((pack) -> {\n            return packageName.equals(pack) || packageName.startsWith(pack + \".\");\n         });\n         return include && !exclude;\n      }\n   }\n\n   protected boolean isPathToMatch(String operationPath) {\n      List<String> pathsToMatch = this.springDocConfigProperties.getPathsToMatch();\n      List<String> pathsToExclude = this.springDocConfigProperties.getPathsToExclude();\n      Optional optionalGroupConfig;\n      if (CollectionUtils.isEmpty(pathsToMatch)) {\n         optionalGroupConfig = this.springDocConfigProperties.getGroupConfigs().stream().filter((groupConfig) -> {\n            return this.groupName.equals(groupConfig.getGroup());\n         }).findAny();\n         if (optionalGroupConfig.isPresent()) {\n            pathsToMatch = ((GroupConfig)optionalGroupConfig.get()).getPathsToMatch();\n         }\n      }\n\n      if (CollectionUtils.isEmpty(pathsToExclude)) {\n         optionalGroupConfig = this.springDocConfigProperties.getGroupConfigs().stream().filter((groupConfig) -> {\n            return this.groupName.equals(groupConfig.getGroup());\n         }).findAny();\n         if (optionalGroupConfig.isPresent()) {\n            pathsToExclude = ((GroupConfig)optionalGroupConfig.get()).getPathsToExclude();\n         }\n      }\n\n      boolean include = CollectionUtils.isEmpty(pathsToMatch) || pathsToMatch.stream().anyMatch((pattern) -> {\n         return this.antPathMatcher.match(pattern, operationPath);\n      });\n      boolean exclude = !CollectionUtils.isEmpty(pathsToExclude) && pathsToExclude.stream().anyMatch((pattern) -> {\n         return this.antPathMatcher.match(pattern, operationPath);\n      });\n      return include && !exclude;\n   }\n\n   protected String decode(String requestURI) {\n      try {\n         return URLDecoder.decode(requestURI, StandardCharsets.UTF_8.toString());\n      } catch (UnsupportedEncodingException var3) {\n         return requestURI;\n      }\n   }\n\n   protected boolean isAdditionalRestController(Class<?> rawClass) {\n      return ADDITIONAL_REST_CONTROLLERS.stream().anyMatch((clazz) -> {\n         return clazz.isAssignableFrom(rawClass);\n      });\n   }\n\n   protected boolean isRestController(Map<String, Object> restControllers, HandlerMethod handlerMethod, String operationPath) {\n      boolean hasOperationAnnotation = AnnotatedElementUtils.hasAnnotation(handlerMethod.getMethod(), Operation.class);\n      return ((containsResponseBody(handlerMethod) || hasOperationAnnotation) && restControllers.containsKey(handlerMethod.getBean().toString()) || this.isAdditionalRestController(handlerMethod.getBeanType())) && operationPath.startsWith(\"/\") && (this.springDocConfigProperties.isModelAndViewAllowed() || modelAndViewClass == null || !modelAndViewClass.isAssignableFrom(handlerMethod.getMethod().getReturnType()));\n   }\n\n   protected Set<RequestMethod> getDefaultAllowedHttpMethods() {\n      RequestMethod[] allowedRequestMethods = new RequestMethod[]{RequestMethod.GET, RequestMethod.POST, RequestMethod.PUT, RequestMethod.PATCH, RequestMethod.DELETE, RequestMethod.OPTIONS, RequestMethod.HEAD};\n      return new HashSet(Arrays.asList(allowedRequestMethods));\n   }\n\n   protected io.swagger.v3.oas.models.Operation customizeOperation(io.swagger.v3.oas.models.Operation operation, HandlerMethod handlerMethod) {\n      Optional<List<OperationCustomizer>> optionalOperationCustomizers = this.springDocCustomizers.getOperationCustomizers();\n      if (optionalOperationCustomizers.isPresent()) {\n         List<OperationCustomizer> operationCustomizerList = (List)optionalOperationCustomizers.get();\n\n         OperationCustomizer operationCustomizer;\n         for(Iterator var5 = operationCustomizerList.iterator(); var5.hasNext(); operation = operationCustomizer.customize(operation, handlerMethod)) {\n            operationCustomizer = (OperationCustomizer)var5.next();\n         }\n      }\n\n      return operation;\n   }\n\n   protected RouterOperation customizeRouterOperation(RouterOperation routerOperation, HandlerMethod handlerMethod) {\n      Optional<List<RouterOperationCustomizer>> optionalRouterOperationCustomizers = this.springDocCustomizers.getRouterOperationCustomizers();\n      if (optionalRouterOperationCustomizers.isPresent()) {\n         List<RouterOperationCustomizer> routerOperationCustomizerList = (List)optionalRouterOperationCustomizers.get();\n\n         RouterOperationCustomizer routerOperationCustomizer;\n         for(Iterator var5 = routerOperationCustomizerList.iterator(); var5.hasNext(); routerOperation = routerOperationCustomizer.customize(routerOperation, handlerMethod)) {\n            routerOperationCustomizer = (RouterOperationCustomizer)var5.next();\n         }\n      }\n\n      return routerOperation;\n   }\n\n   protected void mergeRouters(List<RouterFunctionData> routerFunctionDatas, List<RouterOperation> routerOperationList) {\n      Iterator var3 = routerOperationList.iterator();\n\n      while(true) {\n         while(true) {\n            RouterOperation routerOperation;\n            do {\n               if (!var3.hasNext()) {\n                  return;\n               }\n\n               routerOperation = (RouterOperation)var3.next();\n            } while(!StringUtils.isNotBlank(routerOperation.getPath()));\n\n            List<RouterFunctionData> routerFunctionDataList = (List)routerFunctionDatas.stream().filter((routerFunctionData1) -> {\n               return routerFunctionData1.getPath().equals(routerOperation.getPath());\n            }).collect(Collectors.toList());\n            if (routerFunctionDataList.size() == 1) {\n               this.fillRouterOperation((RouterFunctionData)routerFunctionDataList.get(0), routerOperation);\n            } else if (routerFunctionDataList.size() > 1 && ArrayUtils.isNotEmpty(routerOperation.getMethods())) {\n               routerFunctionDataList = (List)routerFunctionDatas.stream().filter((routerFunctionData1) -> {\n                  return routerFunctionData1.getPath().equals(routerOperation.getPath()) && this.isEqualMethods(routerOperation.getMethods(), routerFunctionData1.getMethods());\n               }).collect(Collectors.toList());\n               if (routerFunctionDataList.size() == 1) {\n                  this.fillRouterOperation((RouterFunctionData)routerFunctionDataList.get(0), routerOperation);\n               } else if (routerFunctionDataList.size() > 1 && ArrayUtils.isNotEmpty(routerOperation.getProduces())) {\n                  routerFunctionDataList = (List)routerFunctionDatas.stream().filter((routerFunctionData1) -> {\n                     return routerFunctionData1.getPath().equals(routerOperation.getPath()) && this.isEqualMethods(routerOperation.getMethods(), routerFunctionData1.getMethods()) && this.isEqualArrays(routerFunctionData1.getProduces(), routerOperation.getProduces());\n                  }).collect(Collectors.toList());\n                  if (routerFunctionDataList.size() == 1) {\n                     this.fillRouterOperation((RouterFunctionData)routerFunctionDataList.get(0), routerOperation);\n                  } else if (routerFunctionDataList.size() > 1 && ArrayUtils.isNotEmpty(routerOperation.getConsumes())) {\n                     routerFunctionDataList = (List)routerFunctionDatas.stream().filter((routerFunctionData1) -> {\n                        return routerFunctionData1.getPath().equals(routerOperation.getPath()) && this.isEqualMethods(routerOperation.getMethods(), routerFunctionData1.getMethods()) && this.isEqualArrays(routerFunctionData1.getProduces(), routerOperation.getProduces()) && this.isEqualArrays(routerFunctionData1.getConsumes(), routerOperation.getConsumes());\n                     }).collect(Collectors.toList());\n                     if (routerFunctionDataList.size() == 1) {\n                        this.fillRouterOperation((RouterFunctionData)routerFunctionDataList.get(0), routerOperation);\n                     }\n                  }\n               } else if (routerFunctionDataList.size() > 1 && ArrayUtils.isNotEmpty(routerOperation.getConsumes())) {\n                  routerFunctionDataList = (List)routerFunctionDatas.stream().filter((routerFunctionData1) -> {\n                     return routerFunctionData1.getPath().equals(routerOperation.getPath()) && this.isEqualMethods(routerOperation.getMethods(), routerFunctionData1.getMethods()) && this.isEqualArrays(routerFunctionData1.getConsumes(), routerOperation.getConsumes());\n                  }).collect(Collectors.toList());\n                  if (routerFunctionDataList.size() == 1) {\n                     this.fillRouterOperation((RouterFunctionData)routerFunctionDataList.get(0), routerOperation);\n                  }\n               }\n            } else if (routerFunctionDataList.size() > 1 && ArrayUtils.isNotEmpty(routerOperation.getProduces())) {\n               routerFunctionDataList = (List)routerFunctionDatas.stream().filter((routerFunctionData1) -> {\n                  return routerFunctionData1.getPath().equals(routerOperation.getPath()) && this.isEqualArrays(routerFunctionData1.getProduces(), routerOperation.getProduces());\n               }).collect(Collectors.toList());\n               if (routerFunctionDataList.size() == 1) {\n                  this.fillRouterOperation((RouterFunctionData)routerFunctionDataList.get(0), routerOperation);\n               } else if (routerFunctionDataList.size() > 1 && ArrayUtils.isNotEmpty(routerOperation.getConsumes())) {\n                  routerFunctionDataList = (List)routerFunctionDatas.stream().filter((routerFunctionData1) -> {\n                     return routerFunctionData1.getPath().equals(routerOperation.getPath()) && this.isEqualMethods(routerOperation.getMethods(), routerFunctionData1.getMethods()) && this.isEqualArrays(routerFunctionData1.getConsumes(), routerOperation.getConsumes()) && this.isEqualArrays(routerFunctionData1.getProduces(), routerOperation.getProduces());\n                  }).collect(Collectors.toList());\n                  if (routerFunctionDataList.size() == 1) {\n                     this.fillRouterOperation((RouterFunctionData)routerFunctionDataList.get(0), routerOperation);\n                  }\n               }\n            } else if (routerFunctionDataList.size() > 1 && ArrayUtils.isNotEmpty(routerOperation.getConsumes())) {\n               routerFunctionDataList = (List)routerFunctionDatas.stream().filter((routerFunctionData1) -> {\n                  return routerFunctionData1.getPath().equals(routerOperation.getPath()) && this.isEqualArrays(routerFunctionData1.getConsumes(), routerOperation.getConsumes());\n               }).collect(Collectors.toList());\n               if (routerFunctionDataList.size() == 1) {\n                  this.fillRouterOperation((RouterFunctionData)routerFunctionDataList.get(0), routerOperation);\n               }\n            }\n         }\n      }\n   }\n\n   private void calculateJsonView(Operation apiOperation, MethodAttributes methodAttributes, Method method) {\n      JsonView jsonViewAnnotation;\n      JsonView jsonViewAnnotationForRequestBody;\n      if (apiOperation != null && apiOperation.ignoreJsonView()) {\n         jsonViewAnnotation = null;\n         jsonViewAnnotationForRequestBody = null;\n      } else {\n         jsonViewAnnotation = (JsonView)AnnotatedElementUtils.findMergedAnnotation(method, JsonView.class);\n         jsonViewAnnotationForRequestBody = (JsonView)Arrays.stream(ReflectionUtils.getParameterAnnotations(method)).filter((arr) -> {\n            return Arrays.stream(arr).anyMatch((annotation) -> {\n               return annotation.annotationType().equals(RequestBody.class) || annotation.annotationType().equals(org.springframework.web.bind.annotation.RequestBody.class);\n            });\n         }).flatMap(Arrays::stream).filter((annotation) -> {\n            return annotation.annotationType().equals(JsonView.class);\n         }).reduce((a, b) -> {\n            return null;\n         }).orElse(jsonViewAnnotation);\n      }\n\n      methodAttributes.setJsonViewAnnotation(jsonViewAnnotation);\n      methodAttributes.setJsonViewAnnotationForRequestBody(jsonViewAnnotationForRequestBody);\n   }\n\n   private boolean isEqualArrays(String[] array1, String[] array2) {\n      Arrays.sort(array1);\n      Arrays.sort(array2);\n      return Arrays.equals(array1, array2);\n   }\n\n   private boolean isEqualMethods(RequestMethod[] requestMethods1, RequestMethod[] requestMethods2) {\n      Arrays.sort(requestMethods1);\n      Arrays.sort(requestMethods2);\n      return Arrays.equals(requestMethods1, requestMethods2);\n   }\n\n   private void fillParametersList(io.swagger.v3.oas.models.Operation operation, Map<String, String> queryParams, MethodAttributes methodAttributes) {\n      List<Parameter> parametersList = operation.getParameters();\n      if (parametersList == null) {\n         parametersList = new ArrayList();\n      }\n\n      Collection<Parameter> headersMap = AbstractRequestService.getHeaders(methodAttributes, new LinkedHashMap());\n      headersMap.forEach((parameterx) -> {\n         if (!CollectionUtils.isEmpty(operation.getParameters())) {\n            Optional<Parameter> existingParam = operation.getParameters().stream().filter((p) -> {\n               return parameterx.getName().equals(p.getName());\n            }).findAny();\n            if (!existingParam.isPresent()) {\n               operation.addParametersItem(parameterx);\n            }\n         }\n\n      });\n      if (!CollectionUtils.isEmpty(queryParams)) {\n         Iterator var6 = queryParams.entrySet().iterator();\n\n         while(var6.hasNext()) {\n            Entry<String, String> entry = (Entry)var6.next();\n            Parameter parameter = new Parameter();\n            parameter.setName((String)entry.getKey());\n            parameter.setSchema((new StringSchema())._default((String)entry.getValue()));\n            parameter.setRequired(true);\n            parameter.setIn(ParameterIn.QUERY.toString());\n            GenericParameterService.mergeParameter((List)parametersList, parameter);\n         }\n\n         operation.setParameters((List)parametersList);\n      }\n\n   }\n\n   private void fillRouterOperation(RouterFunctionData routerFunctionData, RouterOperation routerOperation) {\n      if (ArrayUtils.isEmpty(routerOperation.getConsumes())) {\n         routerOperation.setConsumes(routerFunctionData.getConsumes());\n      }\n\n      if (ArrayUtils.isEmpty(routerOperation.getProduces())) {\n         routerOperation.setProduces(routerFunctionData.getProduces());\n      }\n\n      if (ArrayUtils.isEmpty(routerOperation.getHeaders())) {\n         routerOperation.setHeaders(routerFunctionData.getHeaders());\n      }\n\n      if (ArrayUtils.isEmpty(routerOperation.getMethods())) {\n         routerOperation.setMethods(routerFunctionData.getMethods());\n      }\n\n      if (CollectionUtils.isEmpty(routerOperation.getQueryParams())) {\n         routerOperation.setQueryParams(routerFunctionData.getQueryParams());\n      }\n\n   }\n\n   private PathItem buildPathItem(RequestMethod requestMethod, io.swagger.v3.oas.models.Operation operation, String operationPath, Paths paths) {\n      if (operation != null && !CollectionUtils.isEmpty(operation.getParameters())) {\n         Iterator paramIt = operation.getParameters().iterator();\n\n         while(paramIt.hasNext()) {\n            Parameter parameter = (Parameter)paramIt.next();\n            if (ParameterIn.PATH.toString().equals(parameter.getIn())) {\n               String name = parameter.getName();\n               if (!StringUtils.containsAny(operationPath, new CharSequence[]{\"{\" + name + \"}\", \"{*\" + name + \"}\"})) {\n                  paramIt.remove();\n               }\n            }\n         }\n      }\n\n      PathItem pathItemObject;\n      if (paths.containsKey(operationPath)) {\n         pathItemObject = (PathItem)paths.get(operationPath);\n      } else {\n         pathItemObject = new PathItem();\n      }\n\n      switch(requestMethod) {\n      case POST:\n         pathItemObject.post(operation);\n         break;\n      case GET:\n         pathItemObject.get(operation);\n         break;\n      case DELETE:\n         pathItemObject.delete(operation);\n         break;\n      case PUT:\n         pathItemObject.put(operation);\n         break;\n      case PATCH:\n         pathItemObject.patch(operation);\n         break;\n      case TRACE:\n         pathItemObject.trace(operation);\n         break;\n      case HEAD:\n         pathItemObject.head(operation);\n         break;\n      case OPTIONS:\n         pathItemObject.options(operation);\n      }\n\n      return pathItemObject;\n   }\n\n   private io.swagger.v3.oas.models.Operation getExistingOperation(Map<HttpMethod, io.swagger.v3.oas.models.Operation> operationMap, RequestMethod requestMethod) {\n      io.swagger.v3.oas.models.Operation existingOperation = null;\n      if (!CollectionUtils.isEmpty(operationMap)) {\n         switch(requestMethod) {\n         case POST:\n            existingOperation = (io.swagger.v3.oas.models.Operation)operationMap.get(HttpMethod.POST);\n            break;\n         case GET:\n            existingOperation = (io.swagger.v3.oas.models.Operation)operationMap.get(HttpMethod.GET);\n            break;\n         case DELETE:\n            existingOperation = (io.swagger.v3.oas.models.Operation)operationMap.get(HttpMethod.DELETE);\n            break;\n         case PUT:\n            existingOperation = (io.swagger.v3.oas.models.Operation)operationMap.get(HttpMethod.PUT);\n            break;\n         case PATCH:\n            existingOperation = (io.swagger.v3.oas.models.Operation)operationMap.get(HttpMethod.PATCH);\n         case TRACE:\n         default:\n            break;\n         case HEAD:\n            existingOperation = (io.swagger.v3.oas.models.Operation)operationMap.get(HttpMethod.HEAD);\n            break;\n         case OPTIONS:\n            existingOperation = (io.swagger.v3.oas.models.Operation)operationMap.get(HttpMethod.OPTIONS);\n         }\n      }\n\n      return existingOperation;\n   }\n\n   private io.swagger.v3.oas.models.Operation getOperation(RouterOperation routerOperation, io.swagger.v3.oas.models.Operation existingOperation) {\n      io.swagger.v3.oas.models.Operation operationModel = routerOperation.getOperationModel();\n      io.swagger.v3.oas.models.Operation operation;\n      if (existingOperation != null && operationModel == null) {\n         operation = existingOperation;\n      } else if (existingOperation == null && operationModel != null) {\n         operation = operationModel;\n      } else if (existingOperation != null) {\n         operation = this.operationParser.mergeOperation(existingOperation, operationModel);\n      } else {\n         operation = new io.swagger.v3.oas.models.Operation();\n      }\n\n      return operation;\n   }\n\n   protected void initOpenAPIBuilder(Locale locale) {\n      locale = locale == null ? Locale.getDefault() : locale;\n      if (this.openAPIService.getCachedOpenAPI(locale) != null && this.springDocConfigProperties.isCacheDisabled()) {\n         this.openAPIService = (OpenAPIService)this.openAPIBuilderObjectFactory.getObject();\n      }\n\n   }\n\n   protected byte[] writeYamlValue(OpenAPI openAPI) throws JsonProcessingException {\n      ObjectMapper objectMapper = this.springDocProviders.yamlMapper();\n      if (this.springDocConfigProperties.isWriterWithOrderByKeys()) {\n         ObjectMapperProvider.sortOutput(objectMapper, this.springDocConfigProperties);\n      }\n\n      YAMLFactory factory = (YAMLFactory)objectMapper.getFactory();\n      factory.configure(Feature.USE_NATIVE_TYPE_ID, false);\n      String result;\n      if (!this.springDocConfigProperties.isWriterWithDefaultPrettyPrinter()) {\n         result = objectMapper.writerFor(OpenAPI.class).writeValueAsString(openAPI);\n      } else {\n         result = objectMapper.writerWithDefaultPrettyPrinter().forType(OpenAPI.class).writeValueAsString(openAPI);\n      }\n\n      return result.getBytes(StandardCharsets.UTF_8);\n   }\n\n   protected URI getActuatorURI(String scheme, String host) {\n      Optional<ActuatorProvider> actuatorProviderOptional = this.springDocProviders.getActuatorProvider();\n      URI uri = null;\n      if (actuatorProviderOptional.isPresent()) {\n         ActuatorProvider actuatorProvider = (ActuatorProvider)actuatorProviderOptional.get();\n         int port;\n         String path;\n         if (\"x-actuator\".equals(this.groupName)) {\n            port = actuatorProvider.getActuatorPort();\n            path = actuatorProvider.getActuatorPath();\n         } else {\n            port = actuatorProvider.getApplicationPort();\n            path = actuatorProvider.getContextPath();\n            String mvcServletPath = ((Environment)this.openAPIService.getContext().getBean(Environment.class)).getProperty(\"spring.mvc.servlet.path\");\n            if (SpringDocUtils.isValidPath(mvcServletPath)) {\n               path = path + mvcServletPath;\n            }\n         }\n\n         try {\n            uri = new URI((String)StringUtils.defaultIfEmpty(scheme, \"http\"), (String)null, (String)StringUtils.defaultIfEmpty(host, \"localhost\"), port, path, (String)null, (String)null);\n         } catch (URISyntaxException var9) {\n            LOGGER.error(\"Unable to parse the URL: scheme {}, host {}, port {}, path {}\", new Object[]{scheme, host, port, path});\n         }\n      }\n\n      return uri;\n   }\n\n   protected boolean isActuatorRestController(String operationPath, HandlerMethod handlerMethod) {\n      Optional<ActuatorProvider> actuatorProviderOptional = this.springDocProviders.getActuatorProvider();\n      boolean isActuatorRestController = false;\n      if (actuatorProviderOptional.isPresent()) {\n         isActuatorRestController = ((ActuatorProvider)actuatorProviderOptional.get()).isRestController(operationPath, handlerMethod);\n      }\n\n      return this.springDocConfigProperties.isShowActuator() && isActuatorRestController && (modelAndViewClass == null || !modelAndViewClass.isAssignableFrom(handlerMethod.getMethod().getReturnType()));\n   }\n\n   protected byte[] writeJsonValue(OpenAPI openAPI) throws JsonProcessingException {\n      ObjectMapper objectMapper = this.springDocProviders.jsonMapper();\n      if (this.springDocConfigProperties.isWriterWithOrderByKeys()) {\n         ObjectMapperProvider.sortOutput(objectMapper, this.springDocConfigProperties);\n      }\n\n      String result;\n      if (!this.springDocConfigProperties.isWriterWithDefaultPrettyPrinter()) {\n         result = objectMapper.writerFor(OpenAPI.class).writeValueAsString(openAPI);\n      } else {\n         result = objectMapper.writerWithDefaultPrettyPrinter().forType(OpenAPI.class).writeValueAsString(openAPI);\n      }\n\n      return result.getBytes(StandardCharsets.UTF_8);\n   }\n\n   private List<String> getConditionsToMatch(AbstractOpenApiResource.ConditionType conditionType, GroupConfig... groupConfigs) {\n      List<String> conditionsToMatch = null;\n      GroupConfig groupConfig = null;\n      if (ArrayUtils.isNotEmpty(groupConfigs)) {\n         groupConfig = groupConfigs[0];\n      }\n\n      switch(conditionType) {\n      case HEADERS:\n         conditionsToMatch = groupConfig != null ? groupConfig.getHeadersToMatch() : this.springDocConfigProperties.getHeadersToMatch();\n         break;\n      case PRODUCES:\n         conditionsToMatch = groupConfig != null ? groupConfig.getProducesToMatch() : this.springDocConfigProperties.getProducesToMatch();\n         break;\n      case CONSUMES:\n         conditionsToMatch = groupConfig != null ? groupConfig.getConsumesToMatch() : this.springDocConfigProperties.getConsumesToMatch();\n      }\n\n      return conditionsToMatch;\n   }\n\n   private boolean isFilterCondition(String operationPath, String[] produces, String[] consumes, String[] headers) {\n      return this.isPathToMatch(operationPath) && this.isConditionToMatch(produces, AbstractOpenApiResource.ConditionType.PRODUCES) && this.isConditionToMatch(consumes, AbstractOpenApiResource.ConditionType.CONSUMES) && this.isConditionToMatch(headers, AbstractOpenApiResource.ConditionType.HEADERS);\n   }\n\n   private RouterOperation customizeDataRestRouterOperation(RouterOperation routerOperation) {\n      Optional<List<DataRestRouterOperationCustomizer>> optionalDataRestRouterOperationCustomizers = this.springDocCustomizers.getDataRestRouterOperationCustomizers();\n      if (optionalDataRestRouterOperationCustomizers.isPresent()) {\n         List<DataRestRouterOperationCustomizer> dataRestRouterOperationCustomizerList = (List)optionalDataRestRouterOperationCustomizers.get();\n\n         DataRestRouterOperationCustomizer dataRestRouterOperationCustomizer;\n         for(Iterator var4 = dataRestRouterOperationCustomizerList.iterator(); var4.hasNext(); routerOperation = dataRestRouterOperationCustomizer.customize(routerOperation)) {\n            dataRestRouterOperationCustomizer = (DataRestRouterOperationCustomizer)var4.next();\n         }\n      }\n\n      return routerOperation;\n   }\n\n   static enum ConditionType {\n      PRODUCES,\n      CONSUMES,\n      HEADERS;\n   }\n}\n"}